# -*- coding: utf-8-bom -*-
#Requires -Version 5.1

# Author: Lukian Poleschtschuk
# Version: 1.0.0
# Created: 2025-06-04
# Last Modified: 2025-06-06
# Change Log: Updated version control header

<#
.SYNOPSIS

# Module-scope context variable
$script:ModuleContext = $null

# Lazy initialization function
function Get-ModuleContext {
    if ($null -eq $script:ModuleContext) {
        if ($null -ne $global:MandA) {
            $script:ModuleContext = $global:MandA
        } else {
            throw "Module context not available"
        }
    }
    return $script:ModuleContext
}


function Invoke-SafeModuleExecution {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [scriptblock]$ScriptBlock,
        
        [Parameter(Mandatory=$true)]
        [string]$ModuleName,
        
        [Parameter(Mandatory=$false)]
        $Context
    )
    
    $result = @{
        Success = $false
        Data = $null
        Error = $null
        Duration = $null
    }
    
    $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()
    
    try {
        # Validate global context
        if (-not $global:MandA -or -not $global:MandA.Initialized) {
            throw "Global M&A context not initialized"
        }
        
        # Execute the module function
        $result.Data = & $ScriptBlock
        $result.Success = $true
        
    } catch {
        $result.Error = @{
            Message = $_.Exception.Message
            Type = $_.Exception.GetType().FullName
            StackTrace = $_.ScriptStackTrace
            InnerException = if ($_.Exception.InnerException) { $_.Exception.InnerException.Message } else { $null }
        }
        
        # Log to both file and console
        if (Get-Command Write-MandALog -ErrorAction SilentlyContinue) {
            Write-MandALog -Message "[$ModuleName] Error: $($_.Exception.Message)" -Level "ERROR" -Component $ModuleName -Context $Context
        } else {
            Write-Host "[$ModuleName] Error: $($_.Exception.Message)" -ForegroundColor Red
        }
        
        # Don't rethrow - let caller handle based on result
    } finally {
        $stopwatch.Stop()
        $result.Duration = $stopwatch.Elapsed
    }
    
    return $result
}


    Base module providing common functionality for all discovery modules
.DESCRIPTION
    Provides standardized interfaces, error handling, retry logic, and performance tracking
.NOTES
    Author: Enhanced M&A Discovery Suite
    Version: 2.0.0
#>


#Cant use $outputPath here, as it is used in the module 
# Base discovery result class
class DiscoveryResult {
    [bool]$Success
    [string]$ModuleName
    [int]$RecordCount
    [timespan]$Duration
    [datetime]$Timestamp
    [hashtable]$Metadata
    [object[]]$Data
    [object[]]$Errors
    [object[]]$Warnings
    
    {
    try {
        $this.ModuleName = $moduleName
        $this.Timestamp = Get-Date
        $this.Metadata = @{}
        $this.Errors = @()
        $this.Warnings = @()
    } catch {
        Write-MandALog "Error in function 'DiscoveryResult': $($_.Exception.Message)" "ERROR"
        throw
    }
}
}

# Performance tracker for discovery operations
class DiscoveryPerformanceTracker {
    [hashtable]$Operations = @{}
    [System.Diagnostics.Stopwatch]$TotalTimer
    
    DiscoveryPerformanceTracker() {
        $this.TotalTimer = [System.Diagnostics.Stopwatch]::StartNew()
    }
    
    [void]{
    try {
        $this.Operations[$OperationName] = @{
            StartTime = Get-Date
            Stopwatch = [System.Diagnostics.Stopwatch]::StartNew()
            MemoryBefore = (Get-Process -Id ([System.Diagnostics.Process]::GetCurrentProcess().Id)).WorkingSet64
        }
    } catch {
        Write-MandALog "Error in function 'StartOperation': $($_.Exception.Message)" "ERROR"
        throw
    }
}
    
    [void]{
    try {
        if ($this.Operations.ContainsKey($OperationName)) {
            $op = $this.Operations[$OperationName]
            $op.Stopwatch.Stop()
            $op.Duration = $op.Stopwatch.Elapsed
            $op.ItemsProcessed = $ItemsProcessed
            $op.MemoryAfter = (Get-Process -Id ([System.Diagnostics.Process]::GetCurrentProcess().Id)).WorkingSet64
            $op.MemoryDelta = $op.MemoryAfter - $op.MemoryBefore
            
            if ($ItemsProcessed -gt 0 -and $op.Duration.TotalSeconds -gt 0) {
                $op.ItemsPerSecond = [math]::Round($ItemsProcessed / $op.Duration.TotalSeconds, 2)
            }
        }
    } catch {
        Write-MandALog "Error in function 'EndOperation': $($_.Exception.Message)" "ERROR"
        throw
    }
}
    
    [PSObject]{
    try {
        return [PSCustomObject]@{
            TotalDuration = $this.TotalTimer.Elapsed
            Operations = $this.Operations
        }
    } catch {
        Write-MandALog "Error in function 'GetReport': $($_.Exception.Message)" "ERROR"
        throw
    }
}
}

# Circuit breaker for external service calls
class CircuitBreaker {
    [string]$ServiceName
    [int]$FailureThreshold = 3
    [int]$FailureCount = 0
    [datetime]$LastFailureTime
    [timespan]$Timeout = [timespan]::FromMinutes(5)
    [bool]$IsOpen = $false
    [string]$State = "Closed" # Closed, Open, HalfOpen
    
    CircuitBreaker([string]$serviceName) {
        $this.ServiceName = $serviceName
    }
    
    [bool]{
    try {
        switch ($this.State) {
            "Closed" { return $true }
            "Open" {
                if ((Get-Date) - $this.LastFailureTime -gt $this.Timeout) {
                    $this.State = "HalfOpen"
                    return $true
                }
                return $false
            }
            "HalfOpen" { return $true }
        }
        return $false
    } catch {
        Write-MandALog "Error in function 'CanAttempt': $($_.Exception.Message)" "ERROR"
        throw
    }
}
    
    [void]{
    try {
        $this.FailureCount = 0
        $this.State = "Closed"
        $this.IsOpen = $false
    } catch {
        Write-MandALog "Error in function 'RecordSuccess': $($_.Exception.Message)" "ERROR"
        throw
    }
}
    
    [void]{
    try {
        $this.FailureCount++
        $this.LastFailureTime = Get-Date
        
        if ($this.State -eq "HalfOpen" -or $this.FailureCount -ge $this.FailureThreshold) {
            $this.State = "Open"
            $this.IsOpen = $true
        }
    } catch {
        Write-MandALog "Error in function 'RecordFailure': $($_.Exception.Message)" "ERROR"
        throw
    }
}
}

# Enhanced retry mechanism with circuit breaker
function Invoke-DiscoveryWithRetry {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [scriptblock]$ScriptBlock,
        
        [Parameter(Mandatory=$false)]
        [string]$OperationName = "Operation",
        
        [Parameter(Mandatory=$false)]
        [int]$MaxRetries = 3,
        
        [Parameter(Mandatory=$false)]
        [int]$InitialDelaySeconds = 2,
        
        [Parameter(Mandatory=$false)]
        [CircuitBreaker]$CircuitBreaker,
        
        [Parameter(Mandatory=$false)]
        $Context
    )
    
    # Check circuit breaker
    if ($CircuitBreaker -and -not $CircuitBreaker.CanAttempt()) {
        throw "Circuit breaker is open for $($CircuitBreaker.ServiceName). Too many failures."
    }
    
    $attempt = 0
    $lastError = $null
    
    while ($attempt -lt $MaxRetries) {
        $attempt++
        
        try {
            if ($Context) {
                Write-MandALog "Executing $OperationName (attempt $attempt of $MaxRetries)" -Level "DEBUG" -Context $Context
            }
            
            $result = & $ScriptBlock
            
            # Success - reset circuit breaker
            if ($CircuitBreaker) {
                $CircuitBreaker.RecordSuccess()
            }
            
            return $result
            
        } catch {
            $lastError = $_
            
            # Check if error is retryable
            $isRetryable = Test-RetryableError -Exception $_.Exception
            
            if ($CircuitBreaker) {
                $CircuitBreaker.RecordFailure($_.Exception)
            }
            
            if ($attempt -lt $MaxRetries -and $isRetryable) {
                $delay = Calculate-BackoffDelay -Attempt $attempt -InitialDelay $InitialDelaySeconds -Exception $_.Exception
                
                if ($Context) {
                    Write-MandALog "Retryable error in $OperationName. Waiting $delay seconds before retry..." -Level "WARN" -Context $Context
                }
                
                Start-Sleep -Seconds $delay
            } else {
                break
            }
        }
    }
    
    # All retries exhausted
    throw $lastError
}


    param([Exception]$Exception)
    
    # HTTP status codes that are retryable
    $retryableStatusCodes = @(408, 429, 500, 502, 503, 504)
    
    if ($Exception.Response -and $Exception.Response.StatusCode) {
        return $Exception.Response.StatusCode.value__ -in $retryableStatusCodes
    }
    
    
    try {
        # Check for specific exception types
    $retryableTypes = @(
        'System.Net.WebException',
        'System.Net.Http.HttpRequestException',
        'System.TimeoutException',
        'System.IO.IOException'
    )
    
    $exceptionType = $Exception.GetType().FullName
    if ($exceptionType -in $retryableTypes) {
        return $true
    }
    
    # Check error messages
    $retryableMessages = @('timeout', 'temporary', 'transient', 'throttl', 'rate limit', 'busy', 'unavailable')
    $message = $Exception.Message.ToLower()
    
    foreach ($keyword in $retryableMessages) {
        if ($message -contains $keyword) {
            return $true
        }
    }
    
    return $false
    } catch {
        Write-MandALog "Error in function 'Test-RetryableError': $($_.Exception.Message)" "ERROR"
        throw
    }
}


    param(
        [int]$Attempt,
        [int]$InitialDelay,
        [Exception]$Exception
    )
    
    # Check for Retry-After header (rate limiting)
    if ($Exception.Response -and $Exception.Response.Headers -and $Exception.Response.Headers.RetryAfter) {
        $retryAfter = $Exception.Response.Headers.RetryAfter
        if ($retryAfter.Delta) {
            return [math]::Ceiling($retryAfter.Delta.TotalSeconds)
        }
    
    try {
        }
    
    # Exponential backoff with jitter
    $exponentialDelay = $InitialDelay * [math]::Pow(2, $Attempt - 1)
    $jitter = Get-Random -Minimum 0 -Maximum ($exponentialDelay * 0.1)
    
    return [math]::Min($exponentialDelay + $jitter, 300) # Cap at 5 minutes
    } catch {
        Write-MandALog "Error in function 'Calculate-BackoffDelay': $($_.Exception.Message)" "ERROR"
        throw
    }
}

# Base function for all discovery modules
function Invoke-BaseDiscovery {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$ModuleName,
        
        [Parameter(Mandatory=$true)]
        [scriptblock]$DiscoveryScript,
        
        [Parameter(Mandatory=$true)]
        [hashtable]$Configuration,
        
        [Parameter(Mandatory=$true)]
        $Context,
        
        [Parameter(Mandatory=$false)]
        [string[]]$RequiredPermissions = @(),
        
        [Parameter(Mandatory=$false)]
        [CircuitBreaker]$CircuitBreaker
    )
    
    $result = [DiscoveryResult]::new($ModuleName)
    $performanceTracker = [DiscoveryPerformanceTracker]::new()
    
    try {
        Write-MandALog "Starting $ModuleName Discovery" -Level "HEADER" -Context $Context
        $performanceTracker.StartOperation("Total")
        
        # Validate configuration
        $performanceTracker.StartOperation("Validation")
        Test-DiscoveryPrerequisites -ModuleName $ModuleName -Configuration $Configuration -Context $Context -RequiredPermissions $RequiredPermissions
        $performanceTracker.EndOperation("Validation")
        
        # Check for existing data
        $outputPath = Join-Path $Configuration.environment.outputPath "Raw"
        if ($Configuration.discovery.skipExistingFiles) {
            $existingData = Get-ExistingDiscoveryData -ModuleName $ModuleName -OutputPath $outputPath -Context $Context
            if ($existingData) {
                Write-MandALog "Using existing data for $ModuleName (skipExistingFiles=true)" -Level "INFO" -Context $Context
                $result.Success = $true
                $result.Data = $existingData
                $result.RecordCount = $existingData.Count
                $result.Metadata["DataSource"] = "ExistingFile"
                return $result
            }
        }
        
        # Execute discovery
        $performanceTracker.StartOperation("Discovery")
        $discoveryData = & $DiscoveryScript
        $performanceTracker.EndOperation("Discovery", $discoveryData.Count)
        
        # Validate data quality
        $performanceTracker.StartOperation("DataValidation")
        $validation = Test-DiscoveryDataQuality -Data $discoveryData -ModuleName $ModuleName -Context $Context
        if ($validation.Warnings) {
            $result.Warnings += $validation.Warnings
        }
        $performanceTracker.EndOperation("DataValidation")
        
        # Export data
        $performanceTracker.StartOperation("Export")
        Export-DiscoveryData -Data $discoveryData -ModuleName $ModuleName -OutputPath $outputPath -Context $Context
        $performanceTracker.EndOperation("Export")
        
        # Success
        $performanceTracker.EndOperation("Total", $discoveryData.Count)
        
        $result.Success = $true
        $result.Data = $discoveryData
        $result.RecordCount = $discoveryData.Count
        $result.Duration = $performanceTracker.TotalTimer.Elapsed
        $result.Metadata["Performance"] = $performanceTracker.GetReport()
        
        Write-MandALog "$ModuleName Discovery completed successfully: $($discoveryData.Count) records in $($result.Duration.TotalSeconds) seconds" -Level "SUCCESS" -Context $Context
        
        return $result
        
    } catch {
        $result.Success = $false
        $result.Errors += [PSCustomObject]@{
            Message = $_.Exception.Message
            Type = $_.Exception.GetType().FullName
            StackTrace = $_.ScriptStackTrace
        }
        
        $Context.ErrorCollector.AddError($ModuleName, "Discovery failed", $_.Exception)
        Write-MandALog "Error in $ModuleName discovery: $($_.Exception.Message)" -Level "ERROR" -Context $Context
        
        throw
        
    } finally {
        # Log performance metrics
        if ($Context -and $performanceTracker) {
            $perfReport = $performanceTracker.GetReport()
            Write-MandALog "Performance metrics for $ModuleName`: $($perfReport | ConvertTo-Json -Compress)" -Level "DEBUG" -Context $Context
        }
    }
}


    param(
        [string]$ModuleName,
        [hashtable]$Configuration,
        $Context,
        [string[]]$RequiredPermissions
    )
    
    Write-MandALog "Validating prerequisites for $ModuleName" -Level "DEBUG" -Context $Context
    
    # Check required configuration sections
    $requiredConfigs = Get-RequiredConfiguration -ModuleName $ModuleName
    foreach ($configPath in $requiredConfigs) {
        $value = $Configuration
        $pathParts = $configPath.Split('.')
        
        foreach ($part in $pathParts) {
            if ($null -eq $value -or -not $value.ContainsKey($part)) {
                throw "Missing required configuration: $configPath"
            }
            
    try {
        $value = $value[$part]
        }
        
        if ($null -eq $value -or $value -eq '') {
            throw "Empty required configuration: $configPath"
        }
    }
    
    # Check permissions if specified
    if ($RequiredPermissions.Count -gt 0) {
        Write-MandALog "Checking required permissions: $($RequiredPermissions -join ', ')" -Level "DEBUG" -Context $Context
        # Implementation depends on your permission checking mechanism
    }
    
    return $true
    } catch {
        Write-MandALog "Error in function 'Test-DiscoveryPrerequisites': $($_.Exception.Message)" "ERROR"
        throw
    }
}


    param([string]$ModuleName)
    
    $configMap = @{
        'ExternalIdentity' = @('authentication.tenantId', 'graphAPI.pageSize')
        'FileServer' = @('discovery.fileServer.targetServers', 'discovery.fileServer.timeoutPerServerRemoteCommandSeconds')
        'GPO' = @('environment.domainController')
        'Graph' = @('authentication.tenantId', 'authentication.clientId', 'graphAPI.selectFields')
    }
    
    
    try {
        return if ($configMap.ContainsKey($ModuleName)) { $configMap[$ModuleName] } else { @() }
    } catch {
        Write-MandALog "Error in function 'Get-RequiredConfiguration': $($_.Exception.Message)" "ERROR"
        throw
    }
}

function Get-ExistingDiscoveryData {
    param(
        [string]$ModuleName,
        [string]$OutputPath,
        $Context
    )
    
    # Define expected file names for each module
    $fileMap = @{
        'ExternalIdentity' = @('B2BGuestUsers.csv', 'ExternalCollaborationSettings.csv', 'GuestUserActivityAnalysis.csv')
        'FileServer' = @('FileServers.csv', 'FileShares.csv', 'DFSNamespaces.csv')
        'GPO' = @('GroupPolicies.csv', 'GroupPolicyLinks.csv', 'GPODriveMappings.csv')
        'Graph' = @('GraphUsers.csv', 'GraphGroups.csv')
    }
    
    $expectedFiles = $fileMap[$ModuleName]
    if (-not $expectedFiles) {
        return $null
    }
    
    $existingData = @{}
    $allFilesExist = $true
    
    foreach ($fileName in $expectedFiles) {
        $filePath = Join-Path $OutputPath $fileName
        if (Test-Path $filePath) {
            try {
                $data = Import-Csv -Path $filePath -ErrorAction Stop
                $existingData[$fileName -replace '\.csv$', ''] = $data
                Write-MandALog "Loaded existing file: $fileName ($($data.Count) records)" -Level "DEBUG" -Context $Context
            } catch {
                Write-MandALog "Failed to load existing file $fileName`: $($_.Exception.Message)" -Level "WARN" -Context $Context
                $allFilesExist = $false
                break
            }
        } else {
            $allFilesExist = $false
            break
        }
    }
    
    return if ($allFilesExist) { $existingData } else { $null }
}


    param(
        [object[]]$Data,
        [string]$ModuleName,
        $Context
    )
    
    $warnings = @()
    
    if ($null -eq $Data -or $Data.Count -eq 0) {
        $warnings += "No data returned from discovery"
        return @{ Warnings = $warnings }
    
    try {
        }
    
    # Module-specific validation rules
    $validationRules = Get-DataValidationRules -ModuleName $ModuleName
    
    if ($validationRules.RequiredFields) {
        $sampleSize = [math]::Min(100, $Data.Count)
        $sample = $Data | Select-Object -First $sampleSize
        
        foreach ($item in $sample) {
            foreach ($field in $validationRules.RequiredFields) {
                if (-not $item.PSObject.Properties[$field] -or [string]::IsNullOrWhiteSpace($item.$field)) {
                    $warnings += "Missing required field '$field' in some records"
                    break
                }
            }
        }
    }
    
    # Check for duplicate IDs if applicable
    if ($validationRules.UniqueIdField -and $Data.Count -gt 1) {
        $uniqueIds = $Data | Select-Object -ExpandProperty $validationRules.UniqueIdField -Unique
        if ($uniqueIds.Count -lt $Data.Count) {
            $duplicateCount = $Data.Count - $uniqueIds.Count
            $warnings += "Found $duplicateCount duplicate records based on $($validationRules.UniqueIdField)"
        }
    }
    
    return @{ Warnings = $warnings }
    } catch {
        Write-MandALog "Error in function 'Test-DiscoveryDataQuality': $($_.Exception.Message)" "ERROR"
        throw
    }
}


    param([string]$ModuleName)
    
    $rules = @{
        'ExternalIdentity' = @{
            RequiredFields = @('GuestId', 'UserPrincipalName')
            UniqueIdField = 'GuestId'
        }
        
    try {
        'FileServer' = @{
            RequiredFields = @('ServerName')
            UniqueIdField = 'ServerName'
        }
        'GPO' = @{
            RequiredFields = @('Id', 'DisplayName')
            UniqueIdField = 'Id'
        }
        'Graph' = @{
            RequiredFields = @('id', 'userPrincipalName')
            UniqueIdField = 'id'
        }
    }
    
    return if ($rules.ContainsKey($ModuleName)) { $rules[$ModuleName] } else { @{} }
    } catch {
        Write-MandALog "Error in function 'Get-DataValidationRules': $($_.Exception.Message)" "ERROR"
        throw
    }
}


    param(
        [object[]]$Data,
        [string]$ModuleName,
        [string]$OutputPath,
        $Context,
        [hashtable]$FileMap = $null
    )
    
    if (-not (Test-Path $OutputPath)) {
        New-Item -Path $OutputPath -ItemType Directory -Force | Out-Null
    }
    
    
    try {
        # Add metadata to each record
    $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
    $enrichedData = $Data | ForEach-Object {
        $_ | Add-Member -NotePropertyName '_DiscoveryTimestamp' -NotePropertyValue $timestamp -PassThru -ErrorAction SilentlyContinue
        $_ | Add-Member -NotePropertyName '_DiscoveryVersion' -NotePropertyValue $Context.Version -PassThru -ErrorAction SilentlyContinue
        $_ | Add-Member -NotePropertyName '_DiscoveryModule' -NotePropertyValue $ModuleName -PassThru -ErrorAction SilentlyContinue
    }
    
    # Handle different data structures
    if ($FileMap) {
        # Multiple files (like ExternalIdentity module)
        foreach ($key in $FileMap.Keys) {
            $fileName = $FileMap[$key]
            $filePath = Join-Path $OutputPath $fileName
            $fileData = $enrichedData | Where-Object { $_._DataType -eq $key }
            
            if ($fileData) {
                $fileData | Export-Csv -Path $filePath -NoTypeInformation -Force -Encoding UTF8
                Write-MandALog "Exported $($fileData.Count) records to $fileName" -Level "DEBUG" -Context $Context
            }
        }
    } else {
        # Single file export
        $fileName = "$ModuleName.csv"
        $filePath = Join-Path $OutputPath $fileName
        $enrichedData | Export-Csv -Path $filePath -NoTypeInformation -Force -Encoding UTF8
        Write-MandALog "Exported $($enrichedData.Count) records to $fileName" -Level "DEBUG" -Context $Context
    }
    } catch {
        Write-MandALog "Error in function 'Export-DiscoveryData': $($_.Exception.Message)" "ERROR"
        throw
    }
}

# Export module members
Export-ModuleMember -Function @(
    'Invoke-BaseDiscovery',
    'Invoke-DiscoveryWithRetry',
    'Test-RetryableError',
    'Calculate-BackoffDelay',
    'Test-DiscoveryPrerequisites',
    'Get-ExistingDiscoveryData',
    'Test-DiscoveryDataQuality',
    'Export-DiscoveryData'
) -Variable @() -Alias @()

# Export classes
Export-ModuleMember -Function * -Variable * -Alias * -Cmdlet *



