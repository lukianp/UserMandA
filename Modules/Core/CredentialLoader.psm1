# -*- coding: utf-8-bom -*-
#Requires -Version 5.1

# Author: Lukian Poleschtschuk
# Version: 1.0.0
# Created: 2025-08-03
# Last Modified: 2025-08-03

<#
.SYNOPSIS
    Credential loader for M&A Discovery Suite
.DESCRIPTION
    Loads credentials from the company profile's credentials configuration file.
    Supports the discoverycredentials.config format generated by the app registration.
.NOTES
    Version: 1.0.0
    Author: Lukian Poleschtschuk
    Created: 2025-08-03
    Requires: PowerShell 5.1+
#>

function Get-CompanyCredentials {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$CompanyName,
        
        [Parameter(Mandatory=$false)]
        [string]$CredentialsPath
    )
    
    try {
        # Import security module for encrypted credential support
        Import-Module -Name "$PSScriptRoot\CredentialSecurity.psm1" -Force -ErrorAction SilentlyContinue
        
        # Use secure credential loading if available, fallback to basic loading
        if (Get-Command Get-SecureCompanyCredentials -ErrorAction SilentlyContinue) {
            return Get-SecureCompanyCredentials -CompanyName $CompanyName -CredentialsPath $CredentialsPath
        }
        
        # Fallback to basic credential loading
        # If no path provided, use default company profile path
        if (-not $CredentialsPath) {
            # Try both possible path structures
            $primaryPath = "c:\discoverydata\$CompanyName\Credentials\discoverycredentials.config"
            $fallbackPath = "c:\discoverydata\Profiles\$CompanyName\Credentials\discoverycredentials.config"
            
            if (Test-Path $primaryPath) {
                $CredentialsPath = $primaryPath
            } elseif (Test-Path $fallbackPath) {
                $CredentialsPath = $fallbackPath
            } else {
                $CredentialsPath = $primaryPath  # Use primary path for error message consistency
            }
        }
        
        # Check if credentials file exists
        if (-not (Test-Path $CredentialsPath)) {
            throw "Credentials file not found: $CredentialsPath"
        }
        
        # Load credentials from JSON file
        $credentials = Get-Content -Path $CredentialsPath -Raw | ConvertFrom-Json
        
        # Validate required fields
        if (-not $credentials.TenantId) {
            throw "TenantId not found in credentials file"
        }
        
        if (-not $credentials.ClientId) {
            throw "ClientId not found in credentials file"
        }
        
        if (-not $credentials.ClientSecret) {
            throw "ClientSecret not found in credentials file"
        }
        
        # Return standardized credential object
        return @{
            TenantId = $credentials.TenantId
            ClientId = $credentials.ClientId
            ClientSecret = $credentials.ClientSecret
            ApplicationName = $credentials.ApplicationName
            ExpiryDate = $credentials.ExpiryDate
            CreatedDate = $credentials.CreatedDate
            AzureRoles = $credentials.AzureRoles
            AzureADRoles = $credentials.AzureADRoles
            PermissionCount = $credentials.PermissionCount
            IsEncrypted = $false
        }
    }
    catch {
        Write-Error "Failed to load credentials for company '$CompanyName': $($_.Exception.Message)"
        throw
    }
}

function Test-CredentialExpiry {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [hashtable]$Credentials
    )
    
    try {
        if (-not $Credentials.ExpiryDate) {
            return @{ Valid = $true; Message = "No expiry date specified" }
        }
        
        $expiryDate = [DateTime]::Parse($Credentials.ExpiryDate)
        $daysUntilExpiry = ($expiryDate - [DateTime]::Now).TotalDays
        
        if ($daysUntilExpiry -le 0) {
            return @{ Valid = $false; Message = "Credentials expired on $($Credentials.ExpiryDate)" }
        }
        
        if ($daysUntilExpiry -le 30) {
            return @{ Valid = $true; Warning = $true; Message = "Credentials expire in $([Math]::Round($daysUntilExpiry)) days" }
        }
        
        return @{ Valid = $true; Message = "Credentials valid for $([Math]::Round($daysUntilExpiry)) days" }
    }
    catch {
        return @{ Valid = $false; Message = "Failed to validate expiry: $($_.Exception.Message)" }
    }
}

function ConvertTo-SecureCredentials {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [hashtable]$Credentials
    )
    
    try {
        return @{
            TenantId = $Credentials.TenantId
            ClientId = $Credentials.ClientId
            ClientSecret = ConvertTo-SecureString -String $Credentials.ClientSecret -AsPlainText -Force
            ApplicationName = $Credentials.ApplicationName
            ExpiryDate = $Credentials.ExpiryDate
        }
    }
    catch {
        Write-Error "Failed to convert credentials to secure format: $($_.Exception.Message)"
        throw
    }
}

Export-ModuleMember -Function Get-CompanyCredentials, Test-CredentialExpiry, ConvertTo-SecureCredentials

Write-Host "[CredentialLoader.psm1] Credential loader module loaded" -ForegroundColor Green