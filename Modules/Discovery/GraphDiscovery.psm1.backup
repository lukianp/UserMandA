# -*- coding: utf-8-bom -*-
#Requires -Version 5.1


# Fallback logging function if Write-MandALog is not available
if (-not (Get-Command Write-MandALog -ErrorAction SilentlyContinue)) {
    function Write-MandALog {
        param(
            [string]$Message,
            [string]$Level = "INFO",
            [string]$Component = "Discovery",
            [hashtable]$Context = @{}
        )
        $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
        Write-Host "[$timestamp] [$Level] [$Component] $Message" -ForegroundColor $(
            switch ($Level) {
                'ERROR' { 'Red' }
                'WARN' { 'Yellow' }
                'SUCCESS' { 'Green' }
                'HEADER' { 'Cyan' }
                'DEBUG' { 'Gray' }
                default { 'White' }
            }
        )
    }
}

function Write-GraphLog {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$Message,
        [string]$Level = "INFO",
        [hashtable]$Context
    )
    Write-MandALog -Message "[Graph] $Message" -Level $Level -Component "GraphDiscovery" -Context $Context
}

# --- Main Discovery Function ---

function Invoke-GraphDiscovery {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [hashtable]$Configuration,

        [Parameter(Mandatory=$true)]
        [hashtable]$Context,

        [Parameter(Mandatory=$true)]
        [string]$SessionId
    )

    Write-GraphLog -Level "HEADER" -Message "Starting Discovery (v4.0 - Clean Session Auth)" -Context $Context
    Write-GraphLog -Level "INFO" -Message "Using authentication session: $SessionId" -Context $Context
    $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()

    # 1. INITIALIZE RESULT OBJECT
    if (([System.Management.Automation.PSTypeName]'DiscoveryResult').Type) {
        $result = [DiscoveryResult]::new('Graph')
    } else {
        # Fallback to hashtable
        $result = @{
            Success      = $true; ModuleName = 'Graph'; RecordCount = 0;
            Errors       = [System.Collections.ArrayList]::new(); 
            Warnings     = [System.Collections.ArrayList]::new(); 
            Metadata     = @{};
            StartTime    = Get-Date; EndTime = $null; 
            ExecutionId  = [guid]::NewGuid().ToString();
            AddError     = { param($m, $e, $c) $this.Errors.Add(@{Message=$m; Exception=$e; Context=$c}); $this.Success = $false }.GetNewClosure()
            AddWarning   = { param($m, $c) $this.Warnings.Add(@{Message=$m; Context=$c}) }.GetNewClosure()
            Complete     = { $this.EndTime = Get-Date }.GetNewClosure()
        }
    }

    try {
        # 2. VALIDATE PREREQUISITES & CONTEXT
        Write-GraphLog -Level "INFO" -Message "Validating prerequisites..." -Context $Context
        
        if (-not $Context.Paths.RawDataOutput) {
            $result.AddError("Context is missing required 'Paths.RawDataOutput' property.", $null, $null)
            return $result
        }
        $outputPath = $Context.Paths.RawDataOutput
        Write-GraphLog -Level "DEBUG" -Message "Output path: $outputPath" -Context $Context
        
        Ensure-Path -Path $outputPath

        # 3. VALIDATE MODULE-SPECIFIC CONFIGURATION
        $pageSize = 999
        $includeSignInActivity = $false
        $includeManager = $true
        $includeDevices = $true
        $includeApplications = $true
        $includeServicePrincipals = $true
        $includeDirectoryRoles = $true
        
        if ($Configuration.discovery -and $Configuration.discovery.graph) {
            $graphConfig = $Configuration.discovery.graph
            if ($null -ne $graphConfig.includeSignInActivity) { $includeSignInActivity = $graphConfig.includeSignInActivity }
            if ($null -ne $graphConfig.includeManager) { $includeManager = $graphConfig.includeManager }
            if ($null -ne $graphConfig.includeDevices) { $includeDevices = $graphConfig.includeDevices }
            if ($null -ne $graphConfig.includeApplications) { $includeApplications = $graphConfig.includeApplications }
            if ($null -ne $graphConfig.includeServicePrincipals) { $includeServicePrincipals = $graphConfig.includeServicePrincipals }
            if ($null -ne $graphConfig.includeDirectoryRoles) { $includeDirectoryRoles = $graphConfig.includeDirectoryRoles }
        }

        # 4. AUTHENTICATE & CONNECT (NEW SESSION-BASED)
        Write-GraphLog -Level "INFO" -Message "Getting authentication for Graph service..." -Context $Context
        try {
            $graphAuth = Get-AuthenticationForService -Service "Graph" -SessionId $SessionId
            Write-GraphLog -Level "SUCCESS" -Message "Connected to Microsoft Graph via session authentication" -Context $Context
        } catch {
            $result.AddError("Failed to authenticate with Graph service: $($_.Exception.Message)", $_.Exception, $null)
            return $result
        }

        # 5. PERFORM DISCOVERY
        Write-GraphLog -Level "HEADER" -Message "Starting data discovery" -Context $Context
        $allDiscoveredData = [System.Collections.ArrayList]::new()
        
        # Discover Organization Details
        try {
            Write-GraphLog -Level "INFO" -Message "Discovering organization details..." -Context $Context
            $org = Get-MgOrganization -ErrorAction Stop
            if ($org) {
                $orgData = [PSCustomObject]@{
                    TenantId = $org.Id
                    DisplayName = $org.DisplayName
                    VerifiedDomains = ($org.VerifiedDomains | Where-Object { $_.IsVerified } | ForEach-Object { $_.Name }) -join ';'
                    DefaultDomain = ($org.VerifiedDomains | Where-Object { $_.IsDefault } | Select-Object -First 1).Name
                    TechnicalNotificationMails = ($org.TechnicalNotificationMails -join ';')
                    PreferredLanguage = $org.PreferredLanguage
                    _DataType = 'Organization'
                }
                $null = $allDiscoveredData.Add($orgData)
                Write-GraphLog -Level "SUCCESS" -Message "Discovered organization: $($org.DisplayName)" -Context $Context
            }
        } catch {
            $result.AddWarning("Failed to discover organization details: $($_.Exception.Message)", @{Section="Organization"})
        }

        # Discover Users
        try {
            Write-GraphLog -Level "INFO" -Message "Discovering users..." -Context $Context
            
            $userSelectFields = @(
                'id', 'userPrincipalName', 'displayName', 'mail', 'mailNickname',
                'givenName', 'surname', 'jobTitle', 'department', 'companyName',
                'officeLocation', 'businessPhones', 'mobilePhone', 'preferredLanguage',
                'employeeId', 'employeeType', 'createdDateTime', 'accountEnabled',
                'assignedLicenses', 'assignedPlans', 'onPremisesSyncEnabled',
                'onPremisesImmutableId', 'onPremisesSamAccountName', 'proxyAddresses',
                'userType', 'usageLocation', 'city', 'state', 'country', 'postalCode'
            )
            
            if ($includeSignInActivity) {
                $userSelectFields += 'signInActivity'
            }
            
            $expandFields = @()
            if ($includeManager) {
                $expandFields += 'manager'
            }
            
            $uri = "https://graph.microsoft.com/v1.0/users?`$select=$($userSelectFields -join ',')&`$top=$pageSize"
            if ($expandFields.Count -gt 0) {
                $uri += "&`$expand=$($expandFields -join ',')"
            }
            
            $headers = @{
                'ConsistencyLevel' = 'eventual'
                'Prefer' = 'outlook.body-content-type="text"'
            }
            
            $userCount = 0
            do {
                $response = Invoke-MgGraphRequest -Uri $uri -Method GET -Headers $headers -ErrorAction Stop
                
                foreach ($user in $response.value) {
                    $userCount++
                    
                    $licenses = @()
                    $plans = @()
                    if ($user.assignedLicenses) {
                        $licenses = $user.assignedLicenses | ForEach-Object { $_.skuId }
                    }
                    if ($user.assignedPlans) {
                        $plans = $user.assignedPlans | Where-Object { $_.capabilityStatus -eq 'Enabled' } | ForEach-Object { $_.servicePlanId }
                    }
                    
                    $userObj = [PSCustomObject]@{
                        id = $user.id
                        userPrincipalName = $user.userPrincipalName
                        displayName = $user.displayName
                        mail = $user.mail
                        mailNickname = $user.mailNickname
                        givenName = $user.givenName
                        surname = $user.surname
                        jobTitle = $user.jobTitle
                        department = $user.department
                        companyName = $user.companyName
                        officeLocation = $user.officeLocation
                        businessPhones = ($user.businessPhones -join ';')
                        mobilePhone = $user.mobilePhone
                        preferredLanguage = $user.preferredLanguage
                        employeeId = $user.employeeId
                        employeeType = $user.employeeType
                        createdDateTime = $user.createdDateTime
                        accountEnabled = $user.accountEnabled
                        assignedLicenses = ($licenses -join ';')
                        assignedPlans = ($plans -join ';')
                        licenseCount = $licenses.Count
                        onPremisesSyncEnabled = $user.onPremisesSyncEnabled
                        onPremisesImmutableId = $user.onPremisesImmutableId
                        onPremisesSamAccountName = $user.onPremisesSamAccountName
                        proxyAddresses = (($user.proxyAddresses | Where-Object { $_ -like 'SMTP:*' -or $_ -like 'smtp:*' }) -join ';')
                        userType = $user.userType
                        usageLocation = $user.usageLocation
                        city = $user.city
                        state = $user.state
                        country = $user.country
                        postalCode = $user.postalCode
                        managerUPN = if ($user.manager) { $user.manager.userPrincipalName } else { $null }
                        managerId = if ($user.manager) { $user.manager.id } else { $null }
                        lastSignInDateTime = if ($user.signInActivity) { $user.signInActivity.lastSignInDateTime } else { $null }
                        _DataType = 'User'
                    }
                    
                    $null = $allDiscoveredData.Add($userObj)
                    
                    if ($userCount % 100 -eq 0) {
                        Write-GraphLog -Level "DEBUG" -Message "Processed $userCount users..." -Context $Context
                    }
                }
                
                $uri = $response.'@odata.nextLink'
            } while ($uri)
            
            Write-GraphLog -Level "SUCCESS" -Message "Discovered $userCount users" -Context $Context
            
        } catch {
            $result.AddWarning("Failed to discover users: $($_.Exception.Message)", @{Section="Users"})
        }
        
        # Discover Groups
        try {
            Write-GraphLog -Level "INFO" -Message "Discovering groups..." -Context $Context
            
            $groupSelectFields = @(
                'id', 'displayName', 'mailEnabled', 'mailNickname', 'mail',
                'securityEnabled', 'groupTypes', 'description', 'visibility',
                'createdDateTime', 'renewedDateTime', 'membershipRule',
                'membershipRuleProcessingState', 'proxyAddresses',
                'onPremisesSyncEnabled', 'onPremisesSamAccountName', 'classification'
            )
            
            $uri = "https://graph.microsoft.com/v1.0/groups?`$select=$($groupSelectFields -join ',')&`$top=$pageSize"
            
            $groupCount = 0
            $groupMembers = [System.Collections.ArrayList]::new()
            
            do {
                $response = Invoke-MgGraphRequest -Uri $uri -Method GET -Headers $headers -ErrorAction Stop
                
                foreach ($group in $response.value) {
                    $groupCount++
                    
                    # Determine group type
                    $groupType = 'SecurityGroup'
                    if ($group.groupTypes -contains 'Unified') {
                        $groupType = 'Microsoft365Group'
                    } elseif ($group.mailEnabled -and -not $group.securityEnabled) {
                        $groupType = 'DistributionList'
                    } elseif ($group.mailEnabled -and $group.securityEnabled) {
                        $groupType = 'MailEnabledSecurityGroup'
                    } elseif ($group.groupTypes -contains 'DynamicMembership') {
                        $groupType = 'DynamicGroup'
                    }
                    
                    $groupObj = [PSCustomObject]@{
                        id = $group.id
                        displayName = $group.displayName
                        mail = $group.mail
                        mailNickname = $group.mailNickname
                        mailEnabled = $group.mailEnabled
                        securityEnabled = $group.securityEnabled
                        groupType = $groupType
                        groupTypes = ($group.groupTypes -join ';')
                        description = $group.description
                        visibility = $group.visibility
                        createdDateTime = $group.createdDateTime
                        renewedDateTime = $group.renewedDateTime
                        membershipRule = $group.membershipRule
                        membershipRuleProcessingState = $group.membershipRuleProcessingState
                        isDynamic = ($null -ne $group.membershipRule)
                        proxyAddresses = (($group.proxyAddresses | Where-Object { $_ -like 'SMTP:*' -or $_ -like 'smtp:*' }) -join ';')
                        onPremisesSyncEnabled = $group.onPremisesSyncEnabled
                        onPremisesSamAccountName = $group.onPremisesSamAccountName
                        classification = $group.classification
                        _DataType = 'Group'
                    }
                    
                    $null = $allDiscoveredData.Add($groupObj)
                }
                
                $uri = $response.'@odata.nextLink'
            } while ($uri)
            
            Write-GraphLog -Level "SUCCESS" -Message "Discovered $groupCount groups" -Context $Context
            
        } catch {
            $result.AddWarning("Failed to discover groups: $($_.Exception.Message)", @{Section="Groups"})
        }

        # 6. EXPORT DATA TO CSV
        if ($allDiscoveredData.Count -gt 0) {
            Write-GraphLog -Level "INFO" -Message "Exporting $($allDiscoveredData.Count) records..." -Context $Context
            
            $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
            
            # Group by data type and export
            $dataGroups = $allDiscoveredData | Group-Object -Property _DataType
            
            foreach ($group in $dataGroups) {
                $dataType = $group.Name
                $data = $group.Group
                
                # Add metadata
                $data | ForEach-Object {
                    $_ | Add-Member -MemberType NoteProperty -Name "_DiscoveryTimestamp" -Value $timestamp -Force
                    $_ | Add-Member -MemberType NoteProperty -Name "_DiscoveryModule" -Value "Graph" -Force
                    $_ | Add-Member -MemberType NoteProperty -Name "_SessionId" -Value $SessionId -Force
                }
                
                # Determine filename
                $fileName = switch ($dataType) {
                    'User' { 'GraphUsers.csv' }
                    'Group' { 'GraphGroups.csv' }
                    'Organization' { 'GraphOrganization.csv' }
                    default { "Graph_$dataType.csv" }
                }
                
                $filePath = Join-Path $outputPath $fileName
                $data | Export-Csv -Path $filePath -NoTypeInformation -Encoding UTF8
                
                Write-GraphLog -Level "SUCCESS" -Message "Exported $($data.Count) $dataType records to $fileName" -Context $Context
            }
        } else {
            Write-GraphLog -Level "WARN" -Message "No data discovered to export" -Context $Context
        }

        # 7. FINALIZE METADATA
        $result.RecordCount = $allDiscoveredData.Count
        $result.Metadata["TotalRecords"] = $result.RecordCount
        $result.Metadata["ElapsedTimeSeconds"] = $stopwatch.Elapsed.TotalSeconds
        $result.Metadata["SessionId"] = $SessionId
        
        # Add counts by type
        $dataGroups = $allDiscoveredData | Group-Object -Property _DataType
        foreach ($group in $dataGroups) {
            $result.Metadata["$($group.Name)Count"] = $group.Count
        }

    } catch {
        # Top-level error handler
        Write-GraphLog -Level "ERROR" -Message "Critical error: $($_.Exception.Message)" -Context $Context
        $result.AddError("A critical error occurred during discovery: $($_.Exception.Message)", $_.Exception, $null)
    } finally {
        # 8. CLEANUP & COMPLETE
        Write-GraphLog -Level "INFO" -Message "Cleaning up..." -Context $Context
        
        # Disconnect from services
        Disconnect-MgGraph -ErrorAction SilentlyContinue
        
        $stopwatch.Stop()
        $result.Complete()
        Write-GraphLog -Level "HEADER" -Message "Discovery finished in $($stopwatch.Elapsed.ToString('hh\:mm\:ss')). Records: $($result.RecordCount)." -Context $Context
    }

    return $result
}

# --- Helper Functions ---
function Ensure-Path {
    param($Path)
    if (-not (Test-Path -Path $Path -PathType Container)) {
        try {
            New-Item -Path $Path -ItemType Directory -Force -ErrorAction Stop | Out-Null
        } catch {
            throw "Failed to create output directory: $Path. Error: $($_.Exception.Message)"
        }
    }
}

# --- Module Export ---
Export-ModuleMember -Function Invoke-GraphDiscovery
