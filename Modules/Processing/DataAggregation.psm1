#Requires -Version 5.1

<#
.SYNOPSIS
    Aggregates and processes the raw data collected during the M&A Discovery phase.
.DESCRIPTION
    This module is the core of the processing phase. It reads all the raw CSV files
    generated by the discovery modules, merges them into unified and deduplicated datasets,
    enriches the data by creating relationships, and prepares a clean, consolidated
    output for the export phase. It is a prerequisite for generating any reports or
    PowerApps data.
.NOTES
    Version: 1.1.0
    Author: Gemini
    Creation Date: 2025-06-02
    Modification:
    - Renamed functions to use approved PowerShell verbs (Import, New).
#>

#region INTERNAL HELPER FUNCTIONS

#===============================================================================
# Import-RawDataSources
# Imports all relevant CSV files from the 'Raw' output directory.
#===============================================================================
function Import-RawDataSources {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$RawDataPath
    )

    Write-MandALog "Loading raw data sources from: $RawDataPath" -Level INFO
    $dataSources = @{}

    if (-not (Test-Path $RawDataPath -PathType Container)) {
        Write-MandALog "Raw data path not found: $RawDataPath. Cannot proceed with aggregation." -Level ERROR
        return $null
    }

    $csvFiles = Get-ChildItem -Path $RawDataPath -Filter "*.csv" -File
    if ($csvFiles.Count -eq 0) {
        Write-MandALog "No raw CSV files found in $RawDataPath." -Level WARN
        return $dataSources
    }

    Write-MandALog "Found $($csvFiles.Count) raw CSV files to process." -Level INFO

    foreach ($file in $csvFiles) {
        $sourceName = $file.BaseName
        Write-MandALog "Importing file: $($file.Name)" -Level DEBUG
        try {
            $content = Import-Csv -Path $file.FullName -ErrorAction Stop
            if ($null -ne $content) {
                $dataSources[$sourceName] = $content
                Write-MandALog "Successfully imported '$sourceName' with $($content.Count) records." -Level SUCCESS
            } else {
                Write-MandALog "File '$($file.Name)' is empty or could not be parsed. Skipping." -Level WARN
            }
        }
        catch {
            Write-MandALog "Failed to import '$($file.Name)': $($_.Exception.Message)" -Level ERROR
        }
    }

    return $dataSources
}

#===============================================================================
# Merge-UserProfiles
# Merges user data from AD, Graph, and Exchange into a single canonical list.
#===============================================================================
function Merge-UserProfiles {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [hashtable]$DataSources
    )

    Write-MandALog "Starting user profile aggregation and deduplication." -Level INFO
    $canonicalUsers = @{}

    # Define the order of precedence for adding users.
    # Users found in ActiveDirectory are added first.
    $userSourcePrecedence = @(
        'ActiveDirectory_Users',
        'Graph_Users',
        'Exchange_MailboxUsers'
    )

    foreach ($sourceName in $userSourcePrecedence) {
        if (-not $DataSources.ContainsKey($sourceName)) {
            Write-MandALog "User data source '$sourceName' not found, skipping." -Level DEBUG
            continue
        }

        $users = $DataSources[$sourceName]
        Write-MandALog "Processing $($users.Count) users from '$sourceName'." -Level INFO

        foreach ($user in $users) {
            # Normalize the UserPrincipalName to be the primary key (case-insensitive)
            $upn = $null
            if ($user.PSObject.Properties['UserPrincipalName']) {
                $upn = $user.UserPrincipalName.ToLower().Trim()
            }

            if ([string]::IsNullOrWhiteSpace($upn)) {
                Write-MandALog "Skipping user with blank UPN from source '$sourceName'. DisplayName: $($user.DisplayName)" -Level WARN
                continue
            }

            # If user doesn't exist, create the entry.
            if (-not $canonicalUsers.ContainsKey($upn)) {
                $canonicalUsers[$upn] = [PSCustomObject]@{
                    UserPrincipalName = $upn
                }
            }

            # Merge properties. Later sources overwrite earlier ones, except for specific protected fields.
            foreach ($prop in $user.PSObject.Properties) {
                # Define properties that should NOT be overwritten if they already exist
                # e.g., SamAccountName should only come from Active Directory
                $protectedProperties = @('SamAccountName', 'SID')
                if ($canonicalUsers[$upn].PSObject.Properties[$prop.Name] -and ($prop.Name -in $protectedProperties)) {
                    continue # Skip if property exists and is protected
                }

                $canonicalUsers[$upn] | Add-Member -MemberType NoteProperty -Name $prop.Name -Value $prop.Value -Force
            }
        }
    }

    Write-MandALog "Completed user profile merging. Canonical user count: $($canonicalUsers.Count)." -Level SUCCESS
    return $canonicalUsers.Values
}

#===============================================================================
# Merge-DeviceProfiles
# Merges device data from Graph and Intune.
#===============================================================================
function Merge-DeviceProfiles {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [hashtable]$DataSources
    )

    Write-MandALog "Starting device profile aggregation." -Level INFO
    $canonicalDevices = @{}

    # Define device sources
    $deviceSources = @(
        'Graph_Devices',
        'Intune_Devices'
    )

    foreach ($sourceName in $deviceSources) {
        if (-not $DataSources.ContainsKey($sourceName)) {
            Write-MandALog "Device data source '$sourceName' not found, skipping." -Level DEBUG
            continue
        }

        $devices = $DataSources[$sourceName]
        Write-MandALog "Processing $($devices.Count) devices from '$sourceName'." -Level INFO

        foreach ($device in $devices) {
            # DeviceId is the unique key
            $deviceId = $device.PSObject.Properties['id'] | Select-Object -First 1

            if ([string]::IsNullOrWhiteSpace($deviceId)) {
                continue
            }

            if (-not $canonicalDevices.ContainsKey($deviceId)) {
                $canonicalDevices[$deviceId] = [PSCustomObject]@{
                    DeviceId = $deviceId
                }
            }

            # Merge properties
            foreach ($prop in $device.PSObject.Properties) {
                $canonicalDevices[$deviceId] | Add-Member -MemberType NoteProperty -Name $prop.Name -Value $prop.Value -Force
            }
        }
    }

    Write-MandALog "Completed device profile merging. Canonical device count: $($canonicalDevices.Count)." -Level SUCCESS
    return $canonicalDevices.Values
}

#===============================================================================
# New-RelationshipGraph
# Enriches user and device profiles with relationship data.
#===============================================================================
function New-RelationshipGraph {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [System.Collections.Generic.IEnumerable[PSObject]]$Users,
        [Parameter(Mandatory=$true)]
        [System.Collections.Generic.IEnumerable[PSObject]]$Devices,
        [Parameter(Mandatory=$true)]
        [hashtable]$DataSources
    )

    Write-MandALog "Building relationship graph between users and other entities." -Level INFO

    # Create a lookup table for devices for faster access
    $deviceLookup = @{}
    foreach($device in $Devices) {
        $deviceLookup[$device.DeviceId] = $device
    }

    # 1. Map Devices to Users
    Write-MandALog "Mapping devices to users..." -Level DEBUG
    foreach ($user in $Users) {
        $userUPN = $user.UserPrincipalName
        $userDevices = [System.Collections.Generic.List[PSObject]]::new()

        # Find devices registered to this user
        $registeredDevices = $Devices | Where-Object { $_.registeredUsers -match $userUPN }
        if($registeredDevices) {
            foreach($dev in $registeredDevices) {
                $userDevices.Add($dev)
            }
        }

        # Add a new property to the user object
        $user | Add-Member -MemberType NoteProperty -Name 'AssociatedDevices' -Value $userDevices -Force
    }

    # Future enhancements:
    # 2. Map Group Memberships to Users
    # 3. Map Application Ownership/Assignments to Users

    Write-MandALog "Relationship graph building complete." -Level SUCCESS
    return $Users # Return the enriched user objects
}


#endregion

#===============================================================================
#                           START-DATAAGGREGATION
# Main exported function for the module.
#===============================================================================
function Start-DataAggregation {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [hashtable]$Configuration
    )

    $processedDataPath = $global:MandA.Paths.ProcessedDataOutput
    $rawDataPath = $global:MandA.Paths.RawDataOutput

    Write-MandALog "Starting Data Aggregation phase." -Level HEADER
    Write-MandALog "Processed data will be saved to: $processedDataPath" -Level INFO

    try {
        # Step 1: Load all raw data
        $dataSources = Import-RawDataSources -RawDataPath $rawDataPath
        if ($null -eq $dataSources -or $dataSources.Count -eq 0) {
            throw "No data sources were loaded. Halting processing."
        }

        # Step 2: Merge User Profiles
        $mergedUsers = Merge-UserProfiles -DataSources $dataSources

        # Step 3: Merge Device Profiles
        $mergedDevices = Merge-DeviceProfiles -DataSources $dataSources

        # Step 4: Build Relationships (enrich user objects)
        $finalUsers = New-RelationshipGraph -Users $mergedUsers -Devices $mergedDevices -DataSources $dataSources

        # Step 5: Export processed data to new CSV files
        Write-MandALog "Exporting processed data..." -Level INFO
        if (-not (Test-Path $processedDataPath -PathType Container)) {
            New-Item -Path $processedDataPath -ItemType Directory -Force | Out-Null
        }

        $finalUsers | Export-Csv -Path (Join-Path $processedDataPath "Users.csv") -NoTypeInformation -Encoding UTF8
        Write-MandALog "Exported $($finalUsers.Count) processed users to Users.csv" -Level SUCCESS

        $mergedDevices | Export-Csv -Path (Join-Path $processedDataPath "Devices.csv") -NoTypeInformation -Encoding UTF8
        Write-MandALog "Exported $($mergedDevices.Count) processed devices to Devices.csv" -Level SUCCESS

        # Copy over other non-merged files for use in the export phase
        foreach($source in $dataSources.Keys) {
            if ($source -notin @('ActiveDirectory_Users', 'Graph_Users', 'Exchange_MailboxUsers', 'Graph_Devices', 'Intune_Devices')) {
                $dataSources[$source] | Export-Csv -Path (Join-Path $processedDataPath "$source.csv") -NoTypeInformation -Encoding UTF8
                Write-MandALog "Copied over '$source.csv' to processed data folder." -Level DEBUG
            }
        }

        Write-MandALog "Data Aggregation phase completed successfully." -Level SUCCESS
        return $true
    }
    catch {
        Write-MandALog "ERROR: A critical error occurred during data aggregation: $($_.Exception.Message)" -Level "ERROR"
        Write-MandALog "Stack Trace: $($_.ScriptStackTrace)" -Level DEBUG
        return $false
    }
}

Export-ModuleMember -Function Start-DataAggregation
