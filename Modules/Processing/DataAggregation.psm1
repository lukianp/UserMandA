#Requires -Version 5.1

<#
.SYNOPSIS
    Aggregates and processes the raw data collected during the M&A Discovery phase.
.DESCRIPTION
    This module is the core of the processing phase. It reads all the raw CSV files
    generated by the discovery modules, merges them into unified and deduplicated datasets,
    enriches the data by creating relationships, and prepares a clean, consolidated
    output for the export phase. It is a prerequisite for generating any reports or
    PowerApps data.
.NOTES
    Version: 1.1.0
    Author: Gemini
    Creation Date: 2025-06-02
    Modification:
    - Renamed functions to use approved PowerShell verbs (Import, New).
#>

#region INTERNAL HELPER FUNCTIONS

#===============================================================================
# Import-RawDataSources
# Imports all relevant CSV files from the 'Raw' output directory.
#===============================================================================

#===============================================================================
# Import-RawDataSources
# Imports all relevant CSV files from the 'Raw' output directory.
#===============================================================================
function Import-RawDataSources {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$RawDataPath
    )

    Write-MandALog "Loading raw data sources from: $RawDataPath" -Level INFO
    $dataSources = @{}

    if (-not (Test-Path $RawDataPath -PathType Container)) {
        Write-MandALog "Raw data path not found: $RawDataPath. Cannot proceed with aggregation." -Level ERROR
        return $null
    }

    $csvFiles = Get-ChildItem -Path $RawDataPath -Filter "*.csv" -File
    if ($csvFiles.Count -eq 0) {
        Write-MandALog "No raw CSV files found in $RawDataPath." -Level WARN
        return $dataSources
    }

    Write-MandALog "Found $($csvFiles.Count) raw CSV files to process." -Level INFO

    # Define mappings from actual file names to expected source names
    $sourceNameMappings = @{
        # User-related mappings
        'ADUsers' = 'ActiveDirectory_Users'
        'AD_Users' = 'ActiveDirectory_Users'
        'ActiveDirectoryUsers' = 'ActiveDirectory_Users'
        'GraphUsers' = 'Graph_Users'
        'AADUsers' = 'Graph_Users'
        'AzureADUsers' = 'Graph_Users'
        'ExchangeMailboxUsers' = 'Exchange_MailboxUsers'
        'ExchangeUsers' = 'Exchange_MailboxUsers'
        'MailboxUsers' = 'Exchange_MailboxUsers'
        
        # Computer/Device mappings
        'ADComputers' = 'ActiveDirectory_Computers'
        'AD_Computers' = 'ActiveDirectory_Computers'
        'ActiveDirectoryComputers' = 'ActiveDirectory_Computers'
        'GraphDevices' = 'Graph_Devices'
        'AADDevices' = 'Graph_Devices'
        'AzureADDevices' = 'Graph_Devices'
        'IntuneDevices' = 'Intune_Devices'
        
        # Group mappings
        'ADGroups' = 'ActiveDirectory_Groups'
        'AD_Groups' = 'ActiveDirectory_Groups'
        'ActiveDirectoryGroups' = 'ActiveDirectory_Groups'
        'GraphGroups' = 'Graph_Groups'
        'AADGroups' = 'Graph_Groups'
        'AzureADGroups' = 'Graph_Groups'
        
        # Keep original names for everything else
    }

    foreach ($file in $csvFiles) {
        $sourceName = $file.BaseName
        Write-MandALog "Importing file: $($file.Name)" -Level DEBUG
        
        try {
            $content = Import-Csv -Path $file.FullName -ErrorAction Stop
            
            if ($null -ne $content) {
                # Store with original name
                $dataSources[$sourceName] = $content
                Write-MandALog "Successfully imported '$sourceName' with $($content.Count) records." -Level SUCCESS
                
                # Also store with mapped name if mapping exists
                if ($sourceNameMappings.ContainsKey($sourceName)) {
                    $mappedName = $sourceNameMappings[$sourceName]
                    $dataSources[$mappedName] = $content
                    Write-MandALog "  Also mapped to '$mappedName' for compatibility." -Level DEBUG
                }
                
                # Special handling for some data types
                switch ($sourceName) {
                    'ADUsers' {
                        # Ensure UserPrincipalName exists for AD users
                        if ($content.Count -gt 0 -and -not $content[0].PSObject.Properties['UserPrincipalName']) {
                            Write-MandALog "  ADUsers missing UserPrincipalName field. Will attempt to construct from other fields." -Level WARN
                            
                            # Add UserPrincipalName based on mail or samAccountName
                            foreach ($user in $content) {
                                if ($user.PSObject.Properties['mail'] -and $user.mail) {
                                    $user | Add-Member -NotePropertyName 'UserPrincipalName' -NotePropertyValue $user.mail -Force
                                } elseif ($user.PSObject.Properties['SamAccountName'] -and $user.SamAccountName) {
                                    # Try to get domain from DistinguishedName
                                    $domain = "yourdomain.com" # Default
                                    if ($user.PSObject.Properties['DistinguishedName'] -and $user.DistinguishedName) {
                                        if ($user.DistinguishedName -match 'DC=([^,]+),DC=([^,]+)') {
                                            $domain = "$($matches[1]).$($matches[2])"
                                        }
                                    }
                                    $user | Add-Member -NotePropertyName 'UserPrincipalName' -NotePropertyValue "$($user.SamAccountName)@$domain" -Force
                                }
                            }
                        }
                    }
                    
                    'ADComputers' {
                        # Ensure devices have a consistent identifier
                        if ($content.Count -gt 0) {
                            foreach ($computer in $content) {
                                # Add a DeviceId property if not present
                                if (-not $computer.PSObject.Properties['id'] -and $computer.PSObject.Properties['objectGUID']) {
                                    $computer | Add-Member -NotePropertyName 'id' -NotePropertyValue $computer.objectGUID -Force
                                }
                                # Ensure DisplayName exists
                                if (-not $computer.PSObject.Properties['DisplayName'] -and $computer.PSObject.Properties['Name']) {
                                    $computer | Add-Member -NotePropertyName 'DisplayName' -NotePropertyValue $computer.Name -Force
                                }
                            }
                        }
                    }
                }
                
            } else {
                Write-MandALog "File '$($file.Name)' is empty or could not be parsed. Skipping." -Level WARN
            }
        }
        catch {
            Write-MandALog "Failed to import '$($file.Name)': $($_.Exception.Message)" -Level ERROR
        }
    }

    # Log summary of what was loaded
    Write-MandALog "`nData source loading summary:" -Level INFO
    Write-MandALog "  Original sources loaded: $($csvFiles.Count)" -Level INFO
    Write-MandALog "  Total mappings created: $($dataSources.Count)" -Level INFO
    
    # Check for critical user sources
    $hasUserData = $false
    $userSources = @('ActiveDirectory_Users', 'Graph_Users', 'Exchange_MailboxUsers', 'ADUsers')
    foreach ($source in $userSources) {
        if ($dataSources.ContainsKey($source) -and $dataSources[$source].Count -gt 0) {
            $hasUserData = $true
            Write-MandALog "  Found user data in: $source (Count: $($dataSources[$source].Count))" -Level INFO
        }
    }
    
    if (-not $hasUserData) {
        Write-MandALog "WARNING: No user data sources found! Processing may fail." -Level WARN
    }
    
    # Check for device sources
    $hasDeviceData = $false
    $deviceSources = @('ActiveDirectory_Computers', 'Graph_Devices', 'Intune_Devices', 'ADComputers')
    foreach ($source in $deviceSources) {
        if ($dataSources.ContainsKey($source) -and $dataSources[$source].Count -gt 0) {
            $hasDeviceData = $true
            Write-MandALog "  Found device data in: $source (Count: $($dataSources[$source].Count))" -Level INFO
        }
    }
    
    if (-not $hasDeviceData) {
        Write-MandALog "  No device data sources found (this may be expected)." -Level INFO
    }

    return $dataSources
}


#===============================================================================
# Merge-UserProfiles
# Merges user data from AD, Graph, and Exchange into a single canonical list.
#===============================================================================


function Merge-UserProfiles {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [hashtable]$DataSources
    )

    Write-MandALog "Starting user profile aggregation and deduplication." -Level INFO
    $canonicalUsers = @{}

    # Define the order of precedence for adding users.
    # Updated to match actual file names
    $userSourcePrecedence = @(
        'ADUsers',                    # Changed from 'ActiveDirectory_Users'
        'Graph_Users',                # Keep as is if you have Graph discovery
        'Exchange_MailboxUsers'       # Keep as is if you have Exchange discovery
    )

    # Also check for legacy naming patterns
    $alternativeNames = @{
        'ADUsers' = @('ActiveDirectory_Users', 'AD_Users')
        'Graph_Users' = @('GraphUsers', 'AAD_Users', 'AzureAD_Users')
        'Exchange_MailboxUsers' = @('ExchangeUsers', 'Exchange_Users', 'MailboxUsers')
    }

    foreach ($sourceName in $userSourcePrecedence) {
        $users = $null
        
        # Try primary name first
        if ($DataSources.ContainsKey($sourceName)) {
            $users = $DataSources[$sourceName]
            Write-MandALog "Found users in '$sourceName'" -Level DEBUG
        } else {
            # Try alternative names
            if ($alternativeNames.ContainsKey($sourceName)) {
                foreach ($altName in $alternativeNames[$sourceName]) {
                    if ($DataSources.ContainsKey($altName)) {
                        $users = $DataSources[$altName]
                        Write-MandALog "Found users in '$altName' (alternative for $sourceName)" -Level DEBUG
                        break
                    }
                }
            }
        }

        if ($null -eq $users) {
            Write-MandALog "User data source '$sourceName' not found, skipping." -Level DEBUG
            continue
        }

        Write-MandALog "Processing $($users.Count) users from '$sourceName'." -Level INFO

        foreach ($user in $users) {
            # Normalize the UserPrincipalName to be the primary key (case-insensitive)
            $upn = $null
            
            # Check various possible UPN field names
            $upnFields = @('UserPrincipalName', 'userPrincipalName', 'UPN', 'upn', 'PrimarySmtpAddress')
            foreach ($field in $upnFields) {
                if ($user.PSObject.Properties[$field] -and $user.$field) {
                    $upn = $user.$field.ToLower().Trim()
                    break
                }
            }

            # If no UPN, try to construct from SamAccountName and domain
            if ([string]::IsNullOrWhiteSpace($upn) -and $user.PSObject.Properties['SamAccountName'] -and $user.SamAccountName) {
                # You might need to adjust the domain based on your environment
                $domain = if ($user.PSObject.Properties['Domain']) { $user.Domain } else { "yourdomain.com" }
                $upn = "$($user.SamAccountName)@$domain".ToLower().Trim()
                Write-MandALog "Constructed UPN from SamAccountName for user: $upn" -Level DEBUG
            }

            if ([string]::IsNullOrWhiteSpace($upn)) {
                Write-MandALog "Skipping user with blank UPN from source '$sourceName'. DisplayName: $($user.DisplayName)" -Level WARN
                continue
            }

            # If user doesn't exist, create the entry.
            if (-not $canonicalUsers.ContainsKey($upn)) {
                $canonicalUsers[$upn] = [PSCustomObject]@{
                    UserPrincipalName = $upn
                }
            }

            # Merge properties. Later sources overwrite earlier ones, except for specific protected fields.
            foreach ($prop in $user.PSObject.Properties) {
                # Define properties that should NOT be overwritten if they already exist
                # e.g., SamAccountName should only come from Active Directory
                $protectedProperties = @('SamAccountName', 'SID', 'ObjectGUID')
                if ($canonicalUsers[$upn].PSObject.Properties[$prop.Name] -and ($prop.Name -in $protectedProperties)) {
                    continue # Skip if property exists and is protected
                }

                $canonicalUsers[$upn] | Add-Member -MemberType NoteProperty -Name $prop.Name -Value $prop.Value -Force
            }
        }
    }

   Write-MandALog "Completed user profile merging. Canonical user count: $($canonicalUsers.Count)." -Level SUCCESS
return @($canonicalUsers.Values)  # Ensure it returns an array
}

#===============================================================================
# Merge-DeviceProfiles
# Merges device data from Graph and Intune.
#===============================================================================
function Merge-DeviceProfiles {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [hashtable]$DataSources
    )

    Write-MandALog "Starting device profile aggregation." -Level INFO
    $canonicalDevices = @{}

    # Define device sources
    $deviceSources = @(
        'Graph_Devices',
        'Intune_Devices'
    )

    foreach ($sourceName in $deviceSources) {
        if (-not $DataSources.ContainsKey($sourceName)) {
            Write-MandALog "Device data source '$sourceName' not found, skipping." -Level DEBUG
            continue
        }

        $devices = $DataSources[$sourceName]
        Write-MandALog "Processing $($devices.Count) devices from '$sourceName'." -Level INFO

        foreach ($device in $devices) {
            # DeviceId is the unique key
            $deviceId = $device.PSObject.Properties['id'] | Select-Object -First 1

            if ([string]::IsNullOrWhiteSpace($deviceId)) {
                continue
            }

            if (-not $canonicalDevices.ContainsKey($deviceId)) {
                $canonicalDevices[$deviceId] = [PSCustomObject]@{
                    DeviceId = $deviceId
                }
            }

            # Merge properties
            foreach ($prop in $device.PSObject.Properties) {
                $canonicalDevices[$deviceId] | Add-Member -MemberType NoteProperty -Name $prop.Name -Value $prop.Value -Force
            }
        }
    }

    Write-MandALog "Completed device profile merging. Canonical device count: $($canonicalDevices.Count)." -Level SUCCESS
    return $canonicalDevices.Values
}

#===============================================================================
# New-RelationshipGraph
# Enriches user and device profiles with relationship data.
#===============================================================================


function New-RelationshipGraph {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [array]$Users,  # Changed from [System.Collections.Generic.IEnumerable[PSObject]]
        
        [Parameter(Mandatory=$true)]
        [array]$Devices,  # Changed from [System.Collections.Generic.IEnumerable[PSObject]]
        
        [Parameter(Mandatory=$true)]
        [hashtable]$DataSources
    )

    Write-MandALog "Building relationship graph between users and other entities." -Level INFO

    # Create a lookup table for devices for faster access
    $deviceLookup = @{}
    foreach($device in $Devices) {
        if ($device.PSObject.Properties['DeviceId'] -and $device.DeviceId) {
            $deviceLookup[$device.DeviceId] = $device
        }
    }

    # 1. Map Devices to Users
    Write-MandALog "Mapping devices to users..." -Level DEBUG
    foreach ($user in $Users) {
        $userUPN = $user.UserPrincipalName
        $userDevices = @()  # Changed from [System.Collections.Generic.List[PSObject]]::new()

        # Find devices registered to this user
        $registeredDevices = $Devices | Where-Object { 
            $_.PSObject.Properties['registeredUsers'] -and 
            $_.registeredUsers -match $userUPN 
        }
        
        if($registeredDevices) {
            $userDevices = @($registeredDevices)
        }

        # Add a new property to the user object
        $user | Add-Member -MemberType NoteProperty -Name 'AssociatedDevices' -Value $userDevices -Force
    }

    # Future enhancements:
    # 2. Map Group Memberships to Users
    # 3. Map Application Ownership/Assignments to Users

    Write-MandALog "Relationship graph building complete." -Level SUCCESS
    return $Users # Return the enriched user objects
}


#endregion

#===============================================================================
#                           START-DATAAGGREGATION
# Main exported function for the module.
#===============================================================================
function Start-DataAggregation {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [hashtable]$Configuration
    )

    $processedDataPath = $global:MandA.Paths.ProcessedDataOutput
    $rawDataPath = $global:MandA.Paths.RawDataOutput

    Write-MandALog "Starting Data Aggregation phase." -Level HEADER
    Write-MandALog "Processed data will be saved to: $processedDataPath" -Level INFO

    try {
        # Step 1: Load all raw data
        $dataSources = Import-RawDataSources -RawDataPath $rawDataPath
        if ($null -eq $dataSources -or $dataSources.Count -eq 0) {
            throw "No data sources were loaded. Halting processing."
        }

        # Step 2: Merge User Profiles
        $mergedUsers = Merge-UserProfiles -DataSources $dataSources

        # Step 3: Merge Device Profiles
        $mergedDevices = Merge-DeviceProfiles -DataSources $dataSources

        # Step 4: Build Relationships (enrich user objects)
        $finalUsers = New-RelationshipGraph -Users $mergedUsers -Devices $mergedDevices -DataSources $dataSources

        # Step 5: Export processed data to new CSV files
        Write-MandALog "Exporting processed data..." -Level INFO
        if (-not (Test-Path $processedDataPath -PathType Container)) {
            New-Item -Path $processedDataPath -ItemType Directory -Force | Out-Null
        }

        $finalUsers | Export-Csv -Path (Join-Path $processedDataPath "Users.csv") -NoTypeInformation -Encoding UTF8
        Write-MandALog "Exported $($finalUsers.Count) processed users to Users.csv" -Level SUCCESS

        $mergedDevices | Export-Csv -Path (Join-Path $processedDataPath "Devices.csv") -NoTypeInformation -Encoding UTF8
        Write-MandALog "Exported $($mergedDevices.Count) processed devices to Devices.csv" -Level SUCCESS

        # Copy over other non-merged files for use in the export phase
        foreach($source in $dataSources.Keys) {
            if ($source -notin @('ActiveDirectory_Users', 'Graph_Users', 'Exchange_MailboxUsers', 'Graph_Devices', 'Intune_Devices')) {
                $dataSources[$source] | Export-Csv -Path (Join-Path $processedDataPath "$source.csv") -NoTypeInformation -Encoding UTF8
                Write-MandALog "Copied over '$source.csv' to processed data folder." -Level DEBUG
            }
        }

        Write-MandALog "Data Aggregation phase completed successfully." -Level SUCCESS
        return $true
    }
    catch {
        Write-MandALog "ERROR: A critical error occurred during data aggregation: $($_.Exception.Message)" -Level "ERROR"
        Write-MandALog "Stack Trace: $($_.ScriptStackTrace)" -Level DEBUG
        return $false
    }
}

Export-ModuleMember -Function Start-DataAggregation
