using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Input;
using CommunityToolkit.Mvvm.Input;
using MandADiscoverySuite.Models;
using Microsoft.Extensions.Logging;

namespace MandADiscoverySuite.Services
{
    /// <summary>
    /// Enhanced command infrastructure for PowerShell integration
    /// Extends existing AsyncRelayCommand patterns with robust error handling and cancellation
    /// </summary>
    public class EnhancedMigrationCommands : IDisposable
    {
        private readonly ILogger<EnhancedMigrationCommands> _logger;
        private readonly StructuredLoggingService _structuredLogger;
        private readonly PowerShellExecutionService _executionService;
        private readonly MigrationStateManager _stateManager;
        private readonly Dictionary<string, CancellationTokenSource> _commandCancellations = new();
        private readonly object _commandLock = new object();
        private bool _disposed = false;

        // Command execution tracking
        private readonly Dictionary<string, CommandExecutionTracker> _activeCommands = new();

        // Events for command lifecycle
        public event EventHandler<CommandStartedEventArgs> CommandStarted;
        public event EventHandler<CommandCompletedEventArgs> CommandCompleted;
        public event EventHandler<CommandProgressEventArgs> CommandProgress;

        public EnhancedMigrationCommands(
            ILogger<EnhancedMigrationCommands> logger,
            PowerShellExecutionService executionService,
            MigrationStateManager stateManager)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _executionService = executionService ?? throw new ArgumentNullException(nameof(executionService));
            _stateManager = stateManager ?? throw new ArgumentNullException(nameof(stateManager));
            _structuredLogger = StructuredLoggingService.Instance;

            // Subscribe to execution events for command tracking
            _executionService.ProgressUpdated += OnExecutionProgressUpdated;
            _executionService.StatusChanged += OnExecutionStatusChanged;

            _structuredLogger?.LogInfo("EnhancedMigrationCommands",
                new { action = "commands_init" },
                "Enhanced migration commands initialized");
        }

        #region Discovery Commands

        /// <summary>
        /// Creates an enhanced discovery command with PowerShell integration
        /// </summary>
        public AsyncRelayCommand CreateDiscoveryCommand(string moduleName, string companyName, Dictionary<string, object> parameters = null)
        {
            return new AsyncRelayCommand(async () =>
            {
                var commandId = Guid.NewGuid().ToString();
                var tracker = new CommandExecutionTracker
                {
                    CommandId = commandId,
                    CommandType = "Discovery",
                    ModuleName = moduleName,
                    CompanyName = companyName,
                    StartTime = DateTime.Now
                };

                try
                {
                    lock (_commandLock)
                    {
                        var cts = new CancellationTokenSource();
                        _commandCancellations[commandId] = cts;
                        _activeCommands[commandId] = tracker;
                    }

                    // Fire command started event
                    CommandStarted?.Invoke(this, new CommandStartedEventArgs
                    {
                        CommandId = commandId,
                        CommandType = "Discovery",
                        ModuleName = moduleName
                    });

                    _structuredLogger?.LogInfo("EnhancedMigrationCommands",
                        new { action = "discovery_command_start", command_id = commandId, module = moduleName },
                        $"Starting discovery command: {moduleName}");

                    // Execute discovery module with cancellation support
                    var result = await _executionService.ExecuteDiscoveryModuleAsync(
                        moduleName, 
                        companyName, 
                        parameters, 
                        _commandCancellations[commandId].Token);

                    // Update tracker
                    tracker.EndTime = DateTime.Now;
                    tracker.Success = result.Success;
                    tracker.ErrorMessage = result.ErrorMessage;
                    tracker.ExecutionId = result.ExecutionId;

                    // Fire command completed event
                    CommandCompleted?.Invoke(this, new CommandCompletedEventArgs
                    {
                        CommandId = commandId,
                        Success = result.Success,
                        ErrorMessage = result.ErrorMessage,
                        ExecutionId = result.ExecutionId
                    });

                    _structuredLogger?.LogInfo("EnhancedMigrationCommands",
                        new { action = "discovery_command_complete", command_id = commandId, success = result.Success },
                        $"Discovery command completed: {moduleName}");
                }
                catch (OperationCanceledException)
                {
                    tracker.EndTime = DateTime.Now;
                    tracker.Success = false;
                    tracker.ErrorMessage = "Command was cancelled";

                    _structuredLogger?.LogInfo("EnhancedMigrationCommands",
                        new { action = "discovery_command_cancelled", command_id = commandId },
                        $"Discovery command cancelled: {moduleName}");
                }
                catch (Exception ex)
                {
                    tracker.EndTime = DateTime.Now;
                    tracker.Success = false;
                    tracker.ErrorMessage = ex.Message;

                    _structuredLogger?.LogError("EnhancedMigrationCommands", ex,
                        new { action = "discovery_command_error", command_id = commandId, module = moduleName },
                        $"Discovery command failed: {moduleName}");

                    CommandCompleted?.Invoke(this, new CommandCompletedEventArgs
                    {
                        CommandId = commandId,
                        Success = false,
                        ErrorMessage = ex.Message
                    });

                    throw; // Re-throw to maintain existing error handling patterns
                }
                finally
                {
                    CleanupCommand(commandId);
                }
            });
        }

        /// <summary>
        /// Creates a batch discovery command for multiple modules
        /// </summary>
        public AsyncRelayCommand CreateBatchDiscoveryCommand(List<string> moduleNames, string companyName)
        {
            return new AsyncRelayCommand(async () =>
            {
                var commandId = Guid.NewGuid().ToString();
                var tracker = new CommandExecutionTracker
                {
                    CommandId = commandId,
                    CommandType = "BatchDiscovery",
                    ModuleName = string.Join(", ", moduleNames),
                    CompanyName = companyName,
                    StartTime = DateTime.Now,
                    TotalItems = moduleNames.Count
                };

                try
                {
                    lock (_commandLock)
                    {
                        var cts = new CancellationTokenSource();
                        _commandCancellations[commandId] = cts;
                        _activeCommands[commandId] = tracker;
                    }

                    CommandStarted?.Invoke(this, new CommandStartedEventArgs
                    {
                        CommandId = commandId,
                        CommandType = "BatchDiscovery",
                        ModuleName = tracker.ModuleName
                    });

                    _structuredLogger?.LogInfo("EnhancedMigrationCommands",
                        new { action = "batch_discovery_start", command_id = commandId, modules = moduleNames.Count },
                        $"Starting batch discovery: {moduleNames.Count} modules");

                    var results = new List<MigrationExecutionResult>();
                    var processedCount = 0;

                    foreach (var moduleName in moduleNames)
                    {
                        _commandCancellations[commandId].Token.ThrowIfCancellationRequested();

                        // Update progress
                        tracker.ProcessedItems = processedCount;
                        tracker.CurrentOperation = $"Executing {moduleName}";
                        tracker.ProgressPercentage = (double)processedCount / moduleNames.Count * 100;

                        CommandProgress?.Invoke(this, new CommandProgressEventArgs
                        {
                            CommandId = commandId,
                            ProgressPercentage = tracker.ProgressPercentage,
                            CurrentOperation = tracker.CurrentOperation
                        });

                        // Execute module
                        var result = await _executionService.ExecuteDiscoveryModuleAsync(
                            moduleName, 
                            companyName, 
                            null, 
                            _commandCancellations[commandId].Token);

                        results.Add(result);
                        processedCount++;
                    }

                    // Update final state
                    tracker.EndTime = DateTime.Now;
                    tracker.Success = results.All(r => r.Success);
                    tracker.ProcessedItems = processedCount;
                    tracker.ProgressPercentage = 100;

                    if (!tracker.Success)
                    {
                        tracker.ErrorMessage = string.Join("; ", results.Where(r => !r.Success).Select(r => r.ErrorMessage));
                    }

                    CommandCompleted?.Invoke(this, new CommandCompletedEventArgs
                    {
                        CommandId = commandId,
                        Success = tracker.Success,
                        ErrorMessage = tracker.ErrorMessage
                    });

                    _structuredLogger?.LogInfo("EnhancedMigrationCommands",
                        new { action = "batch_discovery_complete", command_id = commandId, success = tracker.Success },
                        $"Batch discovery completed: {processedCount}/{moduleNames.Count} successful");
                }
                catch (OperationCanceledException)
                {
                    tracker.EndTime = DateTime.Now;
                    tracker.Success = false;
                    tracker.ErrorMessage = "Batch discovery was cancelled";

                    _structuredLogger?.LogInfo("EnhancedMigrationCommands",
                        new { action = "batch_discovery_cancelled", command_id = commandId },
                        "Batch discovery command cancelled");
                }
                catch (Exception ex)
                {
                    tracker.EndTime = DateTime.Now;
                    tracker.Success = false;
                    tracker.ErrorMessage = ex.Message;

                    _structuredLogger?.LogError("EnhancedMigrationCommands", ex,
                        new { action = "batch_discovery_error", command_id = commandId },
                        "Batch discovery command failed");

                    throw;
                }
                finally
                {
                    CleanupCommand(commandId);
                }
            });
        }

        #endregion

        #region Migration Commands

        /// <summary>
        /// Creates an enhanced migration batch command
        /// </summary>
        public AsyncRelayCommand CreateMigrationBatchCommand(MigrationBatch batch, MigrationSettings settings)
        {
            return new AsyncRelayCommand(async () =>
            {
                var commandId = Guid.NewGuid().ToString();
                var tracker = new CommandExecutionTracker
                {
                    CommandId = commandId,
                    CommandType = "Migration",
                    ModuleName = $"{batch.Type}-{batch.Name}",
                    CompanyName = settings?.NotificationEmail ?? "Unknown",
                    StartTime = DateTime.Now,
                    TotalItems = batch.TotalItems
                };

                try
                {
                    lock (_commandLock)
                    {
                        var cts = new CancellationTokenSource();
                        _commandCancellations[commandId] = cts;
                        _activeCommands[commandId] = tracker;
                    }

                    CommandStarted?.Invoke(this, new CommandStartedEventArgs
                    {
                        CommandId = commandId,
                        CommandType = "Migration",
                        ModuleName = tracker.ModuleName
                    });

                    _structuredLogger?.LogInfo("EnhancedMigrationCommands",
                        new { action = "migration_command_start", command_id = commandId, batch_id = batch.Id },
                        $"Starting migration command: {batch.Name}");

                    // Create execution state
                    var executionState = new MigrationExecutionState
                    {
                        ExecutionId = commandId,
                        ModuleName = tracker.ModuleName,
                        CompanyName = tracker.CompanyName,
                        MigrationType = batch.Type,
                        Status = MigrationStatus.InProgress,
                        StartTime = DateTime.Now,
                        TotalItems = batch.TotalItems,
                        ProcessedItems = 0
                    };

                    _stateManager.CreateOrUpdateExecutionState(commandId, executionState);

                    // Execute migration batch
                    var result = await _executionService.ExecuteMigrationBatchAsync(
                        batch, 
                        settings, 
                        _commandCancellations[commandId].Token);

                    // Update tracker and state
                    tracker.EndTime = DateTime.Now;
                    tracker.Success = result.Success;
                    tracker.ErrorMessage = result.ErrorMessage;
                    tracker.ExecutionId = result.ExecutionId;
                    tracker.ProcessedItems = result.ProcessedItems;

                    _stateManager.CompleteExecution(commandId, 
                        result.Success ? MigrationStatus.Completed : MigrationStatus.Failed, 
                        result.ErrorMessage);

                    CommandCompleted?.Invoke(this, new CommandCompletedEventArgs
                    {
                        CommandId = commandId,
                        Success = result.Success,
                        ErrorMessage = result.ErrorMessage,
                        ExecutionId = result.ExecutionId
                    });

                    _structuredLogger?.LogInfo("EnhancedMigrationCommands",
                        new { action = "migration_command_complete", command_id = commandId, success = result.Success },
                        $"Migration command completed: {batch.Name}");
                }
                catch (OperationCanceledException)
                {
                    tracker.EndTime = DateTime.Now;
                    tracker.Success = false;
                    tracker.ErrorMessage = "Migration was cancelled";

                    _stateManager.CompleteExecution(commandId, MigrationStatus.Cancelled, "Migration was cancelled");

                    _structuredLogger?.LogInfo("EnhancedMigrationCommands",
                        new { action = "migration_command_cancelled", command_id = commandId },
                        $"Migration command cancelled: {batch.Name}");
                }
                catch (Exception ex)
                {
                    tracker.EndTime = DateTime.Now;
                    tracker.Success = false;
                    tracker.ErrorMessage = ex.Message;

                    _stateManager.CompleteExecution(commandId, MigrationStatus.Failed, ex.Message);

                    _structuredLogger?.LogError("EnhancedMigrationCommands", ex,
                        new { action = "migration_command_error", command_id = commandId, batch_id = batch.Id },
                        $"Migration command failed: {batch.Name}");

                    throw;
                }
                finally
                {
                    CleanupCommand(commandId);
                }
            });
        }

        /// <summary>
        /// Creates a wave execution command
        /// </summary>
        public AsyncRelayCommand CreateWaveExecutionCommand(MigrationWaveExtended wave, MigrationSettings settings)
        {
            return new AsyncRelayCommand(async () =>
            {
                var commandId = Guid.NewGuid().ToString();
                var tracker = new CommandExecutionTracker
                {
                    CommandId = commandId,
                    CommandType = "WaveExecution",
                    ModuleName = wave.Name,
                    CompanyName = settings?.NotificationEmail ?? "Unknown",
                    StartTime = DateTime.Now,
                    TotalItems = wave.TotalItems
                };

                try
                {
                    lock (_commandLock)
                    {
                        var cts = new CancellationTokenSource();
                        _commandCancellations[commandId] = cts;
                        _activeCommands[commandId] = tracker;
                    }

                    CommandStarted?.Invoke(this, new CommandStartedEventArgs
                    {
                        CommandId = commandId,
                        CommandType = "WaveExecution",
                        ModuleName = wave.Name
                    });

                    _structuredLogger?.LogInfo("EnhancedMigrationCommands",
                        new { action = "wave_command_start", command_id = commandId, wave_id = wave.Id },
                        $"Starting wave execution: {wave.Name}");

                    var batchResults = new List<MigrationExecutionResult>();
                    var processedBatches = 0;

                    foreach (var batch in wave.Batches)
                    {
                        _commandCancellations[commandId].Token.ThrowIfCancellationRequested();

                        // Update progress
                        tracker.ProcessedItems = processedBatches;
                        tracker.CurrentOperation = $"Executing batch: {batch.Name}";
                        tracker.ProgressPercentage = (double)processedBatches / wave.Batches.Count * 100;

                        CommandProgress?.Invoke(this, new CommandProgressEventArgs
                        {
                            CommandId = commandId,
                            ProgressPercentage = tracker.ProgressPercentage,
                            CurrentOperation = tracker.CurrentOperation
                        });

                        // Execute batch
                        var result = await _executionService.ExecuteMigrationBatchAsync(
                            batch, 
                            settings, 
                            _commandCancellations[commandId].Token);

                        batchResults.Add(result);
                        processedBatches++;
                    }

                    // Update final state
                    tracker.EndTime = DateTime.Now;
                    tracker.Success = batchResults.All(r => r.Success);
                    tracker.ProcessedItems = processedBatches;
                    tracker.ProgressPercentage = 100;

                    if (!tracker.Success)
                    {
                        tracker.ErrorMessage = string.Join("; ", batchResults.Where(r => !r.Success).Select(r => r.ErrorMessage));
                    }

                    CommandCompleted?.Invoke(this, new CommandCompletedEventArgs
                    {
                        CommandId = commandId,
                        Success = tracker.Success,
                        ErrorMessage = tracker.ErrorMessage
                    });

                    _structuredLogger?.LogInfo("EnhancedMigrationCommands",
                        new { action = "wave_command_complete", command_id = commandId, success = tracker.Success },
                        $"Wave execution completed: {processedBatches}/{wave.Batches.Count} batches successful");
                }
                catch (OperationCanceledException)
                {
                    tracker.EndTime = DateTime.Now;
                    tracker.Success = false;
                    tracker.ErrorMessage = "Wave execution was cancelled";

                    _structuredLogger?.LogInfo("EnhancedMigrationCommands",
                        new { action = "wave_command_cancelled", command_id = commandId },
                        $"Wave execution cancelled: {wave.Name}");
                }
                catch (Exception ex)
                {
                    tracker.EndTime = DateTime.Now;
                    tracker.Success = false;
                    tracker.ErrorMessage = ex.Message;

                    _structuredLogger?.LogError("EnhancedMigrationCommands", ex,
                        new { action = "wave_command_error", command_id = commandId, wave_id = wave.Id },
                        $"Wave execution failed: {wave.Name}");

                    throw;
                }
                finally
                {
                    CleanupCommand(commandId);
                }
            });
        }

        #endregion

        #region Command Management

        /// <summary>
        /// Cancels a running command
        /// </summary>
        public bool CancelCommand(string commandId)
        {
            lock (_commandLock)
            {
                if (_commandCancellations.TryGetValue(commandId, out var cts))
                {
                    cts.Cancel();
                    
                    if (_activeCommands.TryGetValue(commandId, out var tracker))
                    {
                        tracker.EndTime = DateTime.Now;
                        tracker.Success = false;
                        tracker.ErrorMessage = "Command was cancelled";
                    }

                    _structuredLogger?.LogInfo("EnhancedMigrationCommands",
                        new { action = "command_cancelled", command_id = commandId },
                        "Command cancelled by user request");

                    return true;
                }
                return false;
            }
        }

        /// <summary>
        /// Gets active command trackers
        /// </summary>
        public List<CommandExecutionTracker> GetActiveCommands()
        {
            lock (_commandLock)
            {
                return _activeCommands.Values.Where(t => !t.EndTime.HasValue).ToList();
            }
        }

        /// <summary>
        /// Gets command execution history
        /// </summary>
        public List<CommandExecutionTracker> GetCommandHistory(int maxCount = 50)
        {
            lock (_commandLock)
            {
                return _activeCommands.Values
                    .Where(t => t.EndTime.HasValue)
                    .OrderByDescending(t => t.StartTime)
                    .Take(maxCount)
                    .ToList();
            }
        }

        #endregion

        #region Event Handlers

        /// <summary>
        /// Handles execution progress updates
        /// </summary>
        private void OnExecutionProgressUpdated(object sender, MigrationProgressEventArgs e)
        {
            lock (_commandLock)
            {
                // Find the command associated with this execution
                var tracker = _activeCommands.Values.FirstOrDefault(t => t.ExecutionId == e.ExecutionId);
                if (tracker != null)
                {
                    tracker.ProgressPercentage = e.ProgressPercentage;
                    tracker.CurrentOperation = e.CurrentOperation;

                    CommandProgress?.Invoke(this, new CommandProgressEventArgs
                    {
                        CommandId = tracker.CommandId,
                        ProgressPercentage = e.ProgressPercentage,
                        CurrentOperation = e.CurrentOperation
                    });
                }
            }
        }

        /// <summary>
        /// Handles execution status changes
        /// </summary>
        private void OnExecutionStatusChanged(object sender, MigrationStatusEventArgs e)
        {
            lock (_commandLock)
            {
                var tracker = _activeCommands.Values.FirstOrDefault(t => t.ExecutionId == e.ExecutionId);
                if (tracker != null)
                {
                    if (e.Status == MigrationStatus.Completed || 
                        e.Status == MigrationStatus.Failed || 
                        e.Status == MigrationStatus.Cancelled)
                    {
                        tracker.EndTime = DateTime.Now;
                        tracker.Success = e.Status == MigrationStatus.Completed;
                        
                        if (e.Status == MigrationStatus.Failed)
                        {
                            tracker.ErrorMessage = "Execution failed";
                        }
                        else if (e.Status == MigrationStatus.Cancelled)
                        {
                            tracker.ErrorMessage = "Execution was cancelled";
                        }
                    }
                }
            }
        }

        #endregion

        #region Helper Methods

        /// <summary>
        /// Cleans up command resources
        /// </summary>
        private void CleanupCommand(string commandId)
        {
            lock (_commandLock)
            {
                if (_commandCancellations.TryGetValue(commandId, out var cts))
                {
                    cts.Dispose();
                    _commandCancellations.Remove(commandId);
                }

                // Keep tracker for history but mark as completed
                if (_activeCommands.TryGetValue(commandId, out var tracker) && !tracker.EndTime.HasValue)
                {
                    tracker.EndTime = DateTime.Now;
                }
            }
        }

        #endregion

        #region Disposal

        public void Dispose()
        {
            if (!_disposed)
            {
                // Cancel all active commands
                lock (_commandLock)
                {
                    foreach (var cts in _commandCancellations.Values)
                    {
                        try
                        {
                            cts.Cancel();
                            cts.Dispose();
                        }
                        catch { }
                    }
                    _commandCancellations.Clear();
                }

                // Unsubscribe from events
                if (_executionService != null)
                {
                    _executionService.ProgressUpdated -= OnExecutionProgressUpdated;
                    _executionService.StatusChanged -= OnExecutionStatusChanged;
                }

                _disposed = true;
            }
        }

        #endregion
    }

    #region Supporting Classes

    /// <summary>
    /// Command execution tracker
    /// </summary>
    public class CommandExecutionTracker
    {
        public string CommandId { get; set; }
        public string CommandType { get; set; }
        public string ModuleName { get; set; }
        public string CompanyName { get; set; }
        public DateTime StartTime { get; set; }
        public DateTime? EndTime { get; set; }
        public bool Success { get; set; }
        public string ErrorMessage { get; set; }
        public string ExecutionId { get; set; }
        public double ProgressPercentage { get; set; }
        public string CurrentOperation { get; set; }
        public int TotalItems { get; set; }
        public int ProcessedItems { get; set; }
    }

    // Event argument classes for command lifecycle
    public class CommandStartedEventArgs : EventArgs
    {
        public string CommandId { get; set; }
        public string CommandType { get; set; }
        public string ModuleName { get; set; }
    }

    public class CommandCompletedEventArgs : EventArgs
    {
        public string CommandId { get; set; }
        public bool Success { get; set; }
        public string ErrorMessage { get; set; }
        public string ExecutionId { get; set; }
    }

    public class CommandProgressEventArgs : EventArgs
    {
        public string CommandId { get; set; }
        public double ProgressPercentage { get; set; }
        public string CurrentOperation { get; set; }
    }

    #endregion
}