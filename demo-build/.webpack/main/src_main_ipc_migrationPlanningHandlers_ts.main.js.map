{"version":3,"file":"src_main_ipc_migrationPlanningHandlers_ts.main.js","mappings":"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","sources":["webpack://enterprise-discovery-suite/./src/main/ipc/migrationPlanningHandlers.ts","webpack://enterprise-discovery-suite/./src/main/services/migrationPlanningService.ts"],"sourcesContent":["/**\n * Migration Planning IPC Handlers\n *\n * IPC handlers for migration planning service\n */\nimport { ipcMain } from 'electron';\nimport { getMigrationPlanningService } from '../services/migrationPlanningService';\n/**\n * Register all migration planning IPC handlers\n */\nexport function registerMigrationPlanningHandlers() {\n    const service = getMigrationPlanningService();\n    // Get plans by profile\n    ipcMain.handle('migration-plan:get-by-profile', async (event, profileName) => {\n        try {\n            const plans = await service.getPlansByProfile(profileName);\n            return { success: true, plans };\n        }\n        catch (error) {\n            return { success: false, error: error.message };\n        }\n    });\n    // Create new plan\n    ipcMain.handle('migration-plan:create', async (event, planData) => {\n        try {\n            const plan = await service.createPlan(planData);\n            return { success: true, plan };\n        }\n        catch (error) {\n            return { success: false, error: error.message };\n        }\n    });\n    // Add wave to plan\n    ipcMain.handle('migration-plan:add-wave', async (event, data) => {\n        try {\n            const wave = await service.addWave(data.planId, data.waveData);\n            return { success: true, wave };\n        }\n        catch (error) {\n            return { success: false, error: error.message };\n        }\n    });\n    // Assign users to wave\n    ipcMain.handle('migration-plan:assign-users', async (event, data) => {\n        try {\n            await service.assignUsersToWave(data.planId, data.waveId, data.userIds);\n            return { success: true };\n        }\n        catch (error) {\n            return { success: false, error: error.message };\n        }\n    });\n    // Update wave status\n    ipcMain.handle('migration-plan:update-wave-status', async (event, data) => {\n        try {\n            await service.updateWaveStatus(data.planId, data.waveId, data.status);\n            return { success: true };\n        }\n        catch (error) {\n            return { success: false, error: error.message };\n        }\n    });\n    // Delete plan\n    ipcMain.handle('migration-plan:delete', async (event, planId) => {\n        try {\n            await service.deletePlan(planId);\n            return { success: true };\n        }\n        catch (error) {\n            return { success: false, error: error.message };\n        }\n    });\n    // Get plan by ID\n    ipcMain.handle('migration-plan:get-by-id', async (event, planId) => {\n        try {\n            const plan = await service.getPlanById(planId);\n            return { success: true, plan };\n        }\n        catch (error) {\n            return { success: false, error: error.message };\n        }\n    });\n}\n","/**\n * Migration Planning Service\n *\n * Handles migration wave planning, user assignment, and execution scheduling.\n * Pattern from GUI/Services/MigrationPlanningService.cs\n */\nimport * as fs from 'fs';\nimport * as path from 'path';\n/**\n * Migration Planning Service\n */\nexport class MigrationPlanningService {\n    plansDir;\n    plans = new Map();\n    constructor(dataRoot = 'C:\\\\DiscoveryData') {\n        this.plansDir = path.join(dataRoot, 'MigrationPlans');\n        this.ensureDirectoryExists();\n    }\n    /**\n     * Ensure migration plans directory exists\n     */\n    ensureDirectoryExists() {\n        if (!fs.existsSync(this.plansDir)) {\n            fs.mkdirSync(this.plansDir, { recursive: true });\n        }\n    }\n    /**\n     * Create a new migration plan\n     */\n    async createPlan(planData) {\n        const plan = {\n            id: crypto.randomUUID(),\n            ...planData,\n            waves: [],\n            created: new Date().toISOString(),\n            modified: new Date().toISOString()\n        };\n        this.plans.set(plan.id, plan);\n        await this.savePlan(plan);\n        return plan;\n    }\n    /**\n     * Add a wave to a migration plan\n     */\n    async addWave(planId, waveData) {\n        const plan = this.plans.get(planId);\n        if (!plan) {\n            throw new Error(`Migration plan not found: ${planId}`);\n        }\n        const wave = {\n            id: crypto.randomUUID(),\n            ...waveData,\n            status: 'planned',\n            users: [],\n            priority: waveData.priority || 1,\n            dependencies: waveData.dependencies || [],\n            created: new Date().toISOString(),\n            modified: new Date().toISOString()\n        };\n        plan.waves.push(wave);\n        plan.modified = new Date().toISOString();\n        await this.savePlan(plan);\n        return wave;\n    }\n    /**\n     * Assign users to a wave\n     */\n    async assignUsersToWave(planId, waveId, userIds) {\n        const plan = this.plans.get(planId);\n        if (!plan) {\n            throw new Error(`Migration plan not found: ${planId}`);\n        }\n        const wave = plan.waves.find(w => w.id === waveId);\n        if (!wave) {\n            throw new Error(`Wave not found: ${waveId}`);\n        }\n        // Add unique users only\n        const existingUsers = new Set(wave.users);\n        userIds.forEach(userId => existingUsers.add(userId));\n        wave.users = Array.from(existingUsers);\n        wave.modified = new Date().toISOString();\n        plan.modified = new Date().toISOString();\n        await this.savePlan(plan);\n    }\n    /**\n     * Update wave status\n     */\n    async updateWaveStatus(planId, waveId, status) {\n        const plan = this.plans.get(planId);\n        if (!plan) {\n            throw new Error(`Migration plan not found: ${planId}`);\n        }\n        const wave = plan.waves.find(w => w.id === waveId);\n        if (!wave) {\n            throw new Error(`Wave not found: ${waveId}`);\n        }\n        wave.status = status;\n        wave.modified = new Date().toISOString();\n        plan.modified = new Date().toISOString();\n        await this.savePlan(plan);\n    }\n    /**\n     * Get migration plan\n     */\n    async getPlan(planId) {\n        if (this.plans.has(planId)) {\n            const plan = this.plans.get(planId);\n            return plan || null;\n        }\n        // Try to load from disk\n        const planPath = path.join(this.plansDir, `${planId}.json`);\n        if (fs.existsSync(planPath)) {\n            const content = await fs.promises.readFile(planPath, 'utf8');\n            const plan = JSON.parse(content);\n            this.plans.set(plan.id, plan);\n            return plan;\n        }\n        return null;\n    }\n    /**\n     * Get all migration plans for a profile\n     */\n    async getPlansByProfile(profileName) {\n        await this.loadAllPlans();\n        return Array.from(this.plans.values()).filter(p => p.profileName === profileName);\n    }\n    /**\n     * Delete migration plan\n     */\n    async deletePlan(planId) {\n        this.plans.delete(planId);\n        const planPath = path.join(this.plansDir, `${planId}.json`);\n        if (fs.existsSync(planPath)) {\n            await fs.promises.unlink(planPath);\n        }\n    }\n    /**\n     * Save migration plan to disk\n     */\n    async savePlan(plan) {\n        const planPath = path.join(this.plansDir, `${plan.id}.json`);\n        await fs.promises.writeFile(planPath, JSON.stringify(plan, null, 2), 'utf8');\n    }\n    /**\n     * Load all migration plans from disk\n     */\n    async loadAllPlans() {\n        if (!fs.existsSync(this.plansDir)) {\n            return;\n        }\n        const files = await fs.promises.readdir(this.plansDir);\n        const jsonFiles = files.filter(f => f.endsWith('.json'));\n        for (const file of jsonFiles) {\n            try {\n                const content = await fs.promises.readFile(path.join(this.plansDir, file), 'utf8');\n                const plan = JSON.parse(content);\n                this.plans.set(plan.id, plan);\n            }\n            catch (error) {\n                console.error(`Failed to load migration plan ${file}:`, error);\n            }\n        }\n    }\n    /**\n     * Get statistics\n     */\n    getStatistics() {\n        const allWaves = Array.from(this.plans.values()).flatMap(p => p.waves);\n        return {\n            totalPlans: this.plans.size,\n            totalWaves: allWaves.length,\n            wavesByStatus: {\n                planned: allWaves.filter(w => w.status === 'planned').length,\n                inprogress: allWaves.filter(w => w.status === 'inprogress').length,\n                completed: allWaves.filter(w => w.status === 'completed').length,\n                failed: allWaves.filter(w => w.status === 'failed').length\n            },\n            totalUsersAssigned: Array.from(new Set(allWaves.flatMap(w => w.users))).length\n        };\n    }\n}\n// Singleton instance\nlet migrationPlanningService = null;\nexport function getMigrationPlanningService(dataRoot) {\n    if (!migrationPlanningService) {\n        migrationPlanningService = new MigrationPlanningService(dataRoot);\n    }\n    return migrationPlanningService;\n}\nexport default MigrationPlanningService;\n"],"names":["registerMigrationPlanningHandlers","service","getMigrationPlanningService","ipcMain","handle","async","event","profileName","success","plans","getPlansByProfile","error","message","planData","plan","createPlan","data","wave","addWave","planId","waveData","assignUsersToWave","waveId","userIds","updateWaveStatus","status","deletePlan","getPlanById","MigrationPlanningService","plansDir","Map","constructor","dataRoot","this","ensureDirectoryExists","recursive","id","crypto","randomUUID","waves","created","Date","toISOString","modified","set","savePlan","get","Error","users","priority","dependencies","push","find","w","existingUsers","Set","forEach","userId","add","Array","from","getPlan","has","planPath","content","readFile","JSON","parse","loadAllPlans","values","filter","p","delete","unlink","writeFile","stringify","jsonFiles","readdir","f","endsWith","file","console","getStatistics","allWaves","flatMap","totalPlans","size","totalWaves","length","wavesByStatus","planned","inprogress","completed","failed","totalUsersAssigned","migrationPlanningService"],"sourceRoot":""}