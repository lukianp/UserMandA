{"version":3,"file":"src_main_ipc_dataExportImportHandlers_ts.main.js","mappings":"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","sources":["webpack://enterprise-discovery-suite/./src/main/ipc/dataExportImportHandlers.ts","webpack://enterprise-discovery-suite/./src/main/services/dataExportImportService.ts"],"sourcesContent":["/**\n * Data Export/Import IPC Handlers\n *\n * IPC handlers for data export and import service\n */\nimport { ipcMain } from 'electron';\nimport { getDataExportImportService } from '../services/dataExportImportService';\n/**\n * Register all data export/import IPC handlers\n */\nexport function registerDataExportImportHandlers() {\n    const service = getDataExportImportService();\n    // Export data\n    ipcMain.handle('data-export:export', async (event, params) => {\n        try {\n            const { data, filePath, options } = params;\n            // Determine format from file extension\n            const format = filePath.endsWith('.json')\n                ? 'JSON'\n                : filePath.endsWith('.xlsx')\n                    ? 'XLSX'\n                    : 'CSV';\n            let result;\n            switch (format) {\n                case 'JSON':\n                    result = await service.exportToJSON(data, filePath, options);\n                    break;\n                case 'XLSX':\n                    result = await service.exportToExcel(data, filePath, options);\n                    break;\n                default:\n                    result = await service.exportToCSV(data, filePath, options);\n            }\n            return result;\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    });\n    // Import data\n    ipcMain.handle('data-import:import', async (event, params) => {\n        try {\n            const { filePath, format } = params;\n            let result;\n            switch (format) {\n                case 'JSON':\n                    result = await service.importFromJSON(filePath);\n                    break;\n                case 'XLSX':\n                    result = await service.importFromExcel(filePath);\n                    break;\n                default:\n                    result = await service.importFromCSV(filePath);\n            }\n            return result;\n        }\n        catch (error) {\n            return {\n                success: false,\n                errors: [error.message],\n                warnings: []\n            };\n        }\n    });\n}\n","/**\n * Data Export/Import Service\n *\n * Handles exporting discovery data to various formats (CSV, JSON, XLSX)\n * and importing data for migration or analysis.\n *\n * Pattern from GUI/Services/ExportService.cs\n */\nimport * as fs from 'fs';\nimport * as path from 'path';\n/**\n * Data Export/Import Service\n */\nexport class DataExportImportService {\n    /**\n     * Export data to CSV format\n     */\n    async exportToCSV(data, filePath, options) {\n        try {\n            console.log(`[DataExport] Exporting ${data.length} records to CSV: ${filePath}`);\n            if (data.length === 0) {\n                return { success: false, error: 'No data to export' };\n            }\n            // Get headers from first record\n            const headers = options?.filterFields || Object.keys(data[0]);\n            // Build CSV content\n            const rows = [];\n            // Add headers\n            if (options?.includeHeaders !== false) {\n                rows.push(headers.map(h => this.escapeCSV(h)).join(','));\n            }\n            // Add data rows\n            for (const record of data) {\n                const values = headers.map(header => {\n                    const value = this.getNestedValue(record, header);\n                    return this.escapeCSV(this.formatValue(value));\n                });\n                rows.push(values.join(','));\n            }\n            // Write to file\n            await fs.promises.mkdir(path.dirname(filePath), { recursive: true });\n            await fs.promises.writeFile(filePath, rows.join('\\n'), 'utf8');\n            console.log(`[DataExport] Successfully exported to CSV: ${filePath}`);\n            return { success: true, filePath, recordCount: data.length };\n        }\n        catch (error) {\n            console.error(`[DataExport] CSV export failed:`, error);\n            return { success: false, error: error.message };\n        }\n    }\n    /**\n     * Export data to JSON format\n     */\n    async exportToJSON(data, filePath, options) {\n        try {\n            console.log(`[DataExport] Exporting ${data.length} records to JSON: ${filePath}`);\n            // Filter fields if specified\n            let exportData = data;\n            if (options?.filterFields && options.filterFields.length > 0) {\n                exportData = data.map(record => {\n                    const filtered = {};\n                    options.filterFields.forEach(field => {\n                        filtered[field] = this.getNestedValue(record, field);\n                    });\n                    return filtered;\n                });\n            }\n            // Build export object\n            const exportObject = {\n                data: exportData,\n                recordCount: data.length\n            };\n            // Add metadata if requested\n            if (options?.includeMetadata) {\n                exportObject.metadata = {\n                    exportDate: new Date().toISOString(),\n                    version: '2.0.0',\n                    source: 'M&A Discovery Suite'\n                };\n            }\n            // Write to file\n            await fs.promises.mkdir(path.dirname(filePath), { recursive: true });\n            await fs.promises.writeFile(filePath, JSON.stringify(exportObject, null, 2), 'utf8');\n            console.log(`[DataExport] Successfully exported to JSON: ${filePath}`);\n            return { success: true, filePath, recordCount: data.length };\n        }\n        catch (error) {\n            console.error(`[DataExport] JSON export failed:`, error);\n            return { success: false, error: error.message };\n        }\n    }\n    /**\n     * Import data from CSV file\n     */\n    async importFromCSV(filePath) {\n        try {\n            console.log(`[DataImport] Importing from CSV: ${filePath}`);\n            const content = await fs.promises.readFile(filePath, 'utf8');\n            const lines = content.split('\\n').filter(line => line.trim());\n            if (lines.length === 0) {\n                return { success: false, errors: ['File is empty'], warnings: [] };\n            }\n            // Parse headers\n            const headers = this.parseCSVLine(lines[0]);\n            // Parse data rows\n            const records = [];\n            const errors = [];\n            const warnings = [];\n            for (let i = 1; i < lines.length; i++) {\n                try {\n                    const values = this.parseCSVLine(lines[i]);\n                    if (values.length !== headers.length) {\n                        warnings.push(`Row ${i + 1}: Column count mismatch (expected ${headers.length}, got ${values.length})`);\n                        continue;\n                    }\n                    const record = {};\n                    headers.forEach((header, index) => {\n                        record[header] = values[index];\n                    });\n                    records.push(record);\n                }\n                catch (error) {\n                    errors.push(`Row ${i + 1}: ${error.message}`);\n                }\n            }\n            console.log(`[DataImport] Successfully imported ${records.length} records from CSV`);\n            return {\n                success: true,\n                recordCount: records.length,\n                errors,\n                warnings\n            };\n        }\n        catch (error) {\n            console.error(`[DataImport] CSV import failed:`, error);\n            return { success: false, errors: [error.message], warnings: [] };\n        }\n    }\n    /**\n     * Import data from JSON file\n     */\n    async importFromJSON(filePath) {\n        try {\n            console.log(`[DataImport] Importing from JSON: ${filePath}`);\n            const content = await fs.promises.readFile(filePath, 'utf8');\n            const parsed = JSON.parse(content);\n            // Handle different JSON structures\n            let data;\n            if (Array.isArray(parsed)) {\n                data = parsed;\n            }\n            else if (parsed.data && Array.isArray(parsed.data)) {\n                data = parsed.data;\n            }\n            else {\n                return {\n                    success: false,\n                    errors: ['Invalid JSON structure: expected array or object with \"data\" property'],\n                    warnings: []\n                };\n            }\n            console.log(`[DataImport] Successfully imported ${data.length} records from JSON`);\n            return {\n                success: true,\n                recordCount: data.length,\n                errors: [],\n                warnings: []\n            };\n        }\n        catch (error) {\n            console.error(`[DataImport] JSON import failed:`, error);\n            return { success: false, errors: [error.message], warnings: [] };\n        }\n    }\n    /**\n     * Escape CSV field value\n     */\n    escapeCSV(value) {\n        if (!value)\n            return '';\n        // If value contains comma, quote, or newline, wrap in quotes and escape quotes\n        if (value.includes(',') || value.includes('\"') || value.includes('\\n')) {\n            return `\"${value.replace(/\"/g, '\"\"')}\"`;\n        }\n        return value;\n    }\n    /**\n     * Parse CSV line respecting quoted values\n     */\n    parseCSVLine(line) {\n        const values = [];\n        let current = '';\n        let inQuotes = false;\n        for (let i = 0; i < line.length; i++) {\n            const char = line[i];\n            if (char === '\"') {\n                // Check if it's an escaped quote\n                if (inQuotes && line[i + 1] === '\"') {\n                    current += '\"';\n                    i++; // Skip next quote\n                }\n                else {\n                    inQuotes = !inQuotes;\n                }\n            }\n            else if (char === ',' && !inQuotes) {\n                values.push(current);\n                current = '';\n            }\n            else {\n                current += char;\n            }\n        }\n        // Add last value\n        values.push(current);\n        return values;\n    }\n    /**\n     * Get nested value from object using dot notation\n     */\n    getNestedValue(obj, path) {\n        const parts = path.split('.');\n        let value = obj;\n        for (const part of parts) {\n            if (value === null || value === undefined) {\n                return null;\n            }\n            value = value[part];\n        }\n        return value;\n    }\n    /**\n     * Format value for export\n     */\n    formatValue(value) {\n        if (value === null || value === undefined) {\n            return '';\n        }\n        if (typeof value === 'object') {\n            return JSON.stringify(value);\n        }\n        return String(value);\n    }\n}\n// Singleton instance\nlet dataExportImportService = null;\nexport function getDataExportImportService() {\n    if (!dataExportImportService) {\n        dataExportImportService = new DataExportImportService();\n    }\n    return dataExportImportService;\n}\nexport default DataExportImportService;\n"],"names":["registerDataExportImportHandlers","service","getDataExportImportService","ipcMain","handle","async","event","params","data","filePath","options","result","endsWith","exportToJSON","exportToExcel","exportToCSV","error","success","message","format","importFromJSON","importFromExcel","importFromCSV","errors","warnings","DataExportImportService","console","log","length","headers","filterFields","Object","keys","rows","includeHeaders","push","map","h","this","escapeCSV","join","record","values","header","value","getNestedValue","formatValue","mkdir","recursive","writeFile","recordCount","exportData","filtered","forEach","field","exportObject","includeMetadata","metadata","exportDate","Date","toISOString","version","source","JSON","stringify","lines","readFile","split","filter","line","trim","parseCSVLine","records","i","index","content","parsed","parse","Array","isArray","includes","replace","current","inQuotes","char","obj","path","parts","part","String","dataExportImportService"],"sourceRoot":""}