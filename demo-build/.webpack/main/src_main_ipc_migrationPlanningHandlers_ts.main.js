"use strict";exports.id="src_main_ipc_migrationPlanningHandlers_ts",exports.ids=["src_main_ipc_migrationPlanningHandlers_ts"],exports.modules={"./src/main/ipc/migrationPlanningHandlers.ts":(s,a,e)=>{e.d(a,{registerMigrationPlanningHandlers:()=>i});var n=e("electron"),t=e("./src/main/services/migrationPlanningService.ts");function i(){const s=(0,t.getMigrationPlanningService)();n.ipcMain.handle("migration-plan:get-by-profile",async(a,e)=>{try{return{success:!0,plans:await s.getPlansByProfile(e)}}catch(s){return{success:!1,error:s.message}}}),n.ipcMain.handle("migration-plan:create",async(a,e)=>{try{return{success:!0,plan:await s.createPlan(e)}}catch(s){return{success:!1,error:s.message}}}),n.ipcMain.handle("migration-plan:add-wave",async(a,e)=>{try{return{success:!0,wave:await s.addWave(e.planId,e.waveData)}}catch(s){return{success:!1,error:s.message}}}),n.ipcMain.handle("migration-plan:assign-users",async(a,e)=>{try{return await s.assignUsersToWave(e.planId,e.waveId,e.userIds),{success:!0}}catch(s){return{success:!1,error:s.message}}}),n.ipcMain.handle("migration-plan:update-wave-status",async(a,e)=>{try{return await s.updateWaveStatus(e.planId,e.waveId,e.status),{success:!0}}catch(s){return{success:!1,error:s.message}}}),n.ipcMain.handle("migration-plan:delete",async(a,e)=>{try{return await s.deletePlan(e),{success:!0}}catch(s){return{success:!1,error:s.message}}}),n.ipcMain.handle("migration-plan:get-by-id",async(a,e)=>{try{return{success:!0,plan:await s.getPlanById(e)}}catch(s){return{success:!1,error:s.message}}})}},"./src/main/services/migrationPlanningService.ts":(s,a,e)=>{e.d(a,{getMigrationPlanningService:()=>o});var n=e("fs"),t=e("path");class i{plansDir;plans=new Map;constructor(s="C:\\DiscoveryData"){this.plansDir=t.join(s,"MigrationPlans"),this.ensureDirectoryExists()}ensureDirectoryExists(){n.existsSync(this.plansDir)||n.mkdirSync(this.plansDir,{recursive:!0})}async createPlan(s){const a={id:crypto.randomUUID(),...s,waves:[],created:(new Date).toISOString(),modified:(new Date).toISOString()};return this.plans.set(a.id,a),await this.savePlan(a),a}async addWave(s,a){const e=this.plans.get(s);if(!e)throw new Error(`Migration plan not found: ${s}`);const n={id:crypto.randomUUID(),...a,status:"planned",users:[],priority:a.priority||1,dependencies:a.dependencies||[],created:(new Date).toISOString(),modified:(new Date).toISOString()};return e.waves.push(n),e.modified=(new Date).toISOString(),await this.savePlan(e),n}async assignUsersToWave(s,a,e){const n=this.plans.get(s);if(!n)throw new Error(`Migration plan not found: ${s}`);const t=n.waves.find(s=>s.id===a);if(!t)throw new Error(`Wave not found: ${a}`);const i=new Set(t.users);e.forEach(s=>i.add(s)),t.users=Array.from(i),t.modified=(new Date).toISOString(),n.modified=(new Date).toISOString(),await this.savePlan(n)}async updateWaveStatus(s,a,e){const n=this.plans.get(s);if(!n)throw new Error(`Migration plan not found: ${s}`);const t=n.waves.find(s=>s.id===a);if(!t)throw new Error(`Wave not found: ${a}`);t.status=e,t.modified=(new Date).toISOString(),n.modified=(new Date).toISOString(),await this.savePlan(n)}async getPlan(s){if(this.plans.has(s)){return this.plans.get(s)||null}const a=t.join(this.plansDir,`${s}.json`);if(n.existsSync(a)){const s=await n.promises.readFile(a,"utf8"),e=JSON.parse(s);return this.plans.set(e.id,e),e}return null}async getPlansByProfile(s){return await this.loadAllPlans(),Array.from(this.plans.values()).filter(a=>a.profileName===s)}async deletePlan(s){this.plans.delete(s);const a=t.join(this.plansDir,`${s}.json`);n.existsSync(a)&&await n.promises.unlink(a)}async savePlan(s){const a=t.join(this.plansDir,`${s.id}.json`);await n.promises.writeFile(a,JSON.stringify(s,null,2),"utf8")}async loadAllPlans(){if(!n.existsSync(this.plansDir))return;const s=(await n.promises.readdir(this.plansDir)).filter(s=>s.endsWith(".json"));for(const a of s)try{const s=await n.promises.readFile(t.join(this.plansDir,a),"utf8"),e=JSON.parse(s);this.plans.set(e.id,e)}catch(s){console.error(`Failed to load migration plan ${a}:`,s)}}getStatistics(){const s=Array.from(this.plans.values()).flatMap(s=>s.waves);return{totalPlans:this.plans.size,totalWaves:s.length,wavesByStatus:{planned:s.filter(s=>"planned"===s.status).length,inprogress:s.filter(s=>"inprogress"===s.status).length,completed:s.filter(s=>"completed"===s.status).length,failed:s.filter(s=>"failed"===s.status).length},totalUsersAssigned:Array.from(new Set(s.flatMap(s=>s.users))).length}}}let r=null;function o(s){return r||(r=new i(s)),r}}};
//# sourceMappingURL=src_main_ipc_migrationPlanningHandlers_ts.main.js.map