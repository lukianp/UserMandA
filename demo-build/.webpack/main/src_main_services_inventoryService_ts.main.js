"use strict";exports.id="src_main_services_inventoryService_ts",exports.ids=["src_main_services_inventoryService_ts"],exports.modules={"./src/main/services/inventoryService.ts":(e,t,s)=>{s.d(t,{getInventoryService:()=>u});var i=s("path"),n=s("fs/promises"),r=s("electron"),a=s("./node_modules/lowdb/lib/index.js"),o=s("./node_modules/lowdb/lib/node.js"),c=s("./node_modules/papaparse/papaparse.js");class d{db;isInitialized=!1;inventoryPath;dataRootPath;constructor(){this.inventoryPath=i.join(r.app.getPath("appData"),"MandADiscoverySuite","inventory.json"),this.dataRootPath=process.env.MANDA_DISCOVERY_PATH||("win32"===process.platform?i.join("C:","DiscoveryData"):i.join(r.app.getPath("userData"),"DiscoveryData"))}async initialize(){if(this.isInitialized)return;await n.mkdir(i.dirname(this.inventoryPath),{recursive:!0});const e=new o.JSONFile(this.inventoryPath);this.db=new a.Low(e,{entities:[],evidence:{},relations:{},version:1}),await this.db.read(),this.ensureData(),this.isInitialized=!0}ensureData(){this.db.data||(this.db.data={entities:[],evidence:{},relations:{},version:1}),this.db.data.entities||(this.db.data.entities=[]),this.db.data.evidence||(this.db.data.evidence={}),this.db.data.relations||(this.db.data.relations={}),this.db.data.version||(this.db.data.version=1)}determineUserMergeKey(e){return e.id||e.objectId?{key:"GUID",value:e.id||e.objectId}:e.userPrincipalName?{key:"UPN",value:e.userPrincipalName.toLowerCase()}:e.mail||e.email?{key:"EMAIL",value:(e.mail||e.email).toLowerCase()}:e.samAccountName?{key:"SAMACCOUNTNAME",value:e.samAccountName.toLowerCase()}:e.displayName?{key:"DISPLAYNAME",value:e.displayName.toLowerCase()}:null}mergeUserAttributes(e,t,s){const i=["displayName","mail","userPrincipalName","samAccountName"];for(const n of i){const i=e.externalIds[n]||e[n],r=t[n];r&&i&&i!==r?this.recordConflict(e,n,i,r,s):r&&!i&&("displayName"===n?e.displayName=r:e.externalIds[n]=r)}e.updatedAt=new Date}recordConflict(e,t,s,i,n){if(e.conflicts||(e.conflicts={}),e.conflicts[t]){const s=e.conflicts[t];s.sources.includes(n)||(s.sources.push(n),s.values[n]=i)}else e.conflicts[t]={sources:["EXISTING",n],values:{EXISTING:s,[n]:i},resolvedValue:s,resolvedBy:"SYSTEM",resolvedAt:new Date,severity:this.determineConflictSeverity(t)}}determineConflictSeverity(e){return["userPrincipalName","mail","objectId","id"].includes(e)?"HIGH":["displayName","samAccountName","department","manager"].includes(e)?"MEDIUM":"LOW"}levenshteinDistance(e,t){const s=[];for(let e=0;e<=t.length;e++)s[e]=[e];for(let t=0;t<=e.length;t++)s[0][t]=t;for(let i=1;i<=t.length;i++)for(let n=1;n<=e.length;n++)t.charAt(i-1)===e.charAt(n-1)?s[i][n]=s[i-1][n-1]:s[i][n]=Math.min(s[i-1][n-1]+1,s[i][n-1]+1,s[i-1][n]+1);return s[t.length][e.length]}applyFuzzyMatching(e,t=3){const s=[],i=new Set;for(const n of e){if(i.has(n.id))continue;let e=!1;for(const r of s){if(r.entityType!==n.entityType)continue;if(this.levenshteinDistance(r.displayName.toLowerCase(),n.displayName.toLowerCase())<=t){this.mergeUserAttributes(r,n.externalIds,"FUZZY_MATCH"),i.add(n.id),e=!0;break}}e||(s.push(n),i.add(n.id))}return console.log(`[InventoryService] Fuzzy matching reduced ${e.length} to ${s.length} entities`),s}async rebuildInventory(e){console.log(`[InventoryService] Starting consolidation for profile: ${e}`);try{await this.clearInventoryForProfile(e);const t=await this.loadDiscoveryFiles(e),s=await this.consolidateEntities(e,t),i=await this.createEvidence(e,s,t),n=await this.buildRelations(e,s,t);return await this.calculateScores(s,i,n),await this.saveInventory(e,s,i,n),console.log(`[InventoryService] Consolidation complete. Total entities: ${s.length}`),{entities:s,evidence:i,relations:n}}catch(e){throw console.error("[InventoryService] Consolidation failed:",e),e}}async loadDiscoveryFiles(e){const t=i.join(this.dataRootPath,e,"Raw"),s=e=>{const t={};for(const s of Object.keys(e)){t[s.charAt(0).toLowerCase()+s.slice(1)]=e[s],t[s]=e[s]}return t},r=async e=>{const r=i.join(t,e);try{const t=await n.readFile(r,"utf-8"),i=c.parse(t,{header:!0,skipEmptyLines:!0,dynamicTyping:!0});return console.log(`[InventoryService] âœ… Loaded ${i.data.length} records from ${e}`),i.data.map(s)}catch(t){return console.warn(`[InventoryService] Could not load ${e}:`,t),[]}},a=async e=>{const t=[];for(const s of e){const e=await r(s);t.push(...e)}return t};return{entraUsers:await a(["GraphUsers.csv","AzureDiscovery_Users.csv"]),entraGroups:await a(["GraphGroups.csv","AzureDiscovery_Groups.csv","ExchangeDistributionGroups.csv"]),azureResources:await a(["AzureResourceDiscovery_ResourceGroups.csv","AzureResourceDiscovery_NetworkSecurityGroups.csv"]),applications:await a(["EntraIDAppRegistrations.csv","EntraIDEnterpriseApps.csv","AzureDiscovery_Applications.csv"]),infrastructure:await r("SecurityInfrastructureDiscovery.csv")}}async loadDiscoveryDataChunked(e,t){const s=i.join(this.dataRootPath,e,"Raw"),r=["GraphUsers.csv","AzureDiscovery_Users.csv","GraphGroups.csv","AzureDiscovery_Groups.csv","ExchangeDistributionGroups.csv","EntraIDAppRegistrations.csv","EntraIDEnterpriseApps.csv","AzureDiscovery_Applications.csv","AzureResourceDiscovery_ResourceGroups.csv","AzureResourceDiscovery_NetworkSecurityGroups.csv","SecurityInfrastructureDiscovery.csv"];for(const e of r){const r=i.join(s,e);try{const s=await n.readFile(r,"utf-8");let i=[];const a=1e3;await new Promise((n,r)=>{c.parse(s,{header:!0,skipEmptyLines:!0,dynamicTyping:!0,chunk:async(s,n)=>{if(n.pause(),i.push(...s.data),i.length>=a)try{await t(i,e),i=[]}catch(e){return void r(e)}n.resume()},complete:async()=>{if(i.length>0)try{await t(i,e)}catch(e){return void r(e)}n()},error:e=>{r(e)}})}),console.log(`[InventoryService] Completed chunked loading of ${e}`)}catch(t){console.warn(`[InventoryService] Could not load ${e}:`,t)}}}async consolidateEntities(e,t){const s=[],i=new Map;for(const n of t.entraUsers){const t=this.determineUserMergeKey(n);if(!t){console.warn("[InventoryService] Skipping user record with no valid merge key:",n);continue}const r=`${t.key}:${t.value}`,a=i.get(r);if(a)this.mergeUserAttributes(a,n,"ENTRA_USERS");else{const t={id:this.generateUUID(),sourceProfileId:e,entityType:"USER",displayName:n.displayName||n.userPrincipalName||"Unknown User",externalIds:{objectId:n.id||n.objectId,upn:n.userPrincipalName,mail:n.mail||n.userPrincipalName,samAccountName:n.samAccountName},status:"DISCOVERED",createdAt:new Date,updatedAt:new Date};s.push(t),i.set(r,t)}}for(const i of t.entraGroups)s.push({id:this.generateUUID(),sourceProfileId:e,entityType:"GROUP",displayName:i.displayName||"Unknown Group",externalIds:{objectId:i.id||i.objectId},status:"DISCOVERED",createdAt:new Date,updatedAt:new Date});for(const i of[...t.azureResources,...t.applications])"Application"!==i.resourceType&&"ServicePrincipal"!==i.resourceType&&"Application"!==i.type||s.push({id:this.generateUUID(),sourceProfileId:e,entityType:"APPLICATION",displayName:i.displayName||i.name||"Unknown Application",externalIds:{appId:i.appId,objectId:i.id||i.objectId},status:"DISCOVERED",createdAt:new Date,updatedAt:new Date});for(const i of[...t.azureResources,...t.infrastructure])["VirtualMachine","StorageAccount","ResourceGroup","NetworkInterface"].includes(i.resourceType||i.type)&&s.push({id:this.generateUUID(),sourceProfileId:e,entityType:"INFRASTRUCTURE",displayName:i.name||i.displayName||"Unknown Resource",externalIds:{resourceId:i.id,subscriptionId:i.subscriptionId,hostname:i.computerName||i.dnsName},status:"DISCOVERED",createdAt:new Date,updatedAt:new Date});console.log(`[InventoryService] Created ${s.length} entities: ${s.filter(e=>"USER"===e.entityType).length} users, ${s.filter(e=>"GROUP"===e.entityType).length} groups, ${s.filter(e=>"APPLICATION"===e.entityType).length} apps, ${s.filter(e=>"INFRASTRUCTURE"===e.entityType).length} infra`);return this.applyFuzzyMatching(s,3)}async createEvidence(e,t,s){const i={};for(const e of t.filter(e=>"USER"===e.entityType)){const t=s.entraUsers.find(t=>t.id===e.externalIds.objectId||t.userPrincipalName===e.externalIds.upn);t&&(i[e.id]||(i[e.id]=[]),i[e.id].push({id:this.generateUUID(),inventoryEntityId:e.id,module:"ENTRA_USERS",sourceRecordRef:t.id||t.objectId,observedAt:new Date,payloadSnapshot:t}))}for(const e of t.filter(e=>"GROUP"===e.entityType)){const t=s.entraGroups.find(t=>t.id===e.externalIds.objectId);t&&(i[e.id]||(i[e.id]=[]),i[e.id].push({id:this.generateUUID(),inventoryEntityId:e.id,module:"ENTRA_GROUPS",sourceRecordRef:t.id||t.objectId,observedAt:new Date,payloadSnapshot:t}))}for(const e of t.filter(e=>"APPLICATION"===e.entityType||"INFRASTRUCTURE"===e.entityType)){const t=s.azureResources.find(t=>t.id===e.externalIds.resourceId||t.appId===e.externalIds.appId);t&&(i[e.id]||(i[e.id]=[]),i[e.id].push({id:this.generateUUID(),inventoryEntityId:e.id,module:"AZURE_RESOURCES",sourceRecordRef:t.id,observedAt:new Date,payloadSnapshot:t}))}return console.log(`[InventoryService] Created evidence for ${Object.keys(i).length} entities`),i}async buildRelations(e,t,s){const i={},n=(t,s,n,r)=>{const a={id:this.generateUUID(),sourceProfileId:e,fromEntityId:t,toEntityId:s,relationType:n,metadata:r,createdAt:new Date};i[t]||(i[t]=[]),i[s]||(i[s]=[]),i[t].push(a),i[s].push(a)};for(const e of s.entraGroups){const s=t.find(t=>t.externalIds.objectId===e.id&&"GROUP"===t.entityType);if(s&&e.members){const i=Array.isArray(e.members)?e.members:e.members.split(";");for(const e of i){const i=t.find(t=>(t.externalIds.objectId===e||t.externalIds.upn===e)&&"USER"===t.entityType);i&&n(i.id,s.id,"MEMBER_OF_GROUP",{source:"ENTRA_GROUPS"})}}}for(const e of[...s.azureResources,...s.applications]){const s=t.find(t=>(t.externalIds.appId===e.appId||t.externalIds.objectId===e.id)&&"APPLICATION"===t.entityType);if(s&&e.owners){const i=Array.isArray(e.owners)?e.owners:e.owners.split(";");for(const e of i){const i=t.find(t=>!(t.externalIds.objectId!==e&&t.externalIds.upn!==e||"USER"!==t.entityType&&"GROUP"!==t.entityType));i&&n(i.id,s.id,"OWNS_APPLICATION",{source:"AZURE_RESOURCES",role:"owner"})}}}return console.log(`[InventoryService] Built relations for ${Object.keys(i).length} entities`),i}async calculateScores(e,t,s){for(const i of e){let e=0,n=0;if(s[i.id]?.length>0&&(e+=.3),t[i.id]?.length>1&&(e+=.2),Object.keys(i.externalIds).length>1&&(e+=.2),"DISCOVERED"!==i.status&&(e+=.3),"APPLICATION"===i.entityType){0===(s[i.id]?.filter(e=>"OWNS_APPLICATION"===e.relationType&&e.toEntityId===i.id)||[]).length&&(n+=.3)}if("USER"===i.entityType){0===(s[i.id]?.filter(e=>"MEMBER_OF_GROUP"===e.relationType&&e.fromEntityId===i.id)||[]).length&&(n+=.2)}(!t[i.id]||t[i.id].length<2)&&(n+=.2),i.readinessScore=Math.min(e,1),i.riskScore=Math.min(n,1)}console.log(`[InventoryService] Calculated scores for ${e.length} entities`)}async saveInventory(e,t,s,i){await this.db.read(),this.ensureData(),this.db.data.entities.push(...t);for(const[e,t]of Object.entries(s))this.db.data.evidence[e]||(this.db.data.evidence[e]=[]),this.db.data.evidence[e].push(...t);for(const[e,t]of Object.entries(i))this.db.data.relations[e]||(this.db.data.relations[e]=[]),this.db.data.relations[e].push(...t);await this.db.write(),console.log("[InventoryService] Persisted inventory to database")}async clearInventoryForProfile(e){await this.db.read(),this.ensureData(),this.db.data.entities=this.db.data.entities.filter(t=>t.sourceProfileId!==e);const t=this.db.data.entities.map(e=>e.id),s={};for(const[e,i]of Object.entries(this.db.data.evidence))t.includes(e)&&(s[e]=i);this.db.data.evidence=s;const i={};for(const[t,s]of Object.entries(this.db.data.relations)){const n=s.filter(t=>t.sourceProfileId!==e);n.length>0&&(i[t]=n)}this.db.data.relations=i,await this.db.write(),console.log(`[InventoryService] Cleared inventory for profile: ${e}`)}generateUUID(){return`${Date.now()}-${Math.random().toString(36).substr(2,9)}`}async getStats(e){await this.db.read(),this.ensureData();const t=e?this.db.data.entities.filter(t=>t.sourceProfileId===e):this.db.data.entities,s={USER:0,GROUP:0,APPLICATION:0,INFRASTRUCTURE:0},i={DISCOVERED:0,TRIAGED:0,VERIFIED:0,ENRICHED:0,MIGRATION_READY:0,MIGRATED:0};let n=0,r=0,a=0,o=0,c=0;for(const e of t)s[e.entityType]++,i[e.status]++,e.readinessScore&&(n+=e.readinessScore),e.riskScore&&(r+=e.riskScore),this.db.data.evidence[e.id]&&a++,this.db.data.relations[e.id]&&o++,e.waveId&&c++;return{totalEntities:t.length,byType:s,byStatus:i,averageReadiness:t.length>0?n/t.length:0,averageRisk:t.length>0?r/t.length:0,entitiesWithEvidence:a,entitiesWithRelations:o,entitiesAssignedToWaves:c}}}let l=null;function u(){return l||(l=new d),l}}};
//# sourceMappingURL=src_main_services_inventoryService_ts.main.js.map