{"version":3,"file":"src_main_ipc_errorMonitoringHandlers_ts.main.js","mappings":"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","sources":["webpack://enterprise-discovery-suite/./src/main/ipc/errorMonitoringHandlers.ts","webpack://enterprise-discovery-suite/./src/main/services/errorHandlingService.ts"],"sourcesContent":["/**\n * Error Monitoring IPC Handlers\n *\n * IPC handlers for error monitoring and logging service\n */\nimport { ipcMain } from 'electron';\nimport { getErrorHandlingService } from '../services/errorHandlingService';\n/**\n * Register all error monitoring IPC handlers\n */\nexport function registerErrorMonitoringHandlers(mainWindow) {\n    const service = getErrorHandlingService();\n    // Forward log events to renderer\n    if (mainWindow) {\n        service.on('log', logEntry => {\n            mainWindow.webContents.send('error-monitoring:log', logEntry);\n        });\n        service.on('error-reported', errorReport => {\n            mainWindow.webContents.send('error-monitoring:error-reported', errorReport);\n        });\n    }\n    // Get error reports\n    ipcMain.handle('error-monitoring:get-reports', async (event, filter) => {\n        try {\n            const reports = service.getErrorReports(filter);\n            return { success: true, reports };\n        }\n        catch (error) {\n            return { success: false, error: error.message, reports: [] };\n        }\n    });\n    // Resolve error\n    ipcMain.handle('error-monitoring:resolve', async (event, params) => {\n        try {\n            await service.resolveErrorReport(params.reportId, params.notes);\n            return { success: true };\n        }\n        catch (error) {\n            return { success: false, error: error.message };\n        }\n    });\n    // Log message\n    ipcMain.handle('error-monitoring:log', async (event, params) => {\n        try {\n            service.log(params.level, params.category, params.message, params.context);\n            return { success: true };\n        }\n        catch (error) {\n            return { success: false, error: error.message };\n        }\n    });\n    // Report error\n    ipcMain.handle('error-monitoring:report-error', async (event, params) => {\n        try {\n            const reportId = await service.reportError(params.error, params.context);\n            return { success: true, reportId };\n        }\n        catch (error) {\n            return { success: false, error: error.message };\n        }\n    });\n    // Get logs\n    ipcMain.handle('error-monitoring:get-logs', async (event, filter) => {\n        try {\n            // Return recent logs from buffer\n            const logs = service.getRecentLogs(filter?.limit || 100);\n            // Apply filters\n            let filtered = logs;\n            if (filter?.level) {\n                filtered = filtered.filter((log) => log.level === filter.level);\n            }\n            if (filter?.category) {\n                filtered = filtered.filter((log) => log.category === filter.category);\n            }\n            return { success: true, logs: filtered };\n        }\n        catch (error) {\n            return { success: false, error: error.message, logs: [] };\n        }\n    });\n    // Subscribe to log events (return unsubscribe function)\n    ipcMain.handle('error-monitoring:subscribe', async (event, handlers) => {\n        // Note: This is handled via IPC events above\n        // This handler exists for compatibility but doesn't need implementation\n        return { success: true };\n    });\n}\n","/**\n * Error Handling and Logging Service\n *\n * Centralized error handling, logging, and error reporting system.\n * Pattern from GUI/Services/ErrorHandlingService.cs\n */\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { EventEmitter } from 'events';\n/**\n * Error Handling and Logging Service\n */\nexport class ErrorHandlingService extends EventEmitter {\n    logsDir;\n    errorsDir;\n    currentLogFile;\n    logBuffer = [];\n    flushInterval = null;\n    errorReports = new Map();\n    constructor(dataRoot = 'C:\\\\DiscoveryData') {\n        super();\n        this.logsDir = path.join(dataRoot, 'Logs');\n        this.errorsDir = path.join(dataRoot, 'Errors');\n        this.currentLogFile = this.getLogFilePath();\n        this.ensureDirectoriesExist();\n        this.startFlushInterval();\n    }\n    /**\n     * Ensure log directories exist\n     */\n    ensureDirectoriesExist() {\n        if (!fs.existsSync(this.logsDir)) {\n            fs.mkdirSync(this.logsDir, { recursive: true });\n        }\n        if (!fs.existsSync(this.errorsDir)) {\n            fs.mkdirSync(this.errorsDir, { recursive: true });\n        }\n    }\n    /**\n     * Get current log file path (daily rotation)\n     */\n    getLogFilePath() {\n        const date = new Date().toISOString().split('T')[0];\n        return path.join(this.logsDir, `app-${date}.log`);\n    }\n    /**\n     * Start periodic log flush\n     */\n    startFlushInterval() {\n        this.flushInterval = setInterval(() => {\n            this.flushLogs();\n        }, 5000); // Flush every 5 seconds\n    }\n    /**\n     * Log a message\n     */\n    log(level, category, message, context) {\n        const entry = {\n            timestamp: new Date().toISOString(),\n            level,\n            category,\n            message,\n            context\n        };\n        this.logBuffer.push(entry);\n        // Emit event for real-time monitoring\n        this.emit('log', entry);\n        // Console output\n        const consoleMessage = `[${entry.timestamp}] [${level.toUpperCase()}] [${category}] ${message}`;\n        switch (level) {\n            case 'debug':\n                console.debug(consoleMessage, context || '');\n                break;\n            case 'info':\n                console.log(consoleMessage, context || '');\n                break;\n            case 'warn':\n                console.warn(consoleMessage, context || '');\n                break;\n            case 'error':\n            case 'fatal':\n                console.error(consoleMessage, context || '');\n                break;\n        }\n        // Flush immediately for errors and fatals\n        if (level === 'error' || level === 'fatal') {\n            this.flushLogs();\n        }\n    }\n    /**\n     * Log debug message\n     */\n    debug(category, message, context) {\n        this.log('debug', category, message, context);\n    }\n    /**\n     * Log info message\n     */\n    info(category, message, context) {\n        this.log('info', category, message, context);\n    }\n    /**\n     * Log warning message\n     */\n    warn(category, message, context) {\n        this.log('warn', category, message, context);\n    }\n    /**\n     * Log error message\n     */\n    error(category, message, error, context) {\n        const entry = {\n            timestamp: new Date().toISOString(),\n            level: 'error',\n            category,\n            message,\n            context,\n            error: error\n                ? {\n                    name: error.name,\n                    message: error.message,\n                    stack: error.stack\n                }\n                : undefined\n        };\n        this.logBuffer.push(entry);\n        this.emit('log', entry);\n        this.emit('error', entry);\n        console.error(`[${entry.timestamp}] [ERROR] [${category}] ${message}`, error || '', context || '');\n        // Create error report\n        if (error) {\n            this.createErrorReport(error, context || {});\n        }\n        this.flushLogs();\n    }\n    /**\n     * Log fatal error\n     */\n    fatal(category, message, error, context) {\n        const entry = {\n            timestamp: new Date().toISOString(),\n            level: 'fatal',\n            category,\n            message,\n            context,\n            error: error\n                ? {\n                    name: error.name,\n                    message: error.message,\n                    stack: error.stack\n                }\n                : undefined\n        };\n        this.logBuffer.push(entry);\n        this.emit('log', entry);\n        this.emit('fatal', entry);\n        console.error(`[${entry.timestamp}] [FATAL] [${category}] ${message}`, error || '', context || '');\n        // Create error report\n        if (error) {\n            this.createErrorReport(error, context || {});\n        }\n        this.flushLogs();\n    }\n    /**\n     * Create error report for tracking and resolution\n     */\n    createErrorReport(error, context) {\n        const report = {\n            id: crypto.randomUUID(),\n            timestamp: new Date().toISOString(),\n            error,\n            context,\n            resolved: false\n        };\n        this.errorReports.set(report.id, report);\n        // Save error report to disk\n        const reportPath = path.join(this.errorsDir, `${report.id}.json`);\n        fs.promises.writeFile(reportPath, JSON.stringify({\n            ...report,\n            error: {\n                name: error.name,\n                message: error.message,\n                stack: error.stack\n            }\n        }, null, 2), 'utf8');\n    }\n    /**\n     * Flush log buffer to disk\n     */\n    flushLogs() {\n        if (this.logBuffer.length === 0) {\n            return;\n        }\n        // Check if we need to rotate log file\n        const currentPath = this.getLogFilePath();\n        if (currentPath !== this.currentLogFile) {\n            this.currentLogFile = currentPath;\n        }\n        // Format log entries\n        const logLines = this.logBuffer.map(entry => {\n            const parts = [\n                entry.timestamp,\n                entry.level.toUpperCase().padEnd(5),\n                entry.category.padEnd(20),\n                entry.message\n            ];\n            if (entry.context) {\n                parts.push(JSON.stringify(entry.context));\n            }\n            if (entry.error) {\n                parts.push(`\\n  Error: ${entry.error.name}: ${entry.error.message}`);\n                if (entry.error.stack) {\n                    parts.push(`\\n  Stack: ${entry.error.stack}`);\n                }\n            }\n            return parts.join(' | ');\n        });\n        // Append to log file\n        fs.appendFileSync(this.currentLogFile, logLines.join('\\n') + '\\n', 'utf8');\n        // Clear buffer\n        this.logBuffer = [];\n    }\n    /**\n     * Get error reports\n     */\n    getErrorReports(filter) {\n        let reports = Array.from(this.errorReports.values());\n        if (filter) {\n            if (filter.resolved !== undefined) {\n                reports = reports.filter(r => r.resolved === filter.resolved);\n            }\n            if (filter.since) {\n                const sinceDate = new Date(filter.since);\n                reports = reports.filter(r => new Date(r.timestamp) >= sinceDate);\n            }\n        }\n        return reports;\n    }\n    /**\n     * Resolve error report\n     */\n    async resolveErrorReport(reportId, notes) {\n        const report = this.errorReports.get(reportId);\n        if (report) {\n            report.resolved = true;\n            report.notes = notes;\n            // Update file\n            const reportPath = path.join(this.errorsDir, `${reportId}.json`);\n            if (fs.existsSync(reportPath)) {\n                await fs.promises.writeFile(reportPath, JSON.stringify({\n                    ...report,\n                    error: {\n                        name: report.error.name,\n                        message: report.error.message,\n                        stack: report.error.stack\n                    }\n                }, null, 2), 'utf8');\n            }\n        }\n    }\n    /**\n     * Report an error and create a report\n     */\n    async reportError(error, context) {\n        const report = {\n            id: crypto.randomUUID(),\n            timestamp: new Date().toISOString(),\n            error,\n            context: context || {},\n            resolved: false\n        };\n        this.errorReports.set(report.id, report);\n        // Save error report to disk\n        const reportPath = path.join(this.errorsDir, `${report.id}.json`);\n        await fs.promises.writeFile(reportPath, JSON.stringify({\n            ...report,\n            error: {\n                name: error.name,\n                message: error.message,\n                stack: error.stack\n            }\n        }, null, 2), 'utf8');\n        // Emit event\n        this.emit('error-reported', report);\n        return report.id;\n    }\n    /**\n     * Get recent logs\n     */\n    getRecentLogs(limit = 100) {\n        return this.logBuffer.slice(-limit);\n    }\n    /**\n     * Get log statistics\n     */\n    getStatistics() {\n        return {\n            totalLogs: this.logBuffer.length,\n            errorReports: this.errorReports.size,\n            unresolvedErrors: Array.from(this.errorReports.values()).filter(r => !r.resolved).length\n        };\n    }\n    /**\n     * Cleanup on shutdown\n     */\n    shutdown() {\n        if (this.flushInterval) {\n            clearInterval(this.flushInterval);\n            this.flushInterval = null;\n        }\n        this.flushLogs();\n    }\n}\n// Singleton instance\nlet errorHandlingService = null;\nexport function getErrorHandlingService(dataRoot) {\n    if (!errorHandlingService) {\n        errorHandlingService = new ErrorHandlingService(dataRoot);\n    }\n    return errorHandlingService;\n}\nexport default ErrorHandlingService;\n"],"names":["registerErrorMonitoringHandlers","mainWindow","service","getErrorHandlingService","on","logEntry","webContents","send","errorReport","ipcMain","handle","async","event","filter","success","reports","getErrorReports","error","message","params","resolveErrorReport","reportId","notes","log","level","category","context","reportError","filtered","getRecentLogs","limit","logs","handlers","ErrorHandlingService","EventEmitter","logsDir","errorsDir","currentLogFile","logBuffer","flushInterval","errorReports","Map","constructor","dataRoot","super","this","getLogFilePath","ensureDirectoriesExist","startFlushInterval","recursive","date","Date","toISOString","split","setInterval","flushLogs","entry","timestamp","push","emit","consoleMessage","toUpperCase","console","debug","warn","info","name","stack","undefined","createErrorReport","fatal","report","id","crypto","randomUUID","resolved","set","reportPath","writeFile","JSON","stringify","length","currentPath","logLines","map","parts","padEnd","join","Array","from","values","r","since","sinceDate","get","slice","getStatistics","totalLogs","size","unresolvedErrors","shutdown","clearInterval","errorHandlingService"],"sourceRoot":""}