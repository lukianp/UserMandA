"use strict";exports.id="src_main_ipcHandlers_waves_ts",exports.ids=["src_main_ipcHandlers_waves_ts"],exports.modules={"./src/main/ipcHandlers.waves.ts":(e,a,t)=>{t.d(a,{registerMigrationWaveHandlers:()=>i});var s=t("electron"),n=t("./src/main/services/migrationService.ts");function i(){const e=(0,n.getMigrationService)();e.initialize().catch(e=>{console.error("[WaveHandlers] Failed to initialize migration service:",e)}),s.ipcMain.handle("wave:create",async(a,t)=>{try{console.log(`[WaveHandlers] Creating wave: ${t.name}`);return{success:!0,data:await e.createWave(t)}}catch(e){return console.error("[WaveHandlers] Create wave failed:",e),{success:!1,error:e.message}}}),s.ipcMain.handle("wave:update",async(a,t,s)=>{try{console.log(`[WaveHandlers] Updating wave: ${t}`);const a=await e.updateWave(t,s);return a?{success:!0,data:a}:{success:!1,error:`Wave not found: ${t}`}}catch(e){return console.error("[WaveHandlers] Update wave failed:",e),{success:!1,error:e.message}}}),s.ipcMain.handle("wave:delete",async(a,t)=>{try{console.log(`[WaveHandlers] Deleting wave: ${t}`);return await e.deleteWave(t)?{success:!0}:{success:!1,error:`Wave not found: ${t}`}}catch(e){return console.error("[WaveHandlers] Delete wave failed:",e),{success:!1,error:e.message}}}),s.ipcMain.handle("wave:get",async(a,t)=>{try{const a=await e.getWave(t);return a?{success:!0,data:a}:{success:!1,error:`Wave not found: ${t}`}}catch(e){return console.error("[WaveHandlers] Get wave failed:",e),{success:!1,error:e.message}}}),s.ipcMain.handle("wave:get-by-profile",async(a,t)=>{try{return{success:!0,data:await e.getWavesByProfile(t)}}catch(e){return console.error("[WaveHandlers] Get waves by profile failed:",e),{success:!1,error:e.message}}}),s.ipcMain.handle("wave:get-all",async()=>{try{return{success:!0,data:await e.getAllWaves()}}catch(e){return console.error("[WaveHandlers] Get all waves failed:",e),{success:!1,error:e.message}}}),s.ipcMain.handle("wave:assign-entity",async(a,t,s,n)=>{try{console.log(`[WaveHandlers] Assigning entity ${s} to wave ${t}`);return{success:!0,data:await e.assignEntityToWave(t,s,n)}}catch(e){return console.error("[WaveHandlers] Assign entity failed:",e),{success:!1,error:e.message}}}),s.ipcMain.handle("wave:assign-entities",async(a,t,s,n)=>{try{console.log(`[WaveHandlers] Batch assigning ${s.length} entities to wave ${t}`);return{success:!0,data:await e.assignEntitiesToWave(t,s,n)}}catch(e){return console.error("[WaveHandlers] Batch assign entities failed:",e),{success:!1,error:e.message}}}),s.ipcMain.handle("wave:remove-entity",async(a,t,s)=>{try{console.log(`[WaveHandlers] Removing entity ${s} from wave ${t}`);return await e.removeEntityFromWave(t,s)?{success:!0}:{success:!1,error:"Assignment not found"}}catch(e){return console.error("[WaveHandlers] Remove entity failed:",e),{success:!1,error:e.message}}}),s.ipcMain.handle("wave:get-assignments",async(a,t)=>{try{return{success:!0,data:await e.getWaveAssignments(t)}}catch(e){return console.error("[WaveHandlers] Get wave assignments failed:",e),{success:!1,error:e.message}}}),s.ipcMain.handle("wave:get-entity-assignment",async(a,t)=>{try{return{success:!0,data:await e.getEntityWaveAssignment(t)}}catch(e){return console.error("[WaveHandlers] Get entity assignment failed:",e),{success:!1,error:e.message}}}),s.ipcMain.handle("wave:get-summary",async(a,t)=>{try{const a=await e.getWaveSummary(t);return a?{success:!0,data:a}:{success:!1,error:`Wave not found: ${t}`}}catch(e){return console.error("[WaveHandlers] Get wave summary failed:",e),{success:!1,error:e.message}}}),console.log("[WaveHandlers] Migration wave IPC handlers registered")}},"./src/main/services/migrationService.ts":(e,a,t)=>{t.d(a,{getMigrationService:()=>l});var s=t("path"),n=t("fs/promises"),i=t("electron"),r=t("./node_modules/lowdb/lib/index.js"),d=t("./node_modules/lowdb/lib/node.js"),o=t("./src/main/services/inventoryService.ts");class c{db;isInitialized=!1;dbPath;constructor(){this.dbPath=s.join(i.app.getPath("appData"),"MandADiscoverySuite","migration-waves.json")}async initialize(){if(this.isInitialized)return;await n.mkdir(s.dirname(this.dbPath),{recursive:!0});const e=new d.JSONFile(this.dbPath);this.db=new r.Low(e,{waves:[],assignments:[],version:1}),await this.db.read(),this.ensureData(),this.isInitialized=!0}ensureData(){this.db.data||(this.db.data={waves:[],assignments:[],version:1}),this.db.data.waves||(this.db.data.waves=[]),this.db.data.assignments||(this.db.data.assignments=[]),this.db.data.version||(this.db.data.version=1)}async createWave(e){await this.db.read(),this.ensureData();const a={id:this.generateUUID(),...e,createdAt:new Date,updatedAt:new Date};return this.db.data.waves.push(a),await this.db.write(),console.log(`[MigrationService] Created wave: ${a.name} (${a.id})`),a}async updateWave(e,a){await this.db.read(),this.ensureData();const t=this.db.data.waves.findIndex(a=>a.id===e);if(-1===t)return console.warn(`[MigrationService] Wave not found: ${e}`),null;const s={...this.db.data.waves[t],...a,id:e,updatedAt:new Date};return this.db.data.waves[t]=s,await this.db.write(),console.log(`[MigrationService] Updated wave: ${e}`),s}async deleteWave(e){await this.db.read(),this.ensureData();const a=this.db.data.waves.length;return this.db.data.waves=this.db.data.waves.filter(a=>a.id!==e),this.db.data.waves.length===a?(console.warn(`[MigrationService] Wave not found: ${e}`),!1):(this.db.data.assignments=this.db.data.assignments.filter(a=>a.waveId!==e),await this.db.write(),console.log(`[MigrationService] Deleted wave: ${e}`),!0)}async getWave(e){return await this.db.read(),this.ensureData(),this.db.data.waves.find(a=>a.id===e)||null}async getWavesByProfile(e){return await this.db.read(),this.ensureData(),this.db.data.waves.filter(a=>a.sourceProfileId===e)}async getAllWaves(){return await this.db.read(),this.ensureData(),[...this.db.data.waves]}async assignEntityToWave(e,a,t){await this.db.read(),this.ensureData();if(!this.db.data.waves.find(a=>a.id===e))throw new Error(`Wave not found: ${e}`);const s=this.db.data.assignments.find(t=>t.waveId===e&&t.inventoryEntityId===a);if(s)return console.warn(`[MigrationService] Entity already assigned to wave: ${a}`),s;const n={id:this.generateUUID(),waveId:e,inventoryEntityId:a,assignmentReason:t,createdAt:new Date};return this.db.data.assignments.push(n),await this.db.write(),console.log(`[MigrationService] Assigned entity ${a} to wave ${e}`),n}async assignEntitiesToWave(e,a,t){await this.db.read(),this.ensureData();if(!this.db.data.waves.find(a=>a.id===e))throw new Error(`Wave not found: ${e}`);const s=[],n=new Set(this.db.data.assignments.filter(a=>a.waveId===e).map(e=>e.inventoryEntityId));for(const i of a)if(n.has(i))console.warn(`[MigrationService] Entity ${i} already assigned to wave`);else{const a={id:this.generateUUID(),waveId:e,inventoryEntityId:i,assignmentReason:t,createdAt:new Date};s.push(a),this.db.data.assignments.push(a)}return await this.db.write(),console.log(`[MigrationService] Assigned ${s.length} entities to wave ${e}`),s}async removeEntityFromWave(e,a){await this.db.read(),this.ensureData();const t=this.db.data.assignments.length;return this.db.data.assignments=this.db.data.assignments.filter(t=>!(t.waveId===e&&t.inventoryEntityId===a)),this.db.data.assignments.length===t?(console.warn(`[MigrationService] Assignment not found: ${a} in wave ${e}`),!1):(await this.db.write(),console.log(`[MigrationService] Removed entity ${a} from wave ${e}`),!0)}async getWaveAssignments(e){return await this.db.read(),this.ensureData(),this.db.data.assignments.filter(a=>a.waveId===e)}async getEntityWaveAssignment(e){return await this.db.read(),this.ensureData(),this.db.data.assignments.find(a=>a.inventoryEntityId===e)||null}async getWaveSummary(e){if(!await this.getWave(e))return null;const a=await this.getWaveAssignments(e),t=(0,o.getInventoryService)();await t.initialize();return{waveId:e,entityCounts:{USER:0,GROUP:0,APPLICATION:0,INFRASTRUCTURE:0},readinessAverage:0,blockers:[],totalEntities:a.length}}generateUUID(){return`${Date.now()}-${Math.random().toString(36).substr(2,9)}`}}let v=null;function l(){return v||(v=new c),v}}};
//# sourceMappingURL=src_main_ipcHandlers_waves_ts.main.js.map