{"version":3,"file":"src_main_services_fileWatcherService_ts.main.js","mappings":"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","sources":["webpack://enterprise-discovery-suite/./src/main/services/fileWatcherService.ts"],"sourcesContent":["/**\n * File Watcher Service\n *\n * Monitors discovery data directories for file changes and provides\n * real-time notifications to the renderer process for automatic data reload.\n *\n * Features:\n * - Watches CSV and log files in discovery data directories\n * - Debounced change notifications (300ms)\n * - Per-profile watching with dynamic switching\n * - File statistics tracking\n * - Graceful error handling\n */\nimport { EventEmitter } from 'events';\nimport * as fs from 'fs/promises';\nimport * as fsSync from 'fs';\nimport * as path from 'path';\n/**\n * File Watcher Service\n *\n * Monitors discovery data directories and emits change events\n */\nexport class FileWatcherService extends EventEmitter {\n    config;\n    watchers = new Map();\n    mainWindow = null;\n    // Statistics\n    statistics = {\n        activeWatchers: 0,\n        watchedDirectories: [],\n        totalEvents: 0,\n        eventsByType: {\n            added: 0,\n            changed: 0,\n            deleted: 0,\n        },\n    };\n    // Debounce tracking\n    debounceTimers = new Map();\n    fileStates = new Map();\n    /**\n     * Create File Watcher Service\n     */\n    constructor(config = {}) {\n        super();\n        this.config = {\n            baseDataPath: config.baseDataPath || 'C:\\\\discoverydata',\n            debounceDelay: config.debounceDelay || 300,\n            watchExtensions: config.watchExtensions || ['.csv', '.json', '.log', '.txt'],\n        };\n    }\n    /**\n     * Set main window for IPC communication\n     */\n    setMainWindow(window) {\n        this.mainWindow = window;\n    }\n    /**\n     * Start watching a profile's directories\n     */\n    async watchProfile(profileId) {\n        // Stop existing watcher if any\n        if (this.watchers.has(profileId)) {\n            await this.stopWatching(profileId);\n        }\n        const rawPath = path.join(this.config.baseDataPath, profileId, 'Raw');\n        const logsPath = path.join(this.config.baseDataPath, profileId, 'Logs');\n        // Ensure directories exist\n        await this.ensureDirectories(rawPath, logsPath);\n        // Create watchers\n        const watcher = {\n            profileId,\n            rawWatcher: null,\n            logsWatcher: null,\n            rawPath,\n            logsPath,\n        };\n        try {\n            // Watch Raw directory\n            watcher.rawWatcher = this.createWatcher(rawPath, profileId, 'raw');\n            // Watch Logs directory\n            watcher.logsWatcher = this.createWatcher(logsPath, profileId, 'logs');\n            this.watchers.set(profileId, watcher);\n            this.statistics.activeWatchers = this.watchers.size;\n            this.updateWatchedDirectories();\n            console.log(`FileWatcherService: Started watching profile \"${profileId}\"`);\n            console.log(`  Raw: ${rawPath}`);\n            console.log(`  Logs: ${logsPath}`);\n        }\n        catch (error) {\n            console.error(`FileWatcherService: Failed to watch profile \"${profileId}\":`, error.message);\n            // Clean up partial watchers\n            if (watcher.rawWatcher) {\n                watcher.rawWatcher.close();\n            }\n            if (watcher.logsWatcher) {\n                watcher.logsWatcher.close();\n            }\n            throw error;\n        }\n    }\n    /**\n     * Stop watching a specific profile\n     */\n    async stopWatching(profileId) {\n        const watcher = this.watchers.get(profileId);\n        if (!watcher) {\n            console.warn(`FileWatcherService: No watcher found for profile \"${profileId}\"`);\n            return;\n        }\n        // Close watchers\n        if (watcher.rawWatcher) {\n            watcher.rawWatcher.close();\n        }\n        if (watcher.logsWatcher) {\n            watcher.logsWatcher.close();\n        }\n        // Clear debounce timers for this profile\n        const timerKeys = Array.from(this.debounceTimers.keys()).filter(key => key.startsWith(`${profileId}:`));\n        timerKeys.forEach(key => {\n            const timer = this.debounceTimers.get(key);\n            if (timer) {\n                clearTimeout(timer);\n                this.debounceTimers.delete(key);\n            }\n        });\n        // Clear file states for this profile\n        const stateKeys = Array.from(this.fileStates.keys()).filter(key => key.startsWith(`${profileId}:`));\n        stateKeys.forEach(key => {\n            this.fileStates.delete(key);\n        });\n        this.watchers.delete(profileId);\n        this.statistics.activeWatchers = this.watchers.size;\n        this.updateWatchedDirectories();\n        console.log(`FileWatcherService: Stopped watching profile \"${profileId}\"`);\n    }\n    /**\n     * Stop all watchers\n     */\n    async stopAll() {\n        const profileIds = Array.from(this.watchers.keys());\n        for (const profileId of profileIds) {\n            await this.stopWatching(profileId);\n        }\n        console.log('FileWatcherService: Stopped all watchers');\n    }\n    /**\n     * Get list of currently watched files\n     */\n    getWatchedFiles() {\n        const files = [];\n        for (const watcher of this.watchers.values()) {\n            try {\n                // List files in Raw directory\n                const rawFiles = fsSync.readdirSync(watcher.rawPath)\n                    .filter(f => this.shouldWatch(f))\n                    .map(f => path.join(watcher.rawPath, f));\n                // List files in Logs directory\n                const logFiles = fsSync.readdirSync(watcher.logsPath)\n                    .filter(f => this.shouldWatch(f))\n                    .map(f => path.join(watcher.logsPath, f));\n                files.push(...rawFiles, ...logFiles);\n            }\n            catch (error) {\n                // Directory might not exist or be inaccessible\n                console.warn(`FileWatcherService: Cannot list files for profile \"${watcher.profileId}\"`);\n            }\n        }\n        return files;\n    }\n    /**\n     * Get watcher statistics\n     */\n    getStatistics() {\n        return { ...this.statistics };\n    }\n    /**\n     * Create a file system watcher for a directory\n     */\n    createWatcher(dirPath, profileId, directory) {\n        const watcher = fsSync.watch(dirPath, {\n            persistent: true,\n            recursive: false,\n        }, (eventType, filename) => {\n            if (!filename)\n                return;\n            // Only watch specific extensions\n            if (!this.shouldWatch(filename))\n                return;\n            const filePath = path.join(dirPath, filename);\n            const key = `${profileId}:${directory}:${filename}`;\n            // Debounce the event\n            this.debounceEvent(key, () => {\n                this.handleFileChange(eventType, filePath, profileId, directory, filename);\n            });\n        });\n        watcher.on('error', (error) => {\n            console.error(`FileWatcherService: Watcher error for ${dirPath}:`, error);\n            this.emit('error', { profileId, directory, error });\n        });\n        return watcher;\n    }\n    /**\n     * Handle file change event\n     */\n    async handleFileChange(eventType, filePath, profileId, directory, fileName) {\n        const stateKey = `${profileId}:${directory}:${fileName}`;\n        let changeType;\n        try {\n            // Check if file exists\n            const stats = await fs.stat(filePath);\n            const currentState = {\n                size: stats.size,\n                mtime: stats.mtimeMs,\n            };\n            const previousState = this.fileStates.get(stateKey);\n            if (!previousState) {\n                // New file\n                changeType = 'added';\n                this.statistics.eventsByType.added++;\n            }\n            else if (previousState.size !== currentState.size ||\n                previousState.mtime !== currentState.mtime) {\n                // File modified\n                changeType = 'changed';\n                this.statistics.eventsByType.changed++;\n            }\n            else {\n                // No real change (spurious event)\n                return;\n            }\n            this.fileStates.set(stateKey, currentState);\n            const event = {\n                type: changeType,\n                filePath,\n                fileName,\n                directory,\n                profileId,\n                timestamp: new Date(),\n                fileSize: stats.size,\n                extension: path.extname(fileName),\n            };\n            this.emitChangeEvent(event);\n        }\n        catch (error) {\n            if (error.code === 'ENOENT') {\n                // File deleted\n                changeType = 'deleted';\n                this.statistics.eventsByType.deleted++;\n                this.fileStates.delete(stateKey);\n                const event = {\n                    type: 'deleted',\n                    filePath,\n                    fileName,\n                    directory,\n                    profileId,\n                    timestamp: new Date(),\n                };\n                this.emitChangeEvent(event);\n            }\n            else {\n                console.error(`FileWatcherService: Error handling file change:`, error);\n            }\n        }\n    }\n    /**\n     * Emit file change event to renderer\n     */\n    emitChangeEvent(event) {\n        this.statistics.totalEvents++;\n        this.statistics.lastEventTimestamp = event.timestamp;\n        // Emit to EventEmitter listeners\n        this.emit('fileChanged', event);\n        // Send to renderer process via IPC\n        if (this.mainWindow && !this.mainWindow.isDestroyed()) {\n            this.mainWindow.webContents.send('file:changed', event);\n        }\n        console.log(`FileWatcherService: ${event.type.toUpperCase()} - ${event.fileName} (${event.directory})`);\n    }\n    /**\n     * Debounce file change events\n     */\n    debounceEvent(key, callback) {\n        // Clear existing timer\n        const existing = this.debounceTimers.get(key);\n        if (existing) {\n            clearTimeout(existing);\n        }\n        // Set new timer\n        const timer = setTimeout(() => {\n            callback();\n            this.debounceTimers.delete(key);\n        }, this.config.debounceDelay);\n        this.debounceTimers.set(key, timer);\n    }\n    /**\n     * Check if file should be watched based on extension\n     */\n    shouldWatch(filename) {\n        const ext = path.extname(filename).toLowerCase();\n        return this.config.watchExtensions.includes(ext);\n    }\n    /**\n     * Ensure directories exist, create if needed\n     */\n    async ensureDirectories(rawPath, logsPath) {\n        try {\n            await fs.mkdir(rawPath, { recursive: true });\n            await fs.mkdir(logsPath, { recursive: true });\n        }\n        catch (error) {\n            console.error('FileWatcherService: Failed to create directories:', error.message);\n            throw error;\n        }\n    }\n    /**\n     * Update watched directories list in statistics\n     */\n    updateWatchedDirectories() {\n        const dirs = [];\n        for (const watcher of this.watchers.values()) {\n            dirs.push(watcher.rawPath, watcher.logsPath);\n        }\n        this.statistics.watchedDirectories = dirs;\n    }\n}\n/**\n * Singleton instance\n */\nlet instance = null;\n/**\n * Get or create FileWatcherService instance\n */\nexport function getFileWatcherService(config) {\n    if (!instance) {\n        instance = new FileWatcherService(config);\n    }\n    return instance;\n}\n"],"names":["FileWatcherService","EventEmitter","config","watchers","Map","mainWindow","statistics","activeWatchers","watchedDirectories","totalEvents","eventsByType","added","changed","deleted","debounceTimers","fileStates","constructor","super","this","baseDataPath","debounceDelay","watchExtensions","setMainWindow","window","watchProfile","profileId","has","stopWatching","rawPath","logsPath","ensureDirectories","watcher","rawWatcher","logsWatcher","createWatcher","set","size","updateWatchedDirectories","console","log","error","message","close","get","warn","Array","from","keys","filter","key","startsWith","forEach","timer","clearTimeout","delete","stopAll","profileIds","getWatchedFiles","files","values","rawFiles","f","shouldWatch","map","logFiles","push","getStatistics","dirPath","directory","persistent","recursive","eventType","filename","filePath","debounceEvent","handleFileChange","on","emit","fileName","stateKey","changeType","stats","currentState","mtime","mtimeMs","previousState","event","type","timestamp","Date","fileSize","extension","emitChangeEvent","code","lastEventTimestamp","isDestroyed","webContents","send","toUpperCase","callback","existing","setTimeout","ext","toLowerCase","includes","dirs","instance","getFileWatcherService"],"sourceRoot":""}