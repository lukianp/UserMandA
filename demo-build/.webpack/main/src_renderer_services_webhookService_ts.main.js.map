{"version":3,"file":"src_renderer_services_webhookService_ts.main.js","mappings":"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","sources":["webpack://enterprise-discovery-suite/./src/renderer/services/loggingService.ts","webpack://enterprise-discovery-suite/./src/renderer/services/webhookService.ts"],"sourcesContent":["/**\n * Enhanced Logging Service\n *\n * Features:\n * - Structured logging with context and correlation IDs\n * - Multiple log levels with filtering (TRACE, DEBUG, INFO, WARN, ERROR, FATAL)\n * - Multiple log transports (console, file via IPC, remote)\n * - Log rotation (daily, size-based)\n * - Log search and filtering\n * - Performance logging with method timing\n * - Error stack trace capture\n * - Log correlation IDs for request tracking\n */\n/**\n * Log levels with numeric priorities\n */\nexport var LogLevel;\n(function (LogLevel) {\n    LogLevel[LogLevel[\"TRACE\"] = 0] = \"TRACE\";\n    LogLevel[LogLevel[\"DEBUG\"] = 1] = \"DEBUG\";\n    LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\n    LogLevel[LogLevel[\"WARN\"] = 3] = \"WARN\";\n    LogLevel[LogLevel[\"ERROR\"] = 4] = \"ERROR\";\n    LogLevel[LogLevel[\"FATAL\"] = 5] = \"FATAL\";\n})(LogLevel || (LogLevel = {}));\n/**\n * Enhanced Logging Service\n */\nclass LoggingService {\n    logs = [];\n    config;\n    correlationIdStack = [];\n    performanceMarks = new Map();\n    sessionId;\n    userId;\n    constructor() {\n        this.config = {\n            minLevel: LogLevel.INFO,\n            maxLogs: 10000,\n            transports: ['console'],\n            enablePerformanceLogging: true,\n            enableStackTrace: true,\n            rotationSize: 10 * 1024 * 1024, // 10MB\n            rotationInterval: 86400000, // 24 hours\n        };\n        this.sessionId = globalThis.crypto.randomUUID();\n        // Load persisted logs from localStorage\n        this.loadLogs();\n    }\n    /**\n     * Configure logging service\n     */\n    configure(config) {\n        this.config = { ...this.config, ...config };\n        console.log('Logging service configured:', this.config);\n    }\n    /**\n     * Set minimum log level\n     */\n    setLogLevel(level) {\n        this.config.minLevel = level;\n    }\n    /**\n     * Set user ID for logging context\n     */\n    setUserId(userId) {\n        this.userId = userId;\n    }\n    /**\n     * Start a correlation context\n     */\n    startCorrelation(id) {\n        const correlationId = id || globalThis.crypto.randomUUID();\n        this.correlationIdStack.push(correlationId);\n        return correlationId;\n    }\n    /**\n     * End the current correlation context\n     */\n    endCorrelation() {\n        this.correlationIdStack.pop();\n    }\n    /**\n     * Get current correlation ID\n     */\n    getCurrentCorrelationId() {\n        return this.correlationIdStack[this.correlationIdStack.length - 1];\n    }\n    /**\n     * TRACE level logging\n     */\n    trace(message, context, data) {\n        this.log(LogLevel.TRACE, message, context, data);\n    }\n    /**\n     * DEBUG level logging\n     */\n    debug(message, context, data) {\n        this.log(LogLevel.DEBUG, message, context, data);\n    }\n    /**\n     * INFO level logging\n     */\n    info(message, context, data) {\n        this.log(LogLevel.INFO, message, context, data);\n    }\n    /**\n     * WARN level logging\n     */\n    warn(message, context, data) {\n        this.log(LogLevel.WARN, message, context, data);\n    }\n    /**\n     * ERROR level logging\n     */\n    error(message, context, data, error) {\n        const errorData = error && this.config.enableStackTrace ? {\n            name: error.name,\n            message: error.message,\n            stack: error.stack,\n        } : undefined;\n        this.log(LogLevel.ERROR, message, context, data, errorData);\n    }\n    /**\n     * FATAL level logging\n     */\n    fatal(message, context, data, error) {\n        const errorData = error && this.config.enableStackTrace ? {\n            name: error.name,\n            message: error.message,\n            stack: error.stack,\n        } : undefined;\n        this.log(LogLevel.FATAL, message, context, data, errorData);\n    }\n    /**\n     * Core logging method\n     */\n    log(level, message, context, data, error) {\n        // Check if log level is enabled\n        if (level < this.config.minLevel) {\n            return;\n        }\n        const entry = {\n            id: globalThis.crypto.randomUUID(),\n            timestamp: new Date(),\n            level,\n            levelName: LogLevel[level],\n            message,\n            context,\n            correlationId: this.getCurrentCorrelationId(),\n            data,\n            error,\n            tags: [],\n            userId: this.userId,\n            sessionId: this.sessionId,\n        };\n        this.logs.push(entry);\n        // Manage log rotation\n        if (this.logs.length > this.config.maxLogs) {\n            this.logs = this.logs.slice(-this.config.maxLogs);\n        }\n        // Output to transports\n        this.outputToTransports(entry);\n        // Persist logs periodically\n        if (this.logs.length % 10 === 0) {\n            this.persistLogs();\n        }\n    }\n    /**\n     * Performance logging - start timing\n     */\n    startPerformanceMeasure(methodName) {\n        if (!this.config.enablePerformanceLogging)\n            return;\n        this.performanceMarks.set(methodName, performance.now());\n    }\n    /**\n     * Performance logging - end timing and log\n     */\n    endPerformanceMeasure(methodName, context) {\n        if (!this.config.enablePerformanceLogging)\n            return null;\n        const startTime = this.performanceMarks.get(methodName);\n        if (!startTime) {\n            this.warn(`No performance mark found for ${methodName}`, 'Performance');\n            return null;\n        }\n        const duration = performance.now() - startTime;\n        this.performanceMarks.delete(methodName);\n        // Log performance entry\n        const entry = {\n            id: globalThis.crypto.randomUUID(),\n            timestamp: new Date(),\n            level: LogLevel.DEBUG,\n            levelName: 'DEBUG',\n            message: `Performance: ${methodName}`,\n            context: context || 'Performance',\n            correlationId: this.getCurrentCorrelationId(),\n            performance: {\n                duration,\n                method: methodName,\n            },\n            sessionId: this.sessionId,\n            userId: this.userId,\n        };\n        this.logs.push(entry);\n        this.outputToTransports(entry);\n        return duration;\n    }\n    /**\n     * Measure async function performance\n     */\n    async measureAsync(methodName, fn, context) {\n        this.startPerformanceMeasure(methodName);\n        try {\n            return await fn();\n        }\n        finally {\n            this.endPerformanceMeasure(methodName, context);\n        }\n    }\n    /**\n     * Output log entry to configured transports\n     */\n    outputToTransports(entry) {\n        for (const transport of this.config.transports) {\n            switch (transport) {\n                case 'console':\n                    this.outputToConsole(entry);\n                    break;\n                case 'file':\n                    this.outputToFile(entry);\n                    break;\n                case 'remote':\n                    this.outputToRemote(entry);\n                    break;\n            }\n        }\n    }\n    /**\n     * Output to console\n     */\n    outputToConsole(entry) {\n        const timestamp = entry.timestamp.toISOString();\n        const level = entry.levelName.padEnd(5);\n        const context = entry.context ? `[${entry.context}]` : '';\n        const correlationId = entry.correlationId ? `[${entry.correlationId.slice(0, 8)}]` : '';\n        let logFn = console.log;\n        let color = '';\n        switch (entry.level) {\n            case LogLevel.TRACE:\n                logFn = console.debug;\n                color = '\\x1b[90m'; // Gray\n                break;\n            case LogLevel.DEBUG:\n                logFn = console.debug;\n                color = '\\x1b[36m'; // Cyan\n                break;\n            case LogLevel.INFO:\n                logFn = console.info;\n                color = '\\x1b[32m'; // Green\n                break;\n            case LogLevel.WARN:\n                logFn = console.warn;\n                color = '\\x1b[33m'; // Yellow\n                break;\n            case LogLevel.ERROR:\n                logFn = console.error;\n                color = '\\x1b[31m'; // Red\n                break;\n            case LogLevel.FATAL:\n                logFn = console.error;\n                color = '\\x1b[35m'; // Magenta\n                break;\n        }\n        const reset = '\\x1b[0m';\n        logFn(`${color}${timestamp} ${level}${reset} ${context}${correlationId} ${entry.message}`);\n        if (entry.data) {\n            console.log('  Data:', entry.data);\n        }\n        if (entry.error) {\n            console.error('  Error:', entry.error.message);\n            if (entry.error.stack) {\n                console.error(entry.error.stack);\n            }\n        }\n        if (entry.performance) {\n            console.log(`  Duration: ${entry.performance.duration.toFixed(2)}ms`);\n        }\n    }\n    /**\n     * Output to file (via IPC to main process)\n     */\n    outputToFile(entry) {\n        // Send to main process for file writing\n        if (window.electronAPI?.logToFile) {\n            window.electronAPI.logToFile(entry).catch((err) => {\n                console.error('Failed to write log to file:', err);\n            });\n        }\n    }\n    /**\n     * Output to remote logging service\n     */\n    outputToRemote(entry) {\n        // Would send to remote logging service (e.g., Elasticsearch, Splunk)\n        // Implementation depends on specific service\n    }\n    /**\n     * Get all logs\n     */\n    getLogs() {\n        return [...this.logs];\n    }\n    /**\n     * Filter logs by criteria\n     */\n    filterLogs(filter) {\n        return this.logs.filter((entry) => {\n            if (filter.levels && !filter.levels.includes(entry.level)) {\n                return false;\n            }\n            if (filter.contexts && entry.context && !filter.contexts.includes(entry.context)) {\n                return false;\n            }\n            if (filter.correlationId && entry.correlationId !== filter.correlationId) {\n                return false;\n            }\n            if (filter.startTime && entry.timestamp < filter.startTime) {\n                return false;\n            }\n            if (filter.endTime && entry.timestamp > filter.endTime) {\n                return false;\n            }\n            if (filter.searchText) {\n                const searchLower = filter.searchText.toLowerCase();\n                const matchesMessage = entry.message.toLowerCase().includes(searchLower);\n                const matchesContext = entry.context?.toLowerCase().includes(searchLower);\n                const matchesData = JSON.stringify(entry.data || {}).toLowerCase().includes(searchLower);\n                if (!matchesMessage && !matchesContext && !matchesData) {\n                    return false;\n                }\n            }\n            if (filter.tags && entry.tags) {\n                const hasTag = filter.tags.some((tag) => entry.tags.includes(tag));\n                if (!hasTag) {\n                    return false;\n                }\n            }\n            return true;\n        });\n    }\n    /**\n     * Search logs by text\n     */\n    searchLogs(query) {\n        return this.filterLogs({ searchText: query });\n    }\n    /**\n     * Get logs by correlation ID\n     */\n    getLogsByCorrelation(correlationId) {\n        return this.filterLogs({ correlationId });\n    }\n    /**\n     * Clear all logs\n     */\n    clearLogs() {\n        this.logs = [];\n        localStorage.removeItem('app_logs');\n        console.log('All logs cleared');\n    }\n    /**\n     * Persist logs to localStorage\n     */\n    persistLogs() {\n        try {\n            // Store last 1000 logs\n            const logsToStore = this.logs.slice(-1000);\n            localStorage.setItem('app_logs', JSON.stringify(logsToStore));\n        }\n        catch (error) {\n            console.error('Failed to persist logs:', error);\n        }\n    }\n    /**\n     * Load logs from localStorage\n     */\n    loadLogs() {\n        try {\n            const stored = localStorage.getItem('app_logs');\n            if (stored) {\n                const logs = JSON.parse(stored);\n                // Convert timestamp strings back to Date objects\n                this.logs = logs.map((entry) => ({\n                    ...entry,\n                    timestamp: new Date(entry.timestamp),\n                }));\n                console.log(`Loaded ${this.logs.length} persisted logs`);\n            }\n        }\n        catch (error) {\n            console.error('Failed to load persisted logs:', error);\n        }\n    }\n    /**\n     * Export logs to JSON\n     */\n    exportLogs(format = 'json') {\n        let content;\n        let mimeType;\n        let extension;\n        if (format === 'json') {\n            content = JSON.stringify(this.logs, null, 2);\n            mimeType = 'application/json';\n            extension = 'json';\n        }\n        else {\n            // CSV format\n            const headers = ['timestamp', 'level', 'context', 'correlationId', 'message', 'data'];\n            const rows = this.logs.map((entry) => [\n                entry.timestamp.toISOString(),\n                entry.levelName,\n                entry.context || '',\n                entry.correlationId || '',\n                entry.message,\n                JSON.stringify(entry.data || {}),\n            ]);\n            content = [headers, ...rows].map((row) => row.map((cell) => `\"${cell}\"`).join(',')).join('\\n');\n            mimeType = 'text/csv';\n            extension = 'csv';\n        }\n        const blob = new Blob([content], { type: mimeType });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = `logs_${new Date().toISOString().replace(/[:.]/g, '-')}.${extension}`;\n        a.click();\n        URL.revokeObjectURL(url);\n        this.info('Logs exported', 'LoggingService', { format, count: this.logs.length });\n    }\n    /**\n     * Get logging statistics\n     */\n    getStatistics() {\n        const total = this.logs.length;\n        const byLevel = {};\n        for (let level = LogLevel.TRACE; level <= LogLevel.FATAL; level++) {\n            byLevel[LogLevel[level]] = this.logs.filter((l) => l.level === level).length;\n        }\n        const contexts = new Set(this.logs.map((l) => l.context).filter(Boolean));\n        const correlations = new Set(this.logs.map((l) => l.correlationId).filter(Boolean));\n        return {\n            total,\n            byLevel,\n            uniqueContexts: contexts.size,\n            uniqueCorrelations: correlations.size,\n            sessionId: this.sessionId,\n            userId: this.userId,\n            oldestLog: this.logs[0]?.timestamp,\n            newestLog: this.logs[this.logs.length - 1]?.timestamp,\n        };\n    }\n}\nexport default new LoggingService();\n","/**\n * Webhook Service\n *\n * Enterprise webhook management with:\n * - Webhook registration and management\n * - Event-based webhook triggers\n * - Retry logic with exponential backoff\n * - Webhook signature verification\n * - Delivery tracking and logs\n * - Rate limiting\n * - Webhook testing and validation\n */\nimport loggingService from './loggingService';\n/**\n * Webhook Service\n */\nexport class WebhookService {\n    static instance;\n    webhooks = new Map();\n    deliveries = [];\n    maxDeliveryHistory = 1000;\n    rateLimitMap = new Map(); // Track request timestamps\n    maxRequestsPerMinute = 60;\n    constructor() {\n        // Initialize webhook service\n        loggingService.debug('WebhookService instance created', 'WebhookService');\n    }\n    /**\n     * Get singleton instance\n     */\n    static getInstance() {\n        if (!WebhookService.instance) {\n            WebhookService.instance = new WebhookService();\n        }\n        return WebhookService.instance;\n    }\n    /**\n     * Register a webhook\n     */\n    register(config) {\n        this.webhooks.set(config.id, {\n            timeout: 30000,\n            retryCount: 3,\n            retryDelay: 1000,\n            ...config,\n            enabled: config.enabled ?? true,\n        });\n        loggingService.info(`Webhook registered: ${config.name}`, 'WebhookService', {\n            id: config.id,\n            url: config.url,\n            events: config.events,\n        });\n    }\n    /**\n     * Unregister a webhook\n     */\n    unregister(webhookId) {\n        const deleted = this.webhooks.delete(webhookId);\n        if (deleted) {\n            loggingService.info(`Webhook unregistered: ${webhookId}`, 'WebhookService');\n        }\n        return deleted;\n    }\n    /**\n     * Get webhook by ID\n     */\n    getWebhook(webhookId) {\n        return this.webhooks.get(webhookId);\n    }\n    /**\n     * Get all webhooks\n     */\n    getAllWebhooks() {\n        return Array.from(this.webhooks.values());\n    }\n    /**\n     * Update webhook configuration\n     */\n    update(webhookId, updates) {\n        const webhook = this.webhooks.get(webhookId);\n        if (!webhook) {\n            return false;\n        }\n        this.webhooks.set(webhookId, {\n            ...webhook,\n            ...updates,\n            id: webhookId, // Prevent ID change\n        });\n        loggingService.info(`Webhook updated: ${webhookId}`, 'WebhookService');\n        return true;\n    }\n    /**\n     * Enable webhook\n     */\n    enable(webhookId) {\n        return this.update(webhookId, { enabled: true });\n    }\n    /**\n     * Disable webhook\n     */\n    disable(webhookId) {\n        return this.update(webhookId, { enabled: false });\n    }\n    /**\n     * Trigger webhooks for an event\n     */\n    async trigger(event, data, metadata) {\n        const webhooks = this.getWebhooksForEvent(event);\n        if (webhooks.length === 0) {\n            loggingService.debug(`No webhooks registered for event: ${event}`, 'WebhookService');\n            return;\n        }\n        const payload = {\n            event,\n            timestamp: new Date().toISOString(),\n            data,\n            metadata,\n        };\n        const deliveryPromises = webhooks.map((webhook) => this.deliver(webhook, payload));\n        await Promise.allSettled(deliveryPromises);\n    }\n    /**\n     * Get webhooks subscribed to an event\n     */\n    getWebhooksForEvent(event) {\n        return Array.from(this.webhooks.values()).filter((webhook) => webhook.enabled &&\n            (webhook.events.includes(event) || webhook.events.includes('*')));\n    }\n    /**\n     * Deliver webhook payload\n     */\n    async deliver(webhook, payload, attempt = 1) {\n        // Check rate limit\n        if (!this.checkRateLimit(webhook.id)) {\n            loggingService.warn(`Rate limit exceeded for webhook: ${webhook.id}`, 'WebhookService');\n            return;\n        }\n        const deliveryId = this.generateDeliveryId();\n        const delivery = {\n            id: deliveryId,\n            webhookId: webhook.id,\n            event: payload.event,\n            payload,\n            url: webhook.url,\n            status: 'pending',\n            attempt,\n            maxAttempts: webhook.retryCount || 3,\n            sentAt: new Date(),\n        };\n        this.addDelivery(delivery);\n        try {\n            const startTime = performance.now();\n            // Build request\n            const headers = {\n                'Content-Type': 'application/json',\n                'User-Agent': 'MandA-Discovery-Suite/1.0',\n                ...webhook.headers,\n            };\n            // Add signature if secret is configured\n            if (webhook.secret) {\n                headers['X-Webhook-Signature'] = this.generateSignature(payload, webhook.secret);\n            }\n            // Make request\n            const controller = new AbortController();\n            const timeoutId = setTimeout(() => controller.abort(), webhook.timeout || 30000);\n            const response = await fetch(webhook.url, {\n                method: 'POST',\n                headers,\n                body: JSON.stringify(payload),\n                signal: controller.signal,\n            });\n            clearTimeout(timeoutId);\n            const responseTime = performance.now() - startTime;\n            const responseBody = await response.text();\n            // Update delivery\n            delivery.status = response.ok ? 'success' : 'failed';\n            delivery.httpStatus = response.status;\n            delivery.completedAt = new Date();\n            delivery.responseBody = responseBody.substring(0, 1000); // Limit size\n            delivery.responseTime = responseTime;\n            if (!response.ok) {\n                delivery.error = `HTTP ${response.status}: ${response.statusText}`;\n                throw new Error(delivery.error);\n            }\n            loggingService.info(`Webhook delivered successfully: ${webhook.name}`, 'WebhookService', {\n                event: payload.event,\n                responseTime: `${responseTime.toFixed(2)}ms`,\n                status: response.status,\n            });\n        }\n        catch (error) {\n            delivery.status = 'failed';\n            delivery.error = error instanceof Error ? error.message : String(error);\n            delivery.completedAt = new Date();\n            loggingService.error(`Webhook delivery failed: ${webhook.name}`, 'WebhookService', {\n                event: payload.event,\n                attempt,\n                error: error instanceof Error ? error.message : String(error),\n            });\n            // Retry if not max attempts\n            if (attempt < (webhook.retryCount || 3)) {\n                const retryDelay = this.calculateRetryDelay(attempt, webhook.retryDelay || 1000);\n                loggingService.info(`Retrying webhook in ${retryDelay}ms`, 'WebhookService', { attempt: attempt + 1 });\n                await this.sleep(retryDelay);\n                await this.deliver(webhook, payload, attempt + 1);\n            }\n        }\n    }\n    /**\n     * Calculate retry delay with exponential backoff\n     */\n    calculateRetryDelay(attempt, baseDelay) {\n        return baseDelay * Math.pow(2, attempt - 1);\n    }\n    /**\n     * Sleep utility\n     */\n    sleep(ms) {\n        return new Promise((resolve) => setTimeout(resolve, ms));\n    }\n    /**\n     * Check rate limit\n     */\n    checkRateLimit(webhookId) {\n        const now = Date.now();\n        const oneMinuteAgo = now - 60000;\n        // Get timestamps for this webhook\n        const timestamps = this.rateLimitMap.get(webhookId) || [];\n        // Remove timestamps older than 1 minute\n        const recentTimestamps = timestamps.filter((t) => t > oneMinuteAgo);\n        // Check if under limit\n        if (recentTimestamps.length >= this.maxRequestsPerMinute) {\n            return false;\n        }\n        // Add current timestamp\n        recentTimestamps.push(now);\n        this.rateLimitMap.set(webhookId, recentTimestamps);\n        return true;\n    }\n    /**\n     * Generate webhook signature\n     */\n    generateSignature(payload, secret) {\n        // Simple HMAC-like signature (in production, use crypto.subtle)\n        const data = JSON.stringify(payload);\n        const combined = `${secret}.${data}`;\n        // Base64 encode (simplified for demo)\n        return btoa(combined);\n    }\n    /**\n     * Verify webhook signature\n     */\n    verifySignature(payload, signature, secret) {\n        const expectedSignature = this.generateSignature(payload, secret);\n        return signature === expectedSignature;\n    }\n    /**\n     * Test webhook\n     */\n    async test(webhookId) {\n        const webhook = this.webhooks.get(webhookId);\n        if (!webhook) {\n            throw new Error(`Webhook not found: ${webhookId}`);\n        }\n        const testPayload = {\n            event: 'test',\n            timestamp: new Date().toISOString(),\n            data: {\n                message: 'This is a test webhook delivery',\n            },\n            metadata: {\n                test: true,\n            },\n        };\n        await this.deliver(webhook, testPayload);\n        // Return the most recent delivery for this webhook\n        const deliveries = this.getDeliveriesForWebhook(webhookId);\n        return deliveries[deliveries.length - 1];\n    }\n    /**\n     * Generate delivery ID\n     */\n    generateDeliveryId() {\n        return `delivery-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n    }\n    /**\n     * Add delivery to history\n     */\n    addDelivery(delivery) {\n        this.deliveries.push(delivery);\n        // Trim history if needed\n        if (this.deliveries.length > this.maxDeliveryHistory) {\n            this.deliveries.shift();\n        }\n    }\n    /**\n     * Get deliveries for a webhook\n     */\n    getDeliveriesForWebhook(webhookId) {\n        return this.deliveries.filter((d) => d.webhookId === webhookId);\n    }\n    /**\n     * Get all deliveries\n     */\n    getAllDeliveries() {\n        return [...this.deliveries];\n    }\n    /**\n     * Get delivery by ID\n     */\n    getDelivery(deliveryId) {\n        return this.deliveries.find((d) => d.id === deliveryId);\n    }\n    /**\n     * Get webhook statistics\n     */\n    getStats(webhookId) {\n        const deliveries = this.getDeliveriesForWebhook(webhookId);\n        const successful = deliveries.filter((d) => d.status === 'success');\n        const failed = deliveries.filter((d) => d.status === 'failed');\n        const totalResponseTime = successful.reduce((sum, d) => sum + (d.responseTime || 0), 0);\n        const avgResponseTime = successful.length > 0 ? totalResponseTime / successful.length : 0;\n        const lastDelivery = deliveries.length > 0 ? deliveries[deliveries.length - 1].sentAt : undefined;\n        const successRate = deliveries.length > 0 ? successful.length / deliveries.length : 0;\n        return {\n            webhookId,\n            totalDeliveries: deliveries.length,\n            successfulDeliveries: successful.length,\n            failedDeliveries: failed.length,\n            averageResponseTime: avgResponseTime,\n            lastDelivery,\n            successRate,\n        };\n    }\n    /**\n     * Clear delivery history\n     */\n    clearDeliveries() {\n        this.deliveries = [];\n        loggingService.info('Webhook delivery history cleared', 'WebhookService');\n    }\n    /**\n     * Export webhooks as JSON\n     */\n    exportWebhooks() {\n        const webhooks = this.getAllWebhooks();\n        return JSON.stringify(webhooks, null, 2);\n    }\n    /**\n     * Import webhooks from JSON\n     */\n    importWebhooks(json) {\n        try {\n            const webhooks = JSON.parse(json);\n            let imported = 0;\n            for (const webhook of webhooks) {\n                this.register(webhook);\n                imported++;\n            }\n            loggingService.info(`Imported ${imported} webhooks`, 'WebhookService');\n            return imported;\n        }\n        catch (error) {\n            loggingService.error('Failed to import webhooks', 'WebhookService', error);\n            throw error;\n        }\n    }\n    /**\n     * Set rate limit\n     */\n    setRateLimit(requestsPerMinute) {\n        this.maxRequestsPerMinute = requestsPerMinute;\n        loggingService.info(`Webhook rate limit set to ${requestsPerMinute} requests/minute`, 'WebhookService');\n    }\n    /**\n     * Get rate limit\n     */\n    getRateLimit() {\n        return this.maxRequestsPerMinute;\n    }\n}\n/**\n * Export singleton instance\n */\nexport const webhookService = WebhookService.getInstance();\n"],"names":["LogLevel","logs","config","correlationIdStack","performanceMarks","Map","sessionId","userId","constructor","this","minLevel","INFO","maxLogs","transports","enablePerformanceLogging","enableStackTrace","rotationSize","rotationInterval","globalThis","crypto","randomUUID","loadLogs","configure","console","log","setLogLevel","level","setUserId","startCorrelation","id","correlationId","push","endCorrelation","pop","getCurrentCorrelationId","length","trace","message","context","data","TRACE","debug","DEBUG","info","warn","WARN","error","errorData","name","stack","undefined","ERROR","fatal","FATAL","entry","timestamp","Date","levelName","tags","slice","outputToTransports","persistLogs","startPerformanceMeasure","methodName","set","performance","now","endPerformanceMeasure","startTime","get","duration","delete","method","measureAsync","fn","transport","outputToConsole","outputToFile","outputToRemote","toISOString","padEnd","logFn","color","toFixed","window","electronAPI","logToFile","catch","err","getLogs","filterLogs","filter","levels","includes","contexts","endTime","searchText","searchLower","toLowerCase","matchesMessage","matchesContext","matchesData","JSON","stringify","some","tag","searchLogs","query","getLogsByCorrelation","clearLogs","localStorage","removeItem","logsToStore","setItem","stored","getItem","parse","map","exportLogs","format","content","mimeType","extension","row","cell","join","blob","Blob","type","url","URL","createObjectURL","a","document","createElement","href","download","replace","click","revokeObjectURL","count","getStatistics","total","byLevel","l","Set","Boolean","correlations","uniqueContexts","size","uniqueCorrelations","oldestLog","newestLog","WebhookService","static","webhooks","deliveries","maxDeliveryHistory","rateLimitMap","maxRequestsPerMinute","getInstance","instance","register","timeout","retryCount","retryDelay","enabled","events","unregister","webhookId","deleted","getWebhook","getAllWebhooks","Array","from","values","update","updates","webhook","enable","disable","trigger","event","metadata","getWebhooksForEvent","payload","deliveryPromises","deliver","Promise","allSettled","attempt","checkRateLimit","delivery","generateDeliveryId","status","maxAttempts","sentAt","addDelivery","headers","secret","generateSignature","controller","AbortController","timeoutId","setTimeout","abort","response","fetch","body","signal","clearTimeout","responseTime","responseBody","text","ok","httpStatus","completedAt","substring","statusText","Error","String","calculateRetryDelay","sleep","baseDelay","Math","pow","ms","resolve","oneMinuteAgo","recentTimestamps","t","btoa","verifySignature","signature","test","testPayload","getDeliveriesForWebhook","random","toString","substr","shift","d","getAllDeliveries","getDelivery","deliveryId","find","getStats","successful","failed","totalResponseTime","reduce","sum","avgResponseTime","lastDelivery","successRate","totalDeliveries","successfulDeliveries","failedDeliveries","averageResponseTime","clearDeliveries","exportWebhooks","importWebhooks","json","imported","setRateLimit","requestsPerMinute","getRateLimit","webhookService"],"sourceRoot":""}