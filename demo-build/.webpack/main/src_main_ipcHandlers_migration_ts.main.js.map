{"version":3,"file":"src_main_ipcHandlers_migration_ts.main.js","mappings":"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","sources":["webpack://enterprise-discovery-suite/./src/main/ipcHandlers.migration.ts","webpack://enterprise-discovery-suite/./src/main/services/migrationPlanningService.ts"],"sourcesContent":["/**\n * Migration Planning IPC Handlers\n *\n * IPC handlers for migration planning operations including:\n * - Migration plan creation and management\n * - Wave assignment and status updates\n * - User assignment to migration waves\n */\nimport { ipcMain } from 'electron';\nimport { getMigrationPlanningService } from './services/migrationPlanningService';\n/**\n * Register migration planning IPC handlers\n * @param powerShellService - PowerShell execution service instance\n */\nexport function registerMigrationHandlers(powerShellService) {\n    const service = getMigrationPlanningService();\n    // Store PowerShell service for use in handlers\n    let psService = null;\n    if (powerShellService) {\n        psService = powerShellService;\n    }\n    // ========================================\n    // MIGRATION PLAN HANDLERS\n    // ========================================\n    // NOTE: Migration plan handlers (migration-plan:*) have been moved to ipc/migrationPlanningHandlers.ts\n    // to avoid duplicate handler registration. See lines in ipcHandlers.ts where\n    // registerMigrationPlanningHandlers() is called.\n    // ========================================\n    // CONSOLIDATED INVENTORY HANDLERS\n    // ========================================\n    /**\n     * Get list of discovery CSV files for a profile\n     */\n    ipcMain.handle('inventory:get-discovery-files', async (event, profileId) => {\n        try {\n            // Implementation would scan the discovery data directory\n            // For now, return placeholder\n            return { success: true, files: [] };\n        }\n        catch (error) {\n            return { success: false, error: error.message };\n        }\n    });\n    /**\n     * Read discovery CSV file content\n     */\n    ipcMain.handle('inventory:read-discovery-file', async (event, filePath) => {\n        try {\n            // Implementation would read and parse CSV file\n            // For now, return placeholder\n            return { success: true, content: '' };\n        }\n        catch (error) {\n            return { success: false, error: error.message };\n        }\n    });\n    // NOTE: inventory:rebuild and inventory:get-stats handlers have been moved to ipcHandlers.inventory.ts\n    // ========================================\n    // MIGRATION WAVE HANDLERS (Enhanced)\n    // ========================================\n    /**\n     * Create migration wave\n     */\n    ipcMain.handle('migration:create-wave', async (event, waveData) => {\n        try {\n            console.log(`[IPC] Create wave: ${waveData.name}`);\n            // Wave creation handled by MigrationService in renderer\n            return { success: true, wave: waveData };\n        }\n        catch (error) {\n            return { success: false, error: error.message };\n        }\n    });\n    /**\n     * Get migration waves\n     */\n    ipcMain.handle('migration:get-waves', async (event, filters) => {\n        try {\n            console.log(`[IPC] Get waves with filters:`, filters);\n            // Waves managed by MigrationService in renderer\n            return { success: true, waves: [] };\n        }\n        catch (error) {\n            return { success: false, error: error.message };\n        }\n    });\n    /**\n     * Assign entities to wave\n     */\n    ipcMain.handle('migration:assign-entities-to-wave', async (event, waveId, entityIds, reason) => {\n        try {\n            console.log(`[IPC] Assign ${entityIds.length} entities to wave ${waveId}`);\n            // Assignment handled by MigrationService in renderer\n            return { success: true };\n        }\n        catch (error) {\n            return { success: false, error: error.message };\n        }\n    });\n    /**\n     * Get wave summary\n     */\n    ipcMain.handle('migration:get-wave-summary', async (event, waveId) => {\n        try {\n            console.log(`[IPC] Get wave summary for: ${waveId}`);\n            // Summary calculated by MigrationService in renderer\n            return { success: true, summary: null };\n        }\n        catch (error) {\n            return { success: false, error: error.message };\n        }\n    });\n    /**\n     * Auto-suggest wave assignments\n     */\n    ipcMain.handle('migration:suggest-wave-assignments', async (event, sourceProfileId, targetProfileId) => {\n        try {\n            console.log(`[IPC] Suggest wave assignments: ${sourceProfileId} â†’ ${targetProfileId}`);\n            // Suggestions generated by MigrationService in renderer\n            return { success: true, suggestions: {} };\n        }\n        catch (error) {\n            return { success: false, error: error.message };\n        }\n    });\n    console.log('Migration planning and consolidated inventory IPC handlers registered');\n}\n","/**\n * Migration Planning Service\n *\n * Handles migration wave planning, user assignment, and execution scheduling.\n * Pattern from GUI/Services/MigrationPlanningService.cs\n */\nimport * as fs from 'fs';\nimport * as path from 'path';\n/**\n * Migration Planning Service\n */\nexport class MigrationPlanningService {\n    plansDir;\n    plans = new Map();\n    constructor(dataRoot = 'C:\\\\DiscoveryData') {\n        this.plansDir = path.join(dataRoot, 'MigrationPlans');\n        this.ensureDirectoryExists();\n    }\n    /**\n     * Ensure migration plans directory exists\n     */\n    ensureDirectoryExists() {\n        if (!fs.existsSync(this.plansDir)) {\n            fs.mkdirSync(this.plansDir, { recursive: true });\n        }\n    }\n    /**\n     * Create a new migration plan\n     */\n    async createPlan(planData) {\n        const plan = {\n            id: crypto.randomUUID(),\n            ...planData,\n            waves: [],\n            created: new Date().toISOString(),\n            modified: new Date().toISOString()\n        };\n        this.plans.set(plan.id, plan);\n        await this.savePlan(plan);\n        return plan;\n    }\n    /**\n     * Add a wave to a migration plan\n     */\n    async addWave(planId, waveData) {\n        const plan = this.plans.get(planId);\n        if (!plan) {\n            throw new Error(`Migration plan not found: ${planId}`);\n        }\n        const wave = {\n            id: crypto.randomUUID(),\n            ...waveData,\n            status: 'planned',\n            users: [],\n            priority: waveData.priority || 1,\n            dependencies: waveData.dependencies || [],\n            created: new Date().toISOString(),\n            modified: new Date().toISOString()\n        };\n        plan.waves.push(wave);\n        plan.modified = new Date().toISOString();\n        await this.savePlan(plan);\n        return wave;\n    }\n    /**\n     * Assign users to a wave\n     */\n    async assignUsersToWave(planId, waveId, userIds) {\n        const plan = this.plans.get(planId);\n        if (!plan) {\n            throw new Error(`Migration plan not found: ${planId}`);\n        }\n        const wave = plan.waves.find(w => w.id === waveId);\n        if (!wave) {\n            throw new Error(`Wave not found: ${waveId}`);\n        }\n        // Add unique users only\n        const existingUsers = new Set(wave.users);\n        userIds.forEach(userId => existingUsers.add(userId));\n        wave.users = Array.from(existingUsers);\n        wave.modified = new Date().toISOString();\n        plan.modified = new Date().toISOString();\n        await this.savePlan(plan);\n    }\n    /**\n     * Update wave status\n     */\n    async updateWaveStatus(planId, waveId, status) {\n        const plan = this.plans.get(planId);\n        if (!plan) {\n            throw new Error(`Migration plan not found: ${planId}`);\n        }\n        const wave = plan.waves.find(w => w.id === waveId);\n        if (!wave) {\n            throw new Error(`Wave not found: ${waveId}`);\n        }\n        wave.status = status;\n        wave.modified = new Date().toISOString();\n        plan.modified = new Date().toISOString();\n        await this.savePlan(plan);\n    }\n    /**\n     * Get migration plan\n     */\n    async getPlan(planId) {\n        if (this.plans.has(planId)) {\n            const plan = this.plans.get(planId);\n            return plan || null;\n        }\n        // Try to load from disk\n        const planPath = path.join(this.plansDir, `${planId}.json`);\n        if (fs.existsSync(planPath)) {\n            const content = await fs.promises.readFile(planPath, 'utf8');\n            const plan = JSON.parse(content);\n            this.plans.set(plan.id, plan);\n            return plan;\n        }\n        return null;\n    }\n    /**\n     * Get all migration plans for a profile\n     */\n    async getPlansByProfile(profileName) {\n        await this.loadAllPlans();\n        return Array.from(this.plans.values()).filter(p => p.profileName === profileName);\n    }\n    /**\n     * Delete migration plan\n     */\n    async deletePlan(planId) {\n        this.plans.delete(planId);\n        const planPath = path.join(this.plansDir, `${planId}.json`);\n        if (fs.existsSync(planPath)) {\n            await fs.promises.unlink(planPath);\n        }\n    }\n    /**\n     * Save migration plan to disk\n     */\n    async savePlan(plan) {\n        const planPath = path.join(this.plansDir, `${plan.id}.json`);\n        await fs.promises.writeFile(planPath, JSON.stringify(plan, null, 2), 'utf8');\n    }\n    /**\n     * Load all migration plans from disk\n     */\n    async loadAllPlans() {\n        if (!fs.existsSync(this.plansDir)) {\n            return;\n        }\n        const files = await fs.promises.readdir(this.plansDir);\n        const jsonFiles = files.filter(f => f.endsWith('.json'));\n        for (const file of jsonFiles) {\n            try {\n                const content = await fs.promises.readFile(path.join(this.plansDir, file), 'utf8');\n                const plan = JSON.parse(content);\n                this.plans.set(plan.id, plan);\n            }\n            catch (error) {\n                console.error(`Failed to load migration plan ${file}:`, error);\n            }\n        }\n    }\n    /**\n     * Get statistics\n     */\n    getStatistics() {\n        const allWaves = Array.from(this.plans.values()).flatMap(p => p.waves);\n        return {\n            totalPlans: this.plans.size,\n            totalWaves: allWaves.length,\n            wavesByStatus: {\n                planned: allWaves.filter(w => w.status === 'planned').length,\n                inprogress: allWaves.filter(w => w.status === 'inprogress').length,\n                completed: allWaves.filter(w => w.status === 'completed').length,\n                failed: allWaves.filter(w => w.status === 'failed').length\n            },\n            totalUsersAssigned: Array.from(new Set(allWaves.flatMap(w => w.users))).length\n        };\n    }\n}\n// Singleton instance\nlet migrationPlanningService = null;\nexport function getMigrationPlanningService(dataRoot) {\n    if (!migrationPlanningService) {\n        migrationPlanningService = new MigrationPlanningService(dataRoot);\n    }\n    return migrationPlanningService;\n}\nexport default MigrationPlanningService;\n"],"names":["registerMigrationHandlers","powerShellService","getMigrationPlanningService","psService","ipcMain","handle","async","event","profileId","success","files","error","message","filePath","content","waveData","console","log","name","wave","filters","waves","waveId","entityIds","reason","length","summary","sourceProfileId","targetProfileId","suggestions","MigrationPlanningService","plansDir","plans","Map","constructor","dataRoot","this","ensureDirectoryExists","recursive","createPlan","planData","plan","id","crypto","randomUUID","created","Date","toISOString","modified","set","savePlan","addWave","planId","get","Error","status","users","priority","dependencies","push","assignUsersToWave","userIds","find","w","existingUsers","Set","forEach","userId","add","Array","from","updateWaveStatus","getPlan","has","planPath","readFile","JSON","parse","getPlansByProfile","profileName","loadAllPlans","values","filter","p","deletePlan","delete","unlink","writeFile","stringify","jsonFiles","readdir","f","endsWith","file","getStatistics","allWaves","flatMap","totalPlans","size","totalWaves","wavesByStatus","planned","inprogress","completed","failed","totalUsersAssigned","migrationPlanningService"],"sourceRoot":""}