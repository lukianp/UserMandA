{"version":3,"file":"src_main_services_enterpriseSystemsService_ts.main.js","mappings":"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","sources":["webpack://enterprise-discovery-suite/./src/main/services/enterpriseSystemsService.ts"],"sourcesContent":["/**\n * Enterprise Systems Service\n *\n * Backend service for connecting to and extracting data from enterprise systems:\n * - ServiceNow (ITSM, CMDB)\n * - Jira/Atlassian\n * - Workday (HCM)\n * - LeanIX (Enterprise Architecture)\n *\n * Phase 10: Enterprise Systems Integration\n */\nimport { ipcMain } from 'electron';\nimport * as https from 'https';\nimport * as fs from 'fs';\nimport * as path from 'path';\n// ===== SERVICENOW API =====\nclass ServiceNowClient {\n    config;\n    accessToken = null;\n    constructor(config) {\n        this.config = config;\n    }\n    async getAuthHeader() {\n        if (this.config.useOAuth && this.config.clientId && this.config.clientSecret) {\n            // OAuth flow\n            if (!this.accessToken) {\n                this.accessToken = await this.getOAuthToken();\n            }\n            return `Bearer ${this.accessToken}`;\n        }\n        else {\n            // Basic auth\n            const credentials = Buffer.from(`${this.config.username}:${this.config.password}`).toString('base64');\n            return `Basic ${credentials}`;\n        }\n    }\n    async getOAuthToken() {\n        return new Promise((resolve, reject) => {\n            const tokenUrl = new URL('/oauth_token.do', this.config.instanceUrl);\n            const postData = new URLSearchParams({\n                grant_type: 'password',\n                client_id: this.config.clientId,\n                client_secret: this.config.clientSecret,\n                username: this.config.username,\n                password: this.config.password,\n            }).toString();\n            const options = {\n                hostname: tokenUrl.hostname,\n                path: tokenUrl.pathname,\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded',\n                    'Content-Length': Buffer.byteLength(postData),\n                },\n            };\n            const req = https.request(options, (res) => {\n                let data = '';\n                res.on('data', (chunk) => (data += chunk));\n                res.on('end', () => {\n                    try {\n                        const response = JSON.parse(data);\n                        if (response.access_token) {\n                            resolve(response.access_token);\n                        }\n                        else {\n                            reject(new Error(response.error_description || 'OAuth failed'));\n                        }\n                    }\n                    catch (err) {\n                        reject(err);\n                    }\n                });\n            });\n            req.on('error', reject);\n            req.write(postData);\n            req.end();\n        });\n    }\n    async testConnection() {\n        try {\n            const authHeader = await this.getAuthHeader();\n            const url = new URL('/api/now/table/sys_user?sysparm_limit=1', this.config.instanceUrl);\n            return new Promise((resolve) => {\n                const req = https.request({\n                    hostname: url.hostname,\n                    path: url.pathname + url.search,\n                    method: 'GET',\n                    headers: {\n                        Authorization: authHeader,\n                        Accept: 'application/json',\n                    },\n                }, (res) => {\n                    if (res.statusCode === 200) {\n                        resolve({ success: true });\n                    }\n                    else {\n                        resolve({ success: false, error: `HTTP ${res.statusCode}` });\n                    }\n                });\n                req.on('error', (err) => resolve({ success: false, error: err.message }));\n                req.end();\n            });\n        }\n        catch (err) {\n            return { success: false, error: err.message };\n        }\n    }\n    async extractData(dataType) {\n        const tableMap = {\n            cmdb: 'cmdb_ci',\n            incidents: 'incident',\n            users: 'sys_user',\n            requests: 'sc_request',\n            changes: 'change_request',\n        };\n        const table = tableMap[dataType];\n        if (!table) {\n            return { success: false, error: `Unknown data type: ${dataType}` };\n        }\n        try {\n            const authHeader = await this.getAuthHeader();\n            const allRecords = [];\n            let offset = 0;\n            const limit = 1000;\n            let hasMore = true;\n            while (hasMore) {\n                const url = new URL(`/api/now/table/${table}?sysparm_limit=${limit}&sysparm_offset=${offset}`, this.config.instanceUrl);\n                const records = await new Promise((resolve, reject) => {\n                    const req = https.request({\n                        hostname: url.hostname,\n                        path: url.pathname + url.search,\n                        method: 'GET',\n                        headers: {\n                            Authorization: authHeader,\n                            Accept: 'application/json',\n                        },\n                    }, (res) => {\n                        let data = '';\n                        res.on('data', (chunk) => (data += chunk));\n                        res.on('end', () => {\n                            try {\n                                const response = JSON.parse(data);\n                                resolve(response.result || []);\n                            }\n                            catch (err) {\n                                reject(err);\n                            }\n                        });\n                    });\n                    req.on('error', reject);\n                    req.end();\n                });\n                allRecords.push(...records);\n                hasMore = records.length === limit;\n                offset += limit;\n            }\n            return { success: true, data: allRecords, recordCount: allRecords.length };\n        }\n        catch (err) {\n            return { success: false, error: err.message };\n        }\n    }\n}\n// ===== JIRA API =====\nclass JiraClient {\n    config;\n    constructor(config) {\n        this.config = config;\n    }\n    getAuthHeader() {\n        const credentials = Buffer.from(`${this.config.email}:${this.config.apiToken}`).toString('base64');\n        return `Basic ${credentials}`;\n    }\n    async testConnection() {\n        try {\n            const url = new URL('/rest/api/3/myself', this.config.baseUrl);\n            return new Promise((resolve) => {\n                const req = https.request({\n                    hostname: url.hostname,\n                    path: url.pathname,\n                    method: 'GET',\n                    headers: {\n                        Authorization: this.getAuthHeader(),\n                        Accept: 'application/json',\n                    },\n                }, (res) => {\n                    if (res.statusCode === 200) {\n                        resolve({ success: true });\n                    }\n                    else {\n                        resolve({ success: false, error: `HTTP ${res.statusCode}` });\n                    }\n                });\n                req.on('error', (err) => resolve({ success: false, error: err.message }));\n                req.end();\n            });\n        }\n        catch (err) {\n            return { success: false, error: err.message };\n        }\n    }\n    async extractData(dataType) {\n        const endpoints = {\n            projects: '/rest/api/3/project',\n            issues: '/rest/api/3/search?maxResults=1000',\n            users: '/rest/api/3/users/search?maxResults=1000',\n            boards: '/rest/agile/1.0/board',\n        };\n        const endpoint = endpoints[dataType];\n        if (!endpoint) {\n            return { success: false, error: `Unknown data type: ${dataType}` };\n        }\n        try {\n            const url = new URL(endpoint, this.config.baseUrl);\n            const data = await new Promise((resolve, reject) => {\n                const req = https.request({\n                    hostname: url.hostname,\n                    path: url.pathname + url.search,\n                    method: 'GET',\n                    headers: {\n                        Authorization: this.getAuthHeader(),\n                        Accept: 'application/json',\n                    },\n                }, (res) => {\n                    let data = '';\n                    res.on('data', (chunk) => (data += chunk));\n                    res.on('end', () => {\n                        try {\n                            resolve(JSON.parse(data));\n                        }\n                        catch (err) {\n                            reject(err);\n                        }\n                    });\n                });\n                req.on('error', reject);\n                req.end();\n            });\n            // Normalize response based on data type\n            const records = dataType === 'issues' ? data.issues : Array.isArray(data) ? data : data.values || [];\n            return { success: true, data: records, recordCount: records.length };\n        }\n        catch (err) {\n            return { success: false, error: err.message };\n        }\n    }\n}\n// ===== WORKDAY API =====\nclass WorkdayClient {\n    config;\n    accessToken = null;\n    constructor(config) {\n        this.config = config;\n    }\n    async testConnection() {\n        // Workday requires OAuth2 - simplified test\n        try {\n            if (!this.config.clientId || !this.config.clientSecret) {\n                return { success: false, error: 'OAuth credentials required for Workday' };\n            }\n            // Note: Actual Workday implementation requires proper OAuth2 flow\n            // This is a placeholder that would need to be customized per tenant\n            return { success: true, details: 'Workday connection test (placeholder)' };\n        }\n        catch (err) {\n            return { success: false, error: err.message };\n        }\n    }\n    async extractData(dataType) {\n        // Workday uses SOAP/REST APIs with complex authentication\n        // This is a placeholder structure\n        const dataTypeEndpoints = {\n            employees: '/ccx/service/tenant/Human_Resources/v40.0/Get_Workers',\n            costCenters: '/ccx/service/tenant/Financial_Management/v40.0/Get_Cost_Centers',\n            organizations: '/ccx/service/tenant/Human_Resources/v40.0/Get_Organizations',\n            positions: '/ccx/service/tenant/Human_Resources/v40.0/Get_Positions',\n        };\n        if (!dataTypeEndpoints[dataType]) {\n            return { success: false, error: `Unknown data type: ${dataType}` };\n        }\n        // Placeholder - actual implementation requires SOAP/REST calls with proper auth\n        return {\n            success: true,\n            data: [],\n            recordCount: 0,\n            error: 'Workday extraction requires custom implementation per tenant',\n        };\n    }\n}\n// ===== LEANIX API =====\nclass LeanIXClient {\n    config;\n    accessToken = null;\n    constructor(config) {\n        this.config = config;\n    }\n    async getAccessToken() {\n        if (this.accessToken)\n            return this.accessToken;\n        return new Promise((resolve, reject) => {\n            const url = new URL('/services/mtm/v1/oauth2/token', this.config.instanceUrl);\n            const postData = new URLSearchParams({\n                grant_type: 'client_credentials',\n            }).toString();\n            const req = https.request({\n                hostname: url.hostname,\n                path: url.pathname,\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded',\n                    Authorization: `Basic ${Buffer.from(`apitoken:${this.config.apiToken}`).toString('base64')}`,\n                },\n            }, (res) => {\n                let data = '';\n                res.on('data', (chunk) => (data += chunk));\n                res.on('end', () => {\n                    try {\n                        const response = JSON.parse(data);\n                        if (response.access_token) {\n                            this.accessToken = response.access_token;\n                            resolve(response.access_token);\n                        }\n                        else {\n                            reject(new Error('Failed to get LeanIX access token'));\n                        }\n                    }\n                    catch (err) {\n                        reject(err);\n                    }\n                });\n            });\n            req.on('error', reject);\n            req.write(postData);\n            req.end();\n        });\n    }\n    async testConnection() {\n        try {\n            const token = await this.getAccessToken();\n            return { success: true, details: { tokenObtained: !!token } };\n        }\n        catch (err) {\n            return { success: false, error: err.message };\n        }\n    }\n    async extractData(factSheetType) {\n        try {\n            const token = await this.getAccessToken();\n            const graphqlQuery = {\n                query: `\r\n          query {\r\n            allFactSheets(filter: {factSheetType: ${factSheetType}}) {\r\n              edges {\r\n                node {\r\n                  id\r\n                  name\r\n                  type\r\n                  description\r\n                  ... on ${factSheetType} {\r\n                    lifecycle {\r\n                      asString\r\n                    }\r\n                    businessCriticality\r\n                    technicalFit\r\n                    functionalFit\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        `,\n            };\n            const url = new URL('/services/pathfinder/v1/graphql', this.config.instanceUrl);\n            const data = await new Promise((resolve, reject) => {\n                const postData = JSON.stringify(graphqlQuery);\n                const req = https.request({\n                    hostname: url.hostname,\n                    path: url.pathname,\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                        Authorization: `Bearer ${token}`,\n                        'Content-Length': Buffer.byteLength(postData),\n                    },\n                }, (res) => {\n                    let data = '';\n                    res.on('data', (chunk) => (data += chunk));\n                    res.on('end', () => {\n                        try {\n                            resolve(JSON.parse(data));\n                        }\n                        catch (err) {\n                            reject(err);\n                        }\n                    });\n                });\n                req.on('error', reject);\n                req.write(postData);\n                req.end();\n            });\n            const factSheets = data?.data?.allFactSheets?.edges?.map((e) => e.node) || [];\n            return { success: true, data: factSheets, recordCount: factSheets.length };\n        }\n        catch (err) {\n            return { success: false, error: err.message };\n        }\n    }\n}\n// ===== IPC HANDLERS =====\nexport function registerEnterpriseSystemsHandlers() {\n    // Test connection handler\n    ipcMain.handle('enterprise-test-connection', async (_event, args) => {\n        const { system, config } = args;\n        switch (system) {\n            case 'serviceNow': {\n                const client = new ServiceNowClient(config);\n                return await client.testConnection();\n            }\n            case 'jira': {\n                const client = new JiraClient(config);\n                return await client.testConnection();\n            }\n            case 'workday': {\n                const client = new WorkdayClient(config);\n                return await client.testConnection();\n            }\n            case 'leanIX': {\n                const client = new LeanIXClient(config);\n                return await client.testConnection();\n            }\n            default:\n                return { success: false, error: `Unknown system: ${system}` };\n        }\n    });\n    // Data extraction handler\n    ipcMain.handle('enterprise-extract-data', async (_event, args) => {\n        const { system, config, dataType, companyName } = args;\n        let result;\n        switch (system) {\n            case 'serviceNow': {\n                const client = new ServiceNowClient(config);\n                result = await client.extractData(dataType);\n                break;\n            }\n            case 'jira': {\n                const client = new JiraClient(config);\n                result = await client.extractData(dataType);\n                break;\n            }\n            case 'workday': {\n                const client = new WorkdayClient(config);\n                result = await client.extractData(dataType);\n                break;\n            }\n            case 'leanIX': {\n                const client = new LeanIXClient(config);\n                result = await client.extractData(dataType);\n                break;\n            }\n            default:\n                result = { success: false, error: `Unknown system: ${system}` };\n        }\n        // Save to discovery data if successful\n        if (result.success && result.data && result.data.length > 0 && companyName) {\n            try {\n                const discoveryDataPath = path.join(process.env.DISCOVERY_DATA_PATH || 'C:\\\\DiscoveryData', companyName, 'Raw');\n                if (!fs.existsSync(discoveryDataPath)) {\n                    fs.mkdirSync(discoveryDataPath, { recursive: true });\n                }\n                const filename = `${system}_${dataType}.csv`;\n                const filePath = path.join(discoveryDataPath, filename);\n                // Convert to CSV\n                if (result.data.length > 0) {\n                    const headers = Object.keys(result.data[0]);\n                    const csvContent = [\n                        headers.join(','),\n                        ...result.data.map((row) => headers.map((h) => {\n                            const value = row[h];\n                            if (value === null || value === undefined)\n                                return '';\n                            const str = String(value);\n                            if (str.includes(',') || str.includes('\"') || str.includes('\\n')) {\n                                return `\"${str.replace(/\"/g, '\"\"')}\"`;\n                            }\n                            return str;\n                        }).join(',')),\n                    ].join('\\n');\n                    fs.writeFileSync(filePath, csvContent, 'utf8');\n                }\n            }\n            catch (err) {\n                console.error('Failed to save enterprise data to CSV:', err);\n            }\n        }\n        return result;\n    });\n    console.log('[EnterpriseSystemsService] IPC handlers registered');\n}\nexport default { registerEnterpriseSystemsHandlers };\n"],"names":["ServiceNowClient","config","accessToken","constructor","this","getAuthHeader","useOAuth","clientId","clientSecret","getOAuthToken","Buffer","from","username","password","toString","Promise","resolve","reject","tokenUrl","URL","instanceUrl","postData","URLSearchParams","grant_type","client_id","client_secret","options","hostname","path","pathname","method","headers","byteLength","req","res","data","on","chunk","response","JSON","parse","access_token","Error","error_description","err","write","end","testConnection","authHeader","url","search","Authorization","Accept","statusCode","success","error","message","extractData","dataType","table","cmdb","incidents","users","requests","changes","allRecords","offset","limit","hasMore","records","result","push","length","recordCount","JiraClient","email","apiToken","baseUrl","endpoint","projects","issues","boards","Array","isArray","values","WorkdayClient","details","employees","costCenters","organizations","positions","LeanIXClient","getAccessToken","tokenObtained","factSheetType","token","graphqlQuery","query","stringify","factSheets","allFactSheets","edges","map","e","node","registerEnterpriseSystemsHandlers","ipcMain","handle","async","_event","args","system","client","companyName","discoveryDataPath","process","env","DISCOVERY_DATA_PATH","recursive","filename","filePath","Object","keys","csvContent","join","row","h","value","str","String","includes","replace","console","log"],"sourceRoot":""}