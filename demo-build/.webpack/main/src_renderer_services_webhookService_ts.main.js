"use strict";exports.id="src_renderer_services_webhookService_ts",exports.ids=["src_renderer_services_webhookService_ts"],exports.modules={"./src/renderer/services/loggingService.ts":(e,t,s)=>{var o;s.d(t,{default:()=>r}),function(e){e[e.TRACE=0]="TRACE",e[e.DEBUG=1]="DEBUG",e[e.INFO=2]="INFO",e[e.WARN=3]="WARN",e[e.ERROR=4]="ERROR",e[e.FATAL=5]="FATAL"}(o||(o={}));const r=new class{logs=[];config;correlationIdStack=[];performanceMarks=new Map;sessionId;userId;constructor(){this.config={minLevel:o.INFO,maxLogs:1e4,transports:["console"],enablePerformanceLogging:!0,enableStackTrace:!0,rotationSize:10485760,rotationInterval:864e5},this.sessionId=globalThis.crypto.randomUUID(),this.loadLogs()}configure(e){this.config={...this.config,...e},console.log("Logging service configured:",this.config)}setLogLevel(e){this.config.minLevel=e}setUserId(e){this.userId=e}startCorrelation(e){const t=e||globalThis.crypto.randomUUID();return this.correlationIdStack.push(t),t}endCorrelation(){this.correlationIdStack.pop()}getCurrentCorrelationId(){return this.correlationIdStack[this.correlationIdStack.length-1]}trace(e,t,s){this.log(o.TRACE,e,t,s)}debug(e,t,s){this.log(o.DEBUG,e,t,s)}info(e,t,s){this.log(o.INFO,e,t,s)}warn(e,t,s){this.log(o.WARN,e,t,s)}error(e,t,s,r){const i=r&&this.config.enableStackTrace?{name:r.name,message:r.message,stack:r.stack}:void 0;this.log(o.ERROR,e,t,s,i)}fatal(e,t,s,r){const i=r&&this.config.enableStackTrace?{name:r.name,message:r.message,stack:r.stack}:void 0;this.log(o.FATAL,e,t,s,i)}log(e,t,s,r,i){if(e<this.config.minLevel)return;const n={id:globalThis.crypto.randomUUID(),timestamp:new Date,level:e,levelName:o[e],message:t,context:s,correlationId:this.getCurrentCorrelationId(),data:r,error:i,tags:[],userId:this.userId,sessionId:this.sessionId};this.logs.push(n),this.logs.length>this.config.maxLogs&&(this.logs=this.logs.slice(-this.config.maxLogs)),this.outputToTransports(n),this.logs.length%10==0&&this.persistLogs()}startPerformanceMeasure(e){this.config.enablePerformanceLogging&&this.performanceMarks.set(e,performance.now())}endPerformanceMeasure(e,t){if(!this.config.enablePerformanceLogging)return null;const s=this.performanceMarks.get(e);if(!s)return this.warn(`No performance mark found for ${e}`,"Performance"),null;const r=performance.now()-s;this.performanceMarks.delete(e);const i={id:globalThis.crypto.randomUUID(),timestamp:new Date,level:o.DEBUG,levelName:"DEBUG",message:`Performance: ${e}`,context:t||"Performance",correlationId:this.getCurrentCorrelationId(),performance:{duration:r,method:e},sessionId:this.sessionId,userId:this.userId};return this.logs.push(i),this.outputToTransports(i),r}async measureAsync(e,t,s){this.startPerformanceMeasure(e);try{return await t()}finally{this.endPerformanceMeasure(e,s)}}outputToTransports(e){for(const t of this.config.transports)switch(t){case"console":this.outputToConsole(e);break;case"file":this.outputToFile(e);break;case"remote":this.outputToRemote(e)}}outputToConsole(e){const t=e.timestamp.toISOString(),s=e.levelName.padEnd(5),r=e.context?`[${e.context}]`:"",i=e.correlationId?`[${e.correlationId.slice(0,8)}]`:"";let n=console.log,a="";switch(e.level){case o.TRACE:n=console.debug,a="[90m";break;case o.DEBUG:n=console.debug,a="[36m";break;case o.INFO:n=console.info,a="[32m";break;case o.WARN:n=console.warn,a="[33m";break;case o.ERROR:n=console.error,a="[31m";break;case o.FATAL:n=console.error,a="[35m"}n(`${a}${t} ${s}[0m ${r}${i} ${e.message}`),e.data&&console.log("  Data:",e.data),e.error&&(console.error("  Error:",e.error.message),e.error.stack&&console.error(e.error.stack)),e.performance&&console.log(`  Duration: ${e.performance.duration.toFixed(2)}ms`)}outputToFile(e){window.electronAPI?.logToFile&&window.electronAPI.logToFile(e).catch(e=>{console.error("Failed to write log to file:",e)})}outputToRemote(e){}getLogs(){return[...this.logs]}filterLogs(e){return this.logs.filter(t=>{if(e.levels&&!e.levels.includes(t.level))return!1;if(e.contexts&&t.context&&!e.contexts.includes(t.context))return!1;if(e.correlationId&&t.correlationId!==e.correlationId)return!1;if(e.startTime&&t.timestamp<e.startTime)return!1;if(e.endTime&&t.timestamp>e.endTime)return!1;if(e.searchText){const s=e.searchText.toLowerCase(),o=t.message.toLowerCase().includes(s),r=t.context?.toLowerCase().includes(s),i=JSON.stringify(t.data||{}).toLowerCase().includes(s);if(!o&&!r&&!i)return!1}if(e.tags&&t.tags){if(!e.tags.some(e=>t.tags.includes(e)))return!1}return!0})}searchLogs(e){return this.filterLogs({searchText:e})}getLogsByCorrelation(e){return this.filterLogs({correlationId:e})}clearLogs(){this.logs=[],localStorage.removeItem("app_logs"),console.log("All logs cleared")}persistLogs(){try{const e=this.logs.slice(-1e3);localStorage.setItem("app_logs",JSON.stringify(e))}catch(e){console.error("Failed to persist logs:",e)}}loadLogs(){try{const e=localStorage.getItem("app_logs");if(e){const t=JSON.parse(e);this.logs=t.map(e=>({...e,timestamp:new Date(e.timestamp)})),console.log(`Loaded ${this.logs.length} persisted logs`)}}catch(e){console.error("Failed to load persisted logs:",e)}}exportLogs(e="json"){let t,s,o;if("json"===e)t=JSON.stringify(this.logs,null,2),s="application/json",o="json";else{t=[["timestamp","level","context","correlationId","message","data"],...this.logs.map(e=>[e.timestamp.toISOString(),e.levelName,e.context||"",e.correlationId||"",e.message,JSON.stringify(e.data||{})])].map(e=>e.map(e=>`"${e}"`).join(",")).join("\n"),s="text/csv",o="csv"}const r=new Blob([t],{type:s}),i=URL.createObjectURL(r),n=document.createElement("a");n.href=i,n.download=`logs_${(new Date).toISOString().replace(/[:.]/g,"-")}.${o}`,n.click(),URL.revokeObjectURL(i),this.info("Logs exported","LoggingService",{format:e,count:this.logs.length})}getStatistics(){const e=this.logs.length,t={};for(let e=o.TRACE;e<=o.FATAL;e++)t[o[e]]=this.logs.filter(t=>t.level===e).length;const s=new Set(this.logs.map(e=>e.context).filter(Boolean)),r=new Set(this.logs.map(e=>e.correlationId).filter(Boolean));return{total:e,byLevel:t,uniqueContexts:s.size,uniqueCorrelations:r.size,sessionId:this.sessionId,userId:this.userId,oldestLog:this.logs[0]?.timestamp,newestLog:this.logs[this.logs.length-1]?.timestamp}}}},"./src/renderer/services/webhookService.ts":(e,t,s)=>{s.d(t,{webhookService:()=>i});var o=s("./src/renderer/services/loggingService.ts");class r{static instance;webhooks=new Map;deliveries=[];maxDeliveryHistory=1e3;rateLimitMap=new Map;maxRequestsPerMinute=60;constructor(){o.default.debug("WebhookService instance created","WebhookService")}static getInstance(){return r.instance||(r.instance=new r),r.instance}register(e){this.webhooks.set(e.id,{timeout:3e4,retryCount:3,retryDelay:1e3,...e,enabled:e.enabled??!0}),o.default.info(`Webhook registered: ${e.name}`,"WebhookService",{id:e.id,url:e.url,events:e.events})}unregister(e){const t=this.webhooks.delete(e);return t&&o.default.info(`Webhook unregistered: ${e}`,"WebhookService"),t}getWebhook(e){return this.webhooks.get(e)}getAllWebhooks(){return Array.from(this.webhooks.values())}update(e,t){const s=this.webhooks.get(e);return!!s&&(this.webhooks.set(e,{...s,...t,id:e}),o.default.info(`Webhook updated: ${e}`,"WebhookService"),!0)}enable(e){return this.update(e,{enabled:!0})}disable(e){return this.update(e,{enabled:!1})}async trigger(e,t,s){const r=this.getWebhooksForEvent(e);if(0===r.length)return void o.default.debug(`No webhooks registered for event: ${e}`,"WebhookService");const i={event:e,timestamp:(new Date).toISOString(),data:t,metadata:s},n=r.map(e=>this.deliver(e,i));await Promise.allSettled(n)}getWebhooksForEvent(e){return Array.from(this.webhooks.values()).filter(t=>t.enabled&&(t.events.includes(e)||t.events.includes("*")))}async deliver(e,t,s=1){if(!this.checkRateLimit(e.id))return void o.default.warn(`Rate limit exceeded for webhook: ${e.id}`,"WebhookService");const r={id:this.generateDeliveryId(),webhookId:e.id,event:t.event,payload:t,url:e.url,status:"pending",attempt:s,maxAttempts:e.retryCount||3,sentAt:new Date};this.addDelivery(r);try{const s=performance.now(),i={"Content-Type":"application/json","User-Agent":"MandA-Discovery-Suite/1.0",...e.headers};e.secret&&(i["X-Webhook-Signature"]=this.generateSignature(t,e.secret));const n=new AbortController,a=setTimeout(()=>n.abort(),e.timeout||3e4),l=await fetch(e.url,{method:"POST",headers:i,body:JSON.stringify(t),signal:n.signal});clearTimeout(a);const c=performance.now()-s,g=await l.text();if(r.status=l.ok?"success":"failed",r.httpStatus=l.status,r.completedAt=new Date,r.responseBody=g.substring(0,1e3),r.responseTime=c,!l.ok)throw r.error=`HTTP ${l.status}: ${l.statusText}`,new Error(r.error);o.default.info(`Webhook delivered successfully: ${e.name}`,"WebhookService",{event:t.event,responseTime:`${c.toFixed(2)}ms`,status:l.status})}catch(i){if(r.status="failed",r.error=i instanceof Error?i.message:String(i),r.completedAt=new Date,o.default.error(`Webhook delivery failed: ${e.name}`,"WebhookService",{event:t.event,attempt:s,error:i instanceof Error?i.message:String(i)}),s<(e.retryCount||3)){const r=this.calculateRetryDelay(s,e.retryDelay||1e3);o.default.info(`Retrying webhook in ${r}ms`,"WebhookService",{attempt:s+1}),await this.sleep(r),await this.deliver(e,t,s+1)}}}calculateRetryDelay(e,t){return t*Math.pow(2,e-1)}sleep(e){return new Promise(t=>setTimeout(t,e))}checkRateLimit(e){const t=Date.now(),s=t-6e4,o=(this.rateLimitMap.get(e)||[]).filter(e=>e>s);return!(o.length>=this.maxRequestsPerMinute)&&(o.push(t),this.rateLimitMap.set(e,o),!0)}generateSignature(e,t){const s=JSON.stringify(e);return btoa(`${t}.${s}`)}verifySignature(e,t,s){return t===this.generateSignature(e,s)}async test(e){const t=this.webhooks.get(e);if(!t)throw new Error(`Webhook not found: ${e}`);const s={event:"test",timestamp:(new Date).toISOString(),data:{message:"This is a test webhook delivery"},metadata:{test:!0}};await this.deliver(t,s);const o=this.getDeliveriesForWebhook(e);return o[o.length-1]}generateDeliveryId(){return`delivery-${Date.now()}-${Math.random().toString(36).substr(2,9)}`}addDelivery(e){this.deliveries.push(e),this.deliveries.length>this.maxDeliveryHistory&&this.deliveries.shift()}getDeliveriesForWebhook(e){return this.deliveries.filter(t=>t.webhookId===e)}getAllDeliveries(){return[...this.deliveries]}getDelivery(e){return this.deliveries.find(t=>t.id===e)}getStats(e){const t=this.getDeliveriesForWebhook(e),s=t.filter(e=>"success"===e.status),o=t.filter(e=>"failed"===e.status),r=s.reduce((e,t)=>e+(t.responseTime||0),0),i=s.length>0?r/s.length:0,n=t.length>0?t[t.length-1].sentAt:void 0,a=t.length>0?s.length/t.length:0;return{webhookId:e,totalDeliveries:t.length,successfulDeliveries:s.length,failedDeliveries:o.length,averageResponseTime:i,lastDelivery:n,successRate:a}}clearDeliveries(){this.deliveries=[],o.default.info("Webhook delivery history cleared","WebhookService")}exportWebhooks(){const e=this.getAllWebhooks();return JSON.stringify(e,null,2)}importWebhooks(e){try{const t=JSON.parse(e);let s=0;for(const e of t)this.register(e),s++;return o.default.info(`Imported ${s} webhooks`,"WebhookService"),s}catch(e){throw o.default.error("Failed to import webhooks","WebhookService",e),e}}setRateLimit(e){this.maxRequestsPerMinute=e,o.default.info(`Webhook rate limit set to ${e} requests/minute`,"WebhookService")}getRateLimit(){return this.maxRequestsPerMinute}}const i=r.getInstance()}};
//# sourceMappingURL=src_renderer_services_webhookService_ts.main.js.map