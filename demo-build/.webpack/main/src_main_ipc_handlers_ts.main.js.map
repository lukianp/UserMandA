{"version":3,"file":"src_main_ipc_handlers_ts.main.js","mappings":"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","sources":["webpack://enterprise-discovery-suite/./src/main/ipc/handlers.ts"],"sourcesContent":["/**\n * Advanced IPC Handlers for Production APIs\n *\n * Provides IPC handlers for advanced APIs including:\n * - Ticketing system management\n * - Webhook management and testing\n * - Workflow management and execution\n *\n * All handlers include proper error handling and mock implementations\n * ready for production integration.\n */\nimport { ipcMain } from 'electron';\n/**\n * Register all advanced IPC handlers\n */\nexport function registerAdvancedIpcHandlers() {\n    // ========================================\n    // Ticketing System Handlers\n    // ========================================\n    /**\n     * Get tickets with optional filtering and pagination\n     */\n    ipcMain.handle('getTickets', async (_, args = {}) => {\n        try {\n            console.log('IPC: getTickets', args);\n            const { page = 1, limit = 20, status, priority, search, sortBy = 'created_at', sortOrder = 'desc' } = args;\n            // Mock ticket data - replace with actual database/service calls\n            const mockTickets = [\n                {\n                    id: 'ticket-1',\n                    title: 'User migration failed for john.doe@company.com',\n                    description: 'Migration batch #123 failed during mailbox migration phase',\n                    status: 'open',\n                    priority: 'high',\n                    createdAt: new Date(Date.now() - 86400000).toISOString(), // 1 day ago\n                    updatedAt: new Date().toISOString(),\n                    assignedTo: 'admin@company.com',\n                    createdBy: 'system@migration-service',\n                    tags: ['migration', 'mailbox', 'failure'],\n                    comments: [\n                        {\n                            id: 'comment-1',\n                            author: 'system@migration-service',\n                            message: 'Migration failed due to permissions issue',\n                            createdAt: new Date(Date.now() - 86400000).toISOString()\n                        }\n                    ]\n                },\n                {\n                    id: 'ticket-2',\n                    title: 'Data export completed successfully',\n                    description: 'Scheduled weekly data export for compliance reporting',\n                    status: 'closed',\n                    priority: 'medium',\n                    createdAt: new Date(Date.now() - 172800000).toISOString(), // 2 days ago\n                    updatedAt: new Date(Date.now() - 86400000).toISOString(),\n                    assignedTo: null,\n                    createdBy: 'scheduler@system',\n                    tags: ['export', 'compliance'],\n                    comments: []\n                }\n            ];\n            // Apply filters\n            let filteredTickets = mockTickets;\n            if (status) {\n                filteredTickets = filteredTickets.filter(ticket => ticket.status === status);\n            }\n            if (priority) {\n                filteredTickets = filteredTickets.filter(ticket => ticket.priority === priority);\n            }\n            if (search) {\n                const searchLower = search.toLowerCase();\n                filteredTickets = filteredTickets.filter(ticket => ticket.title.toLowerCase().includes(searchLower) ||\n                    ticket.description.toLowerCase().includes(searchLower) ||\n                    ticket.tags.some(tag => tag.toLowerCase().includes(searchLower)));\n            }\n            // Apply sorting\n            filteredTickets.sort((a, b) => {\n                let aValue = a[sortBy];\n                let bValue = b[sortBy];\n                if (sortBy === 'created_at' || sortBy === 'updated_at') {\n                    aValue = new Date(aValue);\n                    bValue = new Date(bValue);\n                }\n                if (sortOrder === 'asc') {\n                    return aValue > bValue ? 1 : -1;\n                }\n                else {\n                    return aValue < bValue ? 1 : -1;\n                }\n            });\n            // Apply pagination\n            const startIndex = (page - 1) * limit;\n            const endIndex = startIndex + limit;\n            const paginatedTickets = filteredTickets.slice(startIndex, endIndex);\n            return {\n                success: true,\n                data: {\n                    tickets: paginatedTickets,\n                    total: filteredTickets.length,\n                    page,\n                    limit,\n                    totalPages: Math.ceil(filteredTickets.length / limit)\n                }\n            };\n        }\n        catch (error) {\n            console.error(`getTickets error: ${error instanceof Error ? error.message : String(error)}`);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : String(error)\n            };\n        }\n    });\n    /**\n     * Create a new ticket\n     */\n    ipcMain.handle('createTicket', async (_, ticketData) => {\n        try {\n            console.log('IPC: createTicket', ticketData);\n            const { title, description, priority, tags = [], assignedTo } = ticketData;\n            if (!title || !description) {\n                throw new Error('Title and description are required');\n            }\n            // Mock ticket creation - replace with actual database/service calls\n            const newTicket = {\n                id: `ticket-${Date.now()}`,\n                title,\n                description,\n                status: 'open',\n                priority,\n                createdAt: new Date().toISOString(),\n                updatedAt: new Date().toISOString(),\n                assignedTo: assignedTo || null,\n                createdBy: 'current-user@system', // TODO: Get from session\n                tags,\n                comments: []\n            };\n            console.log(`Ticket created: ${newTicket.id}`);\n            return { success: true, data: newTicket };\n        }\n        catch (error) {\n            console.error(`createTicket error: ${error instanceof Error ? error.message : String(error)}`);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : String(error)\n            };\n        }\n    });\n    /**\n     * Update an existing ticket\n     */\n    ipcMain.handle('updateTicket', async (_, args) => {\n        try {\n            console.log('IPC: updateTicket', args);\n            const { ticketId, updates } = args;\n            if (!ticketId) {\n                throw new Error('Ticket ID is required');\n            }\n            // Mock ticket update - replace with actual database/service calls\n            // In a real implementation, you would fetch the existing ticket first\n            const updatedTicket = {\n                id: ticketId,\n                ...updates,\n                updatedAt: new Date().toISOString()\n            };\n            console.log(`Ticket updated: ${ticketId}`);\n            return { success: true, data: updatedTicket };\n        }\n        catch (error) {\n            console.error(`updateTicket error: ${error instanceof Error ? error.message : String(error)}`);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : String(error)\n            };\n        }\n    });\n    /**\n     * Delete a ticket\n     */\n    ipcMain.handle('deleteTicket', async (_, args) => {\n        try {\n            console.log('IPC: deleteTicket', args);\n            const { ticketId } = args;\n            if (!ticketId) {\n                throw new Error('Ticket ID is required');\n            }\n            // Mock ticket deletion - replace with actual database/service calls\n            console.log(`Ticket deleted: ${ticketId}`);\n            return { success: true };\n        }\n        catch (error) {\n            console.error(`deleteTicket error: ${error instanceof Error ? error.message : String(error)}`);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : String(error)\n            };\n        }\n    });\n    /**\n     * Add a comment to a ticket\n     */\n    ipcMain.handle('addTicketComment', async (_, args) => {\n        try {\n            console.log('IPC: addTicketComment', args);\n            const { ticketId, comment } = args;\n            if (!ticketId || !comment) {\n                throw new Error('Ticket ID and comment are required');\n            }\n            // Mock comment addition - replace with actual database/service calls\n            const newComment = {\n                id: `comment-${Date.now()}`,\n                author: 'current-user@system', // TODO: Get from session\n                message: comment,\n                createdAt: new Date().toISOString()\n            };\n            console.log(`Comment added to ticket ${ticketId}: ${newComment.id}`);\n            return { success: true, data: newComment };\n        }\n        catch (error) {\n            console.error(`addTicketComment error: ${error instanceof Error ? error.message : String(error)}`);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : String(error)\n            };\n        }\n    });\n    // ========================================\n    // Webhook Handlers\n    // ========================================\n    /**\n     * Get webhooks with optional filtering and pagination\n     */\n    ipcMain.handle('getWebhooks', async (_, args = {}) => {\n        try {\n            console.log('IPC: getWebhooks', args);\n            const { page = 1, limit = 20, search, status } = args;\n            // Mock webhook data - replace with actual webhook service\n            const mockWebhooks = [\n                {\n                    id: 'webhook-1',\n                    name: 'Migration Status Updates',\n                    url: 'https://api.example.com/webhooks/migration-status',\n                    events: ['migration.started', 'migration.completed', 'migration.failed'],\n                    status: 'active',\n                    lastTriggered: new Date(Date.now() - 3600000).toISOString(),\n                    createdAt: new Date(Date.now() - 86400000).toISOString(),\n                    headers: { 'Authorization': 'Bearer token123' },\n                    retryPolicy: { maxRetries: 3, backoffMs: 1000 }\n                },\n                {\n                    id: 'webhook-2',\n                    name: 'Security Alerts',\n                    url: 'https://security.example.com/alerts',\n                    events: ['security.threat', 'security.policy_violation'],\n                    status: 'active',\n                    lastTriggered: new Date(Date.now() - 7200000).toISOString(),\n                    createdAt: new Date(Date.now() - 172800000).toISOString(),\n                    headers: {},\n                    retryPolicy: { maxRetries: 5, backoffMs: 2000 }\n                }\n            ];\n            // Apply filters\n            let filteredWebhooks = mockWebhooks;\n            if (status) {\n                filteredWebhooks = filteredWebhooks.filter(webhook => webhook.status === status);\n            }\n            if (search) {\n                const searchLower = search.toLowerCase();\n                filteredWebhooks = filteredWebhooks.filter(webhook => webhook.name.toLowerCase().includes(searchLower) ||\n                    webhook.url.toLowerCase().includes(searchLower) ||\n                    webhook.events.some(event => event.toLowerCase().includes(searchLower)));\n            }\n            // Apply pagination\n            const startIndex = (page - 1) * limit;\n            const endIndex = startIndex + limit;\n            const paginatedWebhooks = filteredWebhooks.slice(startIndex, endIndex);\n            return {\n                success: true,\n                data: {\n                    webhooks: paginatedWebhooks,\n                    total: filteredWebhooks.length,\n                    page,\n                    limit,\n                    totalPages: Math.ceil(filteredWebhooks.length / limit)\n                }\n            };\n        }\n        catch (error) {\n            console.error(`getWebhooks error: ${error instanceof Error ? error.message : String(error)}`);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : String(error)\n            };\n        }\n    });\n    /**\n     * Create a new webhook\n     */\n    ipcMain.handle('createWebhook', async (_, webhookData) => {\n        try {\n            console.log('IPC: createWebhook', webhookData);\n            const { name, url, events, headers = {}, retryPolicy } = webhookData;\n            if (!name || !url || !events || events.length === 0) {\n                throw new Error('Name, URL, and at least one event are required');\n            }\n            // Validate URL\n            try {\n                new URL(url);\n            }\n            catch {\n                throw new Error('Invalid URL format');\n            }\n            // Mock webhook creation - replace with actual webhook service\n            const newWebhook = {\n                id: `webhook-${Date.now()}`,\n                name,\n                url,\n                events,\n                status: 'active',\n                lastTriggered: null,\n                createdAt: new Date().toISOString(),\n                headers,\n                retryPolicy: retryPolicy || { maxRetries: 3, backoffMs: 1000 }\n            };\n            console.log(`Webhook created: ${newWebhook.id}`);\n            return { success: true, data: newWebhook };\n        }\n        catch (error) {\n            console.error(`createWebhook error: ${error instanceof Error ? error.message : String(error)}`);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : String(error)\n            };\n        }\n    });\n    /**\n     * Update an existing webhook\n     */\n    ipcMain.handle('updateWebhook', async (_, args) => {\n        try {\n            console.log('IPC: updateWebhook', args);\n            const { webhookId, updates } = args;\n            if (!webhookId) {\n                throw new Error('Webhook ID is required');\n            }\n            // Validate URL if provided\n            if (updates.url) {\n                try {\n                    new URL(updates.url);\n                }\n                catch {\n                    throw new Error('Invalid URL format');\n                }\n            }\n            // Mock webhook update - replace with actual webhook service\n            const updatedWebhook = {\n                id: webhookId,\n                ...updates,\n                updatedAt: new Date().toISOString()\n            };\n            console.log(`Webhook updated: ${webhookId}`);\n            return { success: true, data: updatedWebhook };\n        }\n        catch (error) {\n            console.error(`updateWebhook error: ${error instanceof Error ? error.message : String(error)}`);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : String(error)\n            };\n        }\n    });\n    /**\n     * Delete a webhook\n     */\n    ipcMain.handle('deleteWebhook', async (_, args) => {\n        try {\n            console.log('IPC: deleteWebhook', args);\n            const { webhookId } = args;\n            if (!webhookId) {\n                throw new Error('Webhook ID is required');\n            }\n            // Mock webhook deletion - replace with actual webhook service\n            console.log(`Webhook deleted: ${webhookId}`);\n            return { success: true };\n        }\n        catch (error) {\n            console.error(`deleteWebhook error: ${error instanceof Error ? error.message : String(error)}`);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : String(error)\n            };\n        }\n    });\n    /**\n     * Test a webhook by sending a test payload\n     */\n    ipcMain.handle('testWebhook', async (_, args) => {\n        try {\n            console.log('IPC: testWebhook', args);\n            const { webhookId, testEvent = 'test.event', testData = { message: 'Test webhook payload' } } = args;\n            if (!webhookId) {\n                throw new Error('Webhook ID is required');\n            }\n            // Mock webhook testing - replace with actual webhook service\n            // In a real implementation, this would make an HTTP request to the webhook URL\n            console.log(`Testing webhook ${webhookId} with event: ${testEvent}`);\n            // Simulate async webhook call\n            await new Promise(resolve => setTimeout(resolve, 1000));\n            const testResult = {\n                success: true,\n                responseTime: 150,\n                statusCode: 200,\n                response: 'Webhook received successfully'\n            };\n            console.log(`Webhook test completed for ${webhookId}`);\n            return { success: true, data: testResult };\n        }\n        catch (error) {\n            console.error(`testWebhook error: ${error instanceof Error ? error.message : String(error)}`);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : String(error)\n            };\n        }\n    });\n    // ========================================\n    // Workflow Handlers\n    // ========================================\n    /**\n     * Get workflows with optional filtering and pagination\n     */\n    ipcMain.handle('getWorkflows', async (_, args = {}) => {\n        try {\n            console.log('IPC: getWorkflows', args);\n            const { page = 1, limit = 20, search, status, sortBy = 'created_at', sortOrder = 'desc' } = args;\n            // Mock workflow data - replace with actual workflow service\n            const mockWorkflows = [\n                {\n                    id: 'workflow-1',\n                    name: 'Automated User Migration',\n                    description: 'Complete workflow for migrating users from Active Directory to Azure AD',\n                    status: 'active',\n                    steps: [\n                        { id: 'step-1', name: 'Validate User', type: 'validation' },\n                        { id: 'step-2', name: 'Create Azure AD Account', type: 'creation' },\n                        { id: 'step-3', name: 'Migrate Mailbox', type: 'migration' },\n                        { id: 'step-4', name: 'Update Permissions', type: 'permission' }\n                    ],\n                    createdAt: new Date(Date.now() - 86400000).toISOString(),\n                    updatedAt: new Date().toISOString(),\n                    executionCount: 15,\n                    lastExecutedAt: new Date(Date.now() - 3600000).toISOString(),\n                    successRate: 0.87,\n                    averageExecutionTime: 1800000 // 30 minutes\n                },\n                {\n                    id: 'workflow-2',\n                    name: 'Security Compliance Check',\n                    description: 'Automated security compliance validation workflow',\n                    status: 'active',\n                    steps: [\n                        { id: 'step-1', name: 'Gather User Data', type: 'collection' },\n                        { id: 'step-2', name: 'Check Compliance Rules', type: 'validation' },\n                        { id: 'step-3', name: 'Generate Report', type: 'reporting' }\n                    ],\n                    createdAt: new Date(Date.now() - 172800000).toISOString(),\n                    updatedAt: new Date(Date.now() - 86400000).toISOString(),\n                    executionCount: 8,\n                    lastExecutedAt: new Date(Date.now() - 7200000).toISOString(),\n                    successRate: 0.95,\n                    averageExecutionTime: 900000 // 15 minutes\n                }\n            ];\n            // Apply filters\n            let filteredWorkflows = mockWorkflows;\n            if (status) {\n                filteredWorkflows = filteredWorkflows.filter(workflow => workflow.status === status);\n            }\n            if (search) {\n                const searchLower = search.toLowerCase();\n                filteredWorkflows = filteredWorkflows.filter(workflow => workflow.name.toLowerCase().includes(searchLower) ||\n                    workflow.description.toLowerCase().includes(searchLower) ||\n                    workflow.steps.some(step => step.name.toLowerCase().includes(searchLower)));\n            }\n            // Apply sorting\n            filteredWorkflows.sort((a, b) => {\n                let aValue = a[sortBy];\n                let bValue = b[sortBy];\n                if (sortBy === 'created_at' || sortBy === 'updated_at' || (sortBy === 'lastExecutedAt' && 'lastExecutedAt' in a)) {\n                    aValue = new Date(aValue || 0);\n                    bValue = new Date(bValue || 0);\n                }\n                if (sortOrder === 'asc') {\n                    return aValue > bValue ? 1 : -1;\n                }\n                else {\n                    return aValue < bValue ? 1 : -1;\n                }\n            });\n            // Apply pagination\n            const startIndex = (page - 1) * limit;\n            const endIndex = startIndex + limit;\n            const paginatedWorkflows = filteredWorkflows.slice(startIndex, endIndex);\n            return {\n                success: true,\n                data: {\n                    workflows: paginatedWorkflows,\n                    total: filteredWorkflows.length,\n                    page,\n                    limit,\n                    totalPages: Math.ceil(filteredWorkflows.length / limit)\n                }\n            };\n        }\n        catch (error) {\n            console.error(`getWorkflows error: ${error instanceof Error ? error.message : String(error)}`);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : String(error)\n            };\n        }\n    });\n    /**\n     * Create a new workflow\n     */\n    ipcMain.handle('createWorkflow', async (_, workflowData) => {\n        try {\n            console.log('IPC: createWorkflow', workflowData);\n            const { name, description, steps, triggers = [] } = workflowData;\n            if (!name || !steps || steps.length === 0) {\n                throw new Error('Name and at least one step are required');\n            }\n            // Mock workflow creation - replace with actual workflow service\n            const newWorkflow = {\n                id: `workflow-${Date.now()}`,\n                name,\n                description,\n                status: 'active',\n                steps: steps.map((step, index) => ({\n                    id: `step-${index + 1}`,\n                    ...step\n                })),\n                triggers,\n                createdAt: new Date().toISOString(),\n                updatedAt: new Date().toISOString(),\n                executionCount: 0,\n                lastExecutedAt: null,\n                successRate: 0,\n                averageExecutionTime: 0\n            };\n            console.log(`Workflow created: ${newWorkflow.id}`);\n            return { success: true, data: newWorkflow };\n        }\n        catch (error) {\n            console.error(`createWorkflow error: ${error instanceof Error ? error.message : String(error)}`);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : String(error)\n            };\n        }\n    });\n    /**\n     * Execute a workflow with optional parameters\n     */\n    ipcMain.handle('executeWorkflow', async (_, args) => {\n        try {\n            console.log('IPC: executeWorkflow', args);\n            const { workflowId, parameters = {}, priority = 'normal' } = args;\n            if (!workflowId) {\n                throw new Error('Workflow ID is required');\n            }\n            // Mock workflow execution - replace with actual workflow service\n            const executionId = `execution-${Date.now()}`;\n            const execution = {\n                id: executionId,\n                workflowId,\n                status: 'running',\n                startedAt: new Date().toISOString(),\n                parameters,\n                priority,\n                currentStep: 'step-1',\n                progress: 0,\n                steps: [\n                    { id: 'step-1', name: 'Initialize', status: 'running', startedAt: new Date().toISOString() }\n                ]\n            };\n            console.log(`Workflow execution started: ${executionId} for workflow ${workflowId}`);\n            // Simulate async workflow execution\n            setTimeout(() => {\n                console.log(`Workflow execution completed: ${executionId}`);\n            }, 2000);\n            return { success: true, data: execution };\n        }\n        catch (error) {\n            console.error(`executeWorkflow error: ${error instanceof Error ? error.message : String(error)}`);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : String(error)\n            };\n        }\n    });\n    /**\n     * Get workflow execution status\n     */\n    ipcMain.handle('getWorkflowExecution', async (_, args) => {\n        try {\n            console.log('IPC: getWorkflowExecution', args);\n            const { executionId } = args;\n            if (!executionId) {\n                throw new Error('Execution ID is required');\n            }\n            // Mock execution status - replace with actual workflow service\n            const mockExecution = {\n                id: executionId,\n                workflowId: 'workflow-1',\n                status: 'completed',\n                startedAt: new Date(Date.now() - 300000).toISOString(),\n                completedAt: new Date().toISOString(),\n                parameters: { userId: 'user123' },\n                priority: 'normal',\n                currentStep: null,\n                progress: 100,\n                steps: [\n                    {\n                        id: 'step-1',\n                        name: 'Validate User',\n                        status: 'completed',\n                        startedAt: new Date(Date.now() - 300000).toISOString(),\n                        completedAt: new Date(Date.now() - 240000).toISOString(),\n                        duration: 60000\n                    },\n                    {\n                        id: 'step-2',\n                        name: 'Create Azure AD Account',\n                        status: 'completed',\n                        startedAt: new Date(Date.now() - 240000).toISOString(),\n                        completedAt: new Date(Date.now() - 180000).toISOString(),\n                        duration: 60000\n                    }\n                ],\n                result: { success: true, migratedUserId: 'azure-user-456' },\n                error: null\n            };\n            return { success: true, data: mockExecution };\n        }\n        catch (error) {\n            console.error(`getWorkflowExecution error: ${error instanceof Error ? error.message : String(error)}`);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : String(error)\n            };\n        }\n    });\n    /**\n     * Cancel a running workflow execution\n     */\n    ipcMain.handle('cancelWorkflowExecution', async (_, args) => {\n        try {\n            console.log('IPC: cancelWorkflowExecution', args);\n            const { executionId } = args;\n            if (!executionId) {\n                throw new Error('Execution ID is required');\n            }\n            // Mock execution cancellation - replace with actual workflow service\n            console.log(`Workflow execution cancelled: ${executionId}`);\n            return { success: true };\n        }\n        catch (error) {\n            console.error(`cancelWorkflowExecution error: ${error instanceof Error ? error.message : String(error)}`);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : String(error)\n            };\n        }\n    });\n    /**\n     * Delete a workflow\n     */\n    ipcMain.handle('deleteWorkflow', async (_, args) => {\n        try {\n            console.log('IPC: deleteWorkflow', args);\n            const { workflowId } = args;\n            if (!workflowId) {\n                throw new Error('Workflow ID is required');\n            }\n            // Mock workflow deletion - replace with actual workflow service\n            console.log(`Workflow deleted: ${workflowId}`);\n            return { success: true };\n        }\n        catch (error) {\n            console.error(`deleteWorkflow error: ${error instanceof Error ? error.message : String(error)}`);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : String(error)\n            };\n        }\n    });\n    /**\n     * Update an existing workflow\n     */\n    ipcMain.handle('updateWorkflow', async (_, args) => {\n        try {\n            console.log('IPC: updateWorkflow', args);\n            const { workflowId, updates } = args;\n            if (!workflowId) {\n                throw new Error('Workflow ID is required');\n            }\n            // Mock workflow update - replace with actual workflow service\n            const updatedWorkflow = {\n                id: workflowId,\n                ...updates,\n                updatedAt: new Date().toISOString()\n            };\n            console.log(`Workflow updated: ${workflowId}`);\n            return { success: true, data: updatedWorkflow };\n        }\n        catch (error) {\n            console.error(`updateWorkflow error: ${error instanceof Error ? error.message : String(error)}`);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : String(error)\n            };\n        }\n    });\n}\n"],"names":["registerAdvancedIpcHandlers","ipcMain","handle","async","_","args","console","log","page","limit","status","priority","search","sortBy","sortOrder","filteredTickets","id","title","description","createdAt","Date","now","toISOString","updatedAt","assignedTo","createdBy","tags","comments","author","message","filter","ticket","searchLower","toLowerCase","includes","some","tag","sort","a","b","aValue","bValue","startIndex","endIndex","success","data","tickets","slice","total","length","totalPages","Math","ceil","error","Error","String","ticketData","newTicket","ticketId","updates","updatedTicket","comment","newComment","filteredWebhooks","name","url","events","lastTriggered","headers","retryPolicy","maxRetries","backoffMs","webhook","event","webhooks","webhookData","URL","newWebhook","webhookId","updatedWebhook","testEvent","testData","Promise","resolve","setTimeout","testResult","responseTime","statusCode","response","filteredWorkflows","steps","type","executionCount","lastExecutedAt","successRate","averageExecutionTime","workflow","step","workflows","workflowData","triggers","newWorkflow","map","index","workflowId","parameters","executionId","execution","startedAt","currentStep","progress","completedAt","userId","duration","result","migratedUserId","updatedWorkflow"],"sourceRoot":""}