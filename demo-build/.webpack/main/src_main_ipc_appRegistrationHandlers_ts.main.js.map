{"version":3,"file":"src_main_ipc_appRegistrationHandlers_ts.main.js","mappings":"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","sources":["webpack://enterprise-discovery-suite/./src/main/ipc/appRegistrationHandlers.ts","webpack://enterprise-discovery-suite/./src/main/services/appRegistrationService.ts"],"sourcesContent":["/**\n * IPC Handlers for Azure App Registration\n *\n * Provides renderer process access to app registration functionality\n * with real-time status updates via IPC streaming.\n */\nimport { ipcMain, BrowserWindow } from 'electron';\nimport * as appRegistrationService from '../services/appRegistrationService';\n/**\n * Register all app registration IPC handlers\n */\nexport function registerAppRegistrationHandlers() {\n    // Launch app registration script\n    ipcMain.handle('app-registration:launch', async (event, options) => {\n        console.log('[IPC] app-registration:launch', options);\n        return await appRegistrationService.launchAppRegistration(options);\n    });\n    // Check if credentials exist\n    ipcMain.handle('app-registration:has-credentials', async (event, companyName) => {\n        console.log('[IPC] app-registration:has-credentials', companyName);\n        return appRegistrationService.hasAppRegistrationCredentials(companyName);\n    });\n    // Read credential summary\n    ipcMain.handle('app-registration:read-summary', async (event, companyName) => {\n        console.log('[IPC] app-registration:read-summary', companyName);\n        try {\n            return await appRegistrationService.readCredentialSummary(companyName);\n        }\n        catch (error) {\n            console.error('[IPC] app-registration:read-summary error:', error.message);\n            // Return null instead of throwing to let the renderer handle it gracefully\n            return null;\n        }\n    });\n    // Decrypt credential file\n    ipcMain.handle('app-registration:decrypt-credential', async (event, credentialFilePath) => {\n        console.log('[IPC] app-registration:decrypt-credential', credentialFilePath);\n        return await appRegistrationService.decryptCredentialFile(credentialFilePath);\n    });\n    // Read registration status (for progress tracking)\n    ipcMain.handle('app-registration:read-status', async (event, companyName) => {\n        const status = await appRegistrationService.readRegistrationStatus(companyName);\n        if (status) {\n            console.log('[IPC] app-registration:read-status', companyName, '=> status:', status.status, 'step:', status.step, 'progress:', status.progress, '%');\n        }\n        return status;\n    });\n    // Clear registration status (before starting new registration)\n    ipcMain.handle('app-registration:clear-status', async (event, companyName) => {\n        console.log('[IPC] app-registration:clear-status', companyName);\n        return await appRegistrationService.clearRegistrationStatus(companyName);\n    });\n    // Manual status broadcast (can be called from main process)\n    ipcMain.on('app-registration:broadcast-status', (event, status) => {\n        console.log('[IPC] app-registration:broadcast-status', status.step, status.message);\n        // Broadcast to all renderer windows\n        const windows = BrowserWindow.getAllWindows();\n        for (const window of windows) {\n            if (!window.isDestroyed()) {\n                window.webContents.send('app-registration:status-update', status);\n            }\n        }\n    });\n    console.log('[IPC] App registration handlers registered with streaming support');\n}\nexport default registerAppRegistrationHandlers;\n","/**\n * Azure App Registration Service (Main Process)\n *\n * Handles launching the PowerShell app registration script and\n * monitoring for credential file creation with real-time progress tracking.\n *\n * Enhanced with:\n * - Real-time PowerShell output parsing\n * - Structured status file updates\n * - Robust credential summary handling\n * - IPC streaming for immediate GUI feedback\n *\n * Mirrors GUI/ RunAppRegistrationCommand pattern from MainViewModel.cs\n */\nimport { spawn } from 'child_process';\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport { app, BrowserWindow } from 'electron';\n/**\n * Step order for progress calculation\n */\nconst STEP_ORDER = [\n    'Initialization',\n    'Prerequisites',\n    'ModuleManagement',\n    'GraphConnection',\n    'AzureConnection',\n    'AppRegistration',\n    'PermissionGrant',\n    'RoleAssignment',\n    'SubscriptionAccess',\n    'SecretCreation',\n    'CredentialStorage',\n    'Complete',\n];\n/**\n * Maps PowerShell section names to GUI step IDs\n */\nfunction mapSectionToStep(section) {\n    const sectionMap = {\n        'Prerequisites': 'Prerequisites',\n        'ModuleManagement': 'ModuleManagement',\n        'Module Management': 'ModuleManagement',\n        'GraphConnection': 'GraphConnection',\n        'Graph Connection': 'GraphConnection',\n        'Microsoft Graph': 'GraphConnection',\n        'AzureConnection': 'AzureConnection',\n        'Azure Connection': 'AzureConnection',\n        'Azure Login': 'AzureConnection',\n        'AppRegistration': 'AppRegistration',\n        'App Registration': 'AppRegistration',\n        'Application Registration': 'AppRegistration',\n        'PermissionGrant': 'PermissionGrant',\n        'Permission Grant': 'PermissionGrant',\n        'Admin Consent': 'PermissionGrant',\n        'RoleAssignment': 'RoleAssignment',\n        'Role Assignment': 'RoleAssignment',\n        'Directory Roles': 'RoleAssignment',\n        'SubscriptionAccess': 'SubscriptionAccess',\n        'Subscription Access': 'SubscriptionAccess',\n        'Azure Subscriptions': 'SubscriptionAccess',\n        'SecretCreation': 'SecretCreation',\n        'Secret Creation': 'SecretCreation',\n        'Client Secret': 'SecretCreation',\n        'CredentialStorage': 'CredentialStorage',\n        'Credential Storage': 'CredentialStorage',\n        'Credential Encryption': 'CredentialStorage',\n        'Complete': 'Complete',\n        'Completed': 'Complete',\n        'Success': 'Complete',\n    };\n    // Try exact match first\n    if (sectionMap[section]) {\n        return sectionMap[section];\n    }\n    // Try case-insensitive match\n    const lowerSection = section.toLowerCase();\n    for (const [key, value] of Object.entries(sectionMap)) {\n        if (key.toLowerCase() === lowerSection) {\n            return value;\n        }\n    }\n    // Try partial match\n    for (const [key, value] of Object.entries(sectionMap)) {\n        if (lowerSection.includes(key.toLowerCase()) || key.toLowerCase().includes(lowerSection)) {\n            return value;\n        }\n    }\n    return 'Initialization';\n}\n/**\n * Gets progress percentage for a step\n */\nfunction getStepProgress(step, inProgress = false) {\n    const index = STEP_ORDER.indexOf(step);\n    if (index === -1)\n        return 0;\n    const baseProgress = Math.round(((index + 1) / STEP_ORDER.length) * 100);\n    // Show slightly less progress for in-progress steps\n    return inProgress ? Math.max(0, baseProgress - 5) : baseProgress;\n}\n/**\n * Infers step from a message when no explicit section is provided\n */\nfunction inferStepFromMessage(message) {\n    const lowerMessage = message.toLowerCase();\n    if (lowerMessage.includes('prerequisite') || lowerMessage.includes('validat')) {\n        return 'Prerequisites';\n    }\n    if (lowerMessage.includes('module') || lowerMessage.includes('install')) {\n        return 'ModuleManagement';\n    }\n    if (lowerMessage.includes('graph') || lowerMessage.includes('microsoft.graph')) {\n        return 'GraphConnection';\n    }\n    if (lowerMessage.includes('azure') && (lowerMessage.includes('connect') || lowerMessage.includes('login'))) {\n        return 'AzureConnection';\n    }\n    if (lowerMessage.includes('app') && lowerMessage.includes('regist')) {\n        return 'AppRegistration';\n    }\n    if (lowerMessage.includes('permission') || lowerMessage.includes('consent')) {\n        return 'PermissionGrant';\n    }\n    if (lowerMessage.includes('role') || lowerMessage.includes('directory')) {\n        return 'RoleAssignment';\n    }\n    if (lowerMessage.includes('subscription')) {\n        return 'SubscriptionAccess';\n    }\n    if (lowerMessage.includes('secret') || lowerMessage.includes('credential')) {\n        return 'SecretCreation';\n    }\n    if (lowerMessage.includes('encrypt') || lowerMessage.includes('storage') || lowerMessage.includes('saving')) {\n        return 'CredentialStorage';\n    }\n    if (lowerMessage.includes('complete') || lowerMessage.includes('success') || lowerMessage.includes('finished')) {\n        return 'Complete';\n    }\n    return 'Initialization';\n}\n/**\n * Parses PowerShell output line for status updates\n *\n * Handles patterns like:\n * - [COMPLETED] [2025-12-05 16:19:31] [SUCCESS] [OK] ModuleName (?? 35.96s)\n * - [IN PROGRESS] [timestamp] [PROGRESS] message\n * - [FAILED] [timestamp] [ERROR] message\n */\nfunction parsePowerShellOutput(line) {\n    if (!line || line.trim().length === 0) {\n        return null;\n    }\n    // Pattern for completed operations: [COMPLETED] [timestamp] [SUCCESS] [OK] Section (duration)\n    const completedPattern = /^\\[COMPLETED\\]\\s+\\[([^\\]]+)\\]\\s*\\[SUCCESS\\]\\s*\\[OK\\]\\s*(.+?)\\s*(?:\\([^)]*?([\\d.]+)s\\))?$/i;\n    // Pattern for in-progress operations: [IN PROGRESS] [timestamp] [PROGRESS] message\n    const inProgressPattern = /^\\[IN PROGRESS\\]\\s+\\[([^\\]]+)\\]\\s*\\[PROGRESS\\]\\s*(.+)$/i;\n    // Pattern for failed operations: [FAILED] [timestamp] [ERROR] message\n    const failedPattern = /^\\[FAILED\\]\\s+\\[([^\\]]+)\\]\\s*\\[(?:ERROR|CRITICAL)\\]\\s*(.+)$/i;\n    // Alternative patterns for simpler output\n    const simpleSuccessPattern = /^\\[OK\\]\\s+(.+?)\\s*(?:\\([^)]*?([\\d.]+)s\\))?$/i;\n    const simpleProgressPattern = /^(?:\\[PROGRESS\\]|Starting:?)\\s*(.+)$/i;\n    const simpleErrorPattern = /^(?:\\[ERROR\\]|\\[CRITICAL\\]|Error:)\\s*(.+)$/i;\n    let match;\n    const timestamp = new Date().toISOString();\n    // Try completed pattern\n    if ((match = completedPattern.exec(line))) {\n        const [, ts, section, duration] = match;\n        const step = mapSectionToStep(section.trim());\n        return {\n            status: 'completed',\n            step,\n            message: `${section.trim()} completed${duration ? ` in ${duration}s` : ''}`,\n            progress: getStepProgress(step),\n            timestamp: ts || timestamp,\n        };\n    }\n    // Try in-progress pattern\n    if ((match = inProgressPattern.exec(line))) {\n        const [, ts, message] = match;\n        const step = inferStepFromMessage(message);\n        return {\n            status: 'in_progress',\n            step,\n            message: message.trim(),\n            progress: getStepProgress(step, true),\n            timestamp: ts || timestamp,\n        };\n    }\n    // Try failed pattern\n    if ((match = failedPattern.exec(line))) {\n        const [, ts, errorMsg] = match;\n        return {\n            status: 'failed',\n            step: 'Error',\n            message: 'Operation failed',\n            progress: 0,\n            timestamp: ts || timestamp,\n            error: errorMsg.trim(),\n        };\n    }\n    // Try simple success pattern\n    if ((match = simpleSuccessPattern.exec(line))) {\n        const [, section, duration] = match;\n        const step = mapSectionToStep(section.trim());\n        return {\n            status: 'completed',\n            step,\n            message: `${section.trim()} completed${duration ? ` in ${duration}s` : ''}`,\n            progress: getStepProgress(step),\n            timestamp,\n        };\n    }\n    // Try simple progress pattern\n    if ((match = simpleProgressPattern.exec(line))) {\n        const [, message] = match;\n        const step = inferStepFromMessage(message);\n        return {\n            status: 'in_progress',\n            step,\n            message: message.trim(),\n            progress: getStepProgress(step, true),\n            timestamp,\n        };\n    }\n    // Try simple error pattern\n    if ((match = simpleErrorPattern.exec(line))) {\n        const [, errorMsg] = match;\n        return {\n            status: 'failed',\n            step: 'Error',\n            message: 'Error occurred',\n            progress: 0,\n            timestamp,\n            error: errorMsg.trim(),\n        };\n    }\n    return null;\n}\n/**\n * Get the path to the registration status file\n */\nfunction getStatusFilePath(companyName) {\n    return path.join('C:', 'DiscoveryData', companyName, 'Logs', 'MandADiscovery_Registration_Log_status.json');\n}\n/**\n * Writes status to JSON file for GUI polling\n */\nasync function writeStatusFile(companyName, status) {\n    try {\n        const statusPath = getStatusFilePath(companyName);\n        const dir = path.dirname(statusPath);\n        await fs.promises.mkdir(dir, { recursive: true });\n        const statusData = {\n            status: status.status === 'completed' && status.step === 'Complete' ? 'success' :\n                status.status === 'failed' ? 'failed' : 'running',\n            message: status.message,\n            error: status.error || '',\n            step: status.step,\n            timestamp: status.timestamp,\n            logFile: path.join('C:', 'DiscoveryData', companyName, 'Logs', 'MandADiscovery_Registration_Log.txt'),\n            progress: status.progress,\n        };\n        await fs.promises.writeFile(statusPath, JSON.stringify(statusData, null, 2));\n        console.log(`[AppRegistrationService] Status update written: ${status.step} - ${status.message}`);\n    }\n    catch (error) {\n        console.error('[AppRegistrationService] Failed to write status file:', error);\n    }\n}\n/**\n * Writes initial status file when launching script\n */\nasync function writeInitialStatus(companyName) {\n    const initialStatus = {\n        status: 'in_progress',\n        step: 'Initialization',\n        message: 'Launching PowerShell app registration script...',\n        progress: 0,\n        timestamp: new Date().toISOString(),\n    };\n    await writeStatusFile(companyName, initialStatus);\n}\n/**\n * Broadcasts status update to all renderer windows via IPC\n */\nfunction broadcastStatusUpdate(status) {\n    try {\n        const windows = BrowserWindow.getAllWindows();\n        for (const window of windows) {\n            if (!window.isDestroyed()) {\n                window.webContents.send('app-registration:status-update', status);\n            }\n        }\n    }\n    catch (error) {\n        console.error('[AppRegistrationService] Failed to broadcast status:', error);\n    }\n}\n/**\n * Monitors status file for detached PowerShell processes\n * Used when showWindow: true (interactive mode)\n */\nfunction startFileBasedMonitoring(companyName) {\n    const statusFilePath = getStatusFilePath(companyName);\n    const credentialSummaryPath = path.join('C:', 'DiscoveryData', companyName, 'Credentials', 'credential_summary.json');\n    console.log(`[AppRegistrationService] ========================================`);\n    console.log(`[AppRegistrationService] Starting file-based status monitoring`);\n    console.log(`[AppRegistrationService] Status file: ${statusFilePath}`);\n    console.log(`[AppRegistrationService] Credential file: ${credentialSummaryPath}`);\n    console.log(`[AppRegistrationService] Poll interval: 1000ms`);\n    console.log(`[AppRegistrationService] Max duration: 10 minutes`);\n    console.log(`[AppRegistrationService] ========================================`);\n    const startTime = Date.now();\n    const maxDuration = 10 * 60 * 1000; // 10 minutes timeout\n    let lastStatusContent = '';\n    const pollInterval = setInterval(async () => {\n        try {\n            // Check timeout\n            const elapsed = Date.now() - startTime;\n            if (elapsed > maxDuration) {\n                clearInterval(pollInterval);\n                console.warn(`[AppRegistrationService] âš ï¸ File monitoring timeout after ${Math.round(elapsed / 1000)}s`);\n                const timeoutStatus = {\n                    status: 'failed',\n                    step: 'Error',\n                    message: 'Operation timed out after 10 minutes',\n                    progress: 50,\n                    timestamp: new Date().toISOString(),\n                    error: 'Timeout exceeded'\n                };\n                await writeStatusFile(companyName, timeoutStatus);\n                broadcastStatusUpdate(timeoutStatus);\n                return;\n            }\n            // Check if credentials file exists (completion indicator)\n            if (fs.existsSync(credentialSummaryPath)) {\n                clearInterval(pollInterval);\n                console.log(`[AppRegistrationService] âœ… Credential file detected - registration complete!`);\n                const successStatus = {\n                    status: 'completed',\n                    step: 'Complete',\n                    message: 'App registration completed successfully',\n                    progress: 100,\n                    timestamp: new Date().toISOString()\n                };\n                await writeStatusFile(companyName, successStatus);\n                broadcastStatusUpdate(successStatus);\n                return;\n            }\n            // Check status file\n            if (fs.existsSync(statusFilePath)) {\n                const content = fs.readFileSync(statusFilePath, 'utf-8');\n                // Only process if content changed (avoid redundant broadcasts)\n                if (content !== lastStatusContent) {\n                    lastStatusContent = content;\n                    try {\n                        const status = JSON.parse(content);\n                        console.log(`[AppRegistrationService] ðŸ“„ Status file update:`, {\n                            status: status.status,\n                            step: status.step,\n                            progress: status.progress,\n                            message: status.message.substring(0, 50) + '...'\n                        });\n                        // Convert to ParsedPowerShellOutput format for broadcasting\n                        const parsedStatus = {\n                            status: status.status === 'success' ? 'completed' :\n                                status.status === 'failed' ? 'failed' : 'in_progress',\n                            step: status.step,\n                            message: status.message,\n                            progress: status.progress || 0,\n                            timestamp: status.timestamp,\n                            error: status.error\n                        };\n                        broadcastStatusUpdate(parsedStatus);\n                        // Stop monitoring if completed or failed\n                        if (status.status === 'success' || status.status === 'failed') {\n                            clearInterval(pollInterval);\n                            console.log(`[AppRegistrationService] ${status.status === 'success' ? 'âœ… SUCCESS' : 'âŒ FAILED'} - monitoring stopped`);\n                        }\n                    }\n                    catch (parseError) {\n                        console.warn(`[AppRegistrationService] âš ï¸ Failed to parse status file:`, parseError);\n                    }\n                }\n            }\n            else {\n                // Status file doesn't exist yet - script still initializing\n                console.log(`[AppRegistrationService] â³ Waiting for status file... (${Math.round(elapsed / 1000)}s elapsed)`);\n            }\n        }\n        catch (error) {\n            console.error(`[AppRegistrationService] âŒ Error in file monitoring:`, error);\n        }\n    }, 1000); // Poll every 1 second\n    console.log(`[AppRegistrationService] File monitoring started (interval: ${pollInterval})`);\n}\n/**\n * Launches the Azure App Registration PowerShell script\n *\n * Pattern from GUI/MainViewModel.cs:2041-2087 (RunAppRegistrationAsync)\n */\nexport async function launchAppRegistration(options) {\n    try {\n        // Find the PowerShell script\n        const scriptPath = findAppRegistrationScript();\n        if (!scriptPath || !fs.existsSync(scriptPath)) {\n            return {\n                success: false,\n                error: 'App registration script not found. Expected at Scripts/DiscoveryCreateAppRegistration.ps1'\n            };\n        }\n        // Build PowerShell arguments\n        const args = buildPowerShellArgs(scriptPath, options);\n        console.log(`[AppRegistrationService] Launching script: ${scriptPath}`);\n        console.log(`[AppRegistrationService] Company: ${options.companyName}`);\n        // Write initial status\n        await writeInitialStatus(options.companyName);\n        if (options.showWindow) {\n            // Launch in new window (user-interactive mode) with -NoExit to keep window open\n            // Use cmd.exe with 'start' to create a visible PowerShell window\n            // Build PowerShell script arguments array\n            const scriptArgs = ['-CompanyName', `\"${options.companyName}\"`];\n            if (options.autoInstallModules) {\n                scriptArgs.push('-AutoInstallModules');\n            }\n            if (options.secretValidityYears) {\n                scriptArgs.push('-SecretValidityYears', options.secretValidityYears.toString());\n            }\n            if (options.skipAzureRoles) {\n                scriptArgs.push('-SkipAzureRoles');\n            }\n            // Build cmd.exe arguments array\n            // Using 'start' to open new window - first arg is empty title \"\", second is the program\n            const cmdArgs = [\n                '/c', // Run command and terminate\n                'start', // Start a new window\n                '\"\"', // Empty title (required by start command)\n                'powershell.exe',\n                '-NoProfile',\n                '-ExecutionPolicy', 'Bypass',\n                '-NoExit', // Keep window open after script completes\n                '-File',\n                `\"${scriptPath}\"`, // Quote the path\n                ...scriptArgs // Script arguments already quoted where needed\n            ];\n            console.log(`[AppRegistrationService] ========================================`);\n            console.log(`[AppRegistrationService] LAUNCHING POWERSHELL WINDOW (FILE-BASED MONITORING)`);\n            console.log(`[AppRegistrationService] Script path: ${scriptPath}`);\n            console.log(`[AppRegistrationService] Cmd args: ${JSON.stringify(cmdArgs)}`);\n            console.log(`[AppRegistrationService] ========================================`);\n            const child = spawn('cmd.exe', cmdArgs, {\n                detached: true,\n                stdio: 'ignore',\n                windowsHide: false,\n                shell: true // Use shell to properly handle 'start' command\n            });\n            child.unref(); // Allow parent to exit\n            console.log(`[AppRegistrationService] PowerShell window launched, PID: ${child.pid}`);\n            // Start file-based status monitoring for detached process\n            // The PowerShell script writes to a status file which we poll\n            startFileBasedMonitoring(options.companyName);\n            return {\n                success: true,\n                message: 'App registration script launched in new window (file-based monitoring active)',\n                processId: child.pid\n            };\n        }\n        else {\n            // Execute and capture output (automated mode) with real-time parsing\n            return new Promise((resolve) => {\n                const child = spawn('powershell.exe', args, {\n                    shell: true,\n                    stdio: ['ignore', 'pipe', 'pipe']\n                });\n                let lastStatus = null;\n                let outputBuffer = '';\n                let errorBuffer = '';\n                // Process stdout for real-time status updates\n                child.stdout?.on('data', (data) => {\n                    const chunk = data.toString();\n                    outputBuffer += chunk;\n                    // Process line by line\n                    const lines = chunk.split('\\n');\n                    for (const line of lines) {\n                        const trimmedLine = line.trim();\n                        if (trimmedLine) {\n                            const parsed = parsePowerShellOutput(trimmedLine);\n                            if (parsed) {\n                                lastStatus = parsed;\n                                // Write status file and broadcast\n                                writeStatusFile(options.companyName, parsed);\n                                broadcastStatusUpdate(parsed);\n                            }\n                        }\n                    }\n                });\n                // Capture stderr\n                child.stderr?.on('data', (data) => {\n                    const chunk = data.toString();\n                    errorBuffer += chunk;\n                    // Check for error patterns\n                    const lines = chunk.split('\\n');\n                    for (const line of lines) {\n                        const trimmedLine = line.trim();\n                        if (trimmedLine && (trimmedLine.toLowerCase().includes('error') || trimmedLine.toLowerCase().includes('failed'))) {\n                            const errorStatus = {\n                                status: 'failed',\n                                step: 'Error',\n                                message: 'Script error occurred',\n                                progress: lastStatus?.progress || 0,\n                                timestamp: new Date().toISOString(),\n                                error: trimmedLine,\n                            };\n                            writeStatusFile(options.companyName, errorStatus);\n                            broadcastStatusUpdate(errorStatus);\n                        }\n                    }\n                });\n                child.on('close', async (code) => {\n                    console.log(`[AppRegistrationService] Script exited with code: ${code}`);\n                    if (code === 0) {\n                        // Write final success status\n                        const successStatus = {\n                            status: 'completed',\n                            step: 'Complete',\n                            message: 'App registration completed successfully',\n                            progress: 100,\n                            timestamp: new Date().toISOString(),\n                        };\n                        await writeStatusFile(options.companyName, successStatus);\n                        broadcastStatusUpdate(successStatus);\n                        resolve({\n                            success: true,\n                            message: 'App registration completed successfully'\n                        });\n                    }\n                    else {\n                        const errorStatus = {\n                            status: 'failed',\n                            step: 'Error',\n                            message: `App registration script failed with exit code ${code}`,\n                            progress: lastStatus?.progress || 0,\n                            timestamp: new Date().toISOString(),\n                            error: errorBuffer || lastStatus?.error || `Exit code: ${code}`,\n                        };\n                        await writeStatusFile(options.companyName, errorStatus);\n                        broadcastStatusUpdate(errorStatus);\n                        resolve({\n                            success: false,\n                            error: `App registration script failed with exit code ${code}`,\n                            message: lastStatus?.message || errorBuffer || 'Unknown error'\n                        });\n                    }\n                });\n                child.on('error', async (error) => {\n                    const errorStatus = {\n                        status: 'failed',\n                        step: 'Error',\n                        message: 'Failed to launch PowerShell script',\n                        progress: 0,\n                        timestamp: new Date().toISOString(),\n                        error: error.message,\n                    };\n                    await writeStatusFile(options.companyName, errorStatus);\n                    broadcastStatusUpdate(errorStatus);\n                    resolve({\n                        success: false,\n                        error: `Failed to launch PowerShell: ${error.message}`\n                    });\n                });\n            });\n        }\n    }\n    catch (error) {\n        console.error('[AppRegistrationService] Launch failed:', error);\n        return {\n            success: false,\n            error: `Failed to launch app registration: ${error.message}`\n        };\n    }\n}\n/**\n * Finds the app registration PowerShell script\n */\nfunction findAppRegistrationScript() {\n    // Try multiple potential locations\n    const possiblePaths = [\n        // Development mode - from repo root\n        path.join(app.getAppPath(), '..', '..', 'Scripts', 'DiscoveryCreateAppRegistration.ps1'),\n        // Production mode - bundled in resources\n        path.join(process.resourcesPath, 'Scripts', 'DiscoveryCreateAppRegistration.ps1'),\n        // C:\\enterprisediscovery location\n        path.join('C:', 'enterprisediscovery', 'Scripts', 'DiscoveryCreateAppRegistration.ps1'),\n        // Fallback - user's scripts directory\n        path.join('D:', 'Scripts', 'UserMandA', 'Scripts', 'DiscoveryCreateAppRegistration.ps1'),\n        // Fallback - current working directory\n        path.join(process.cwd(), 'Scripts', 'DiscoveryCreateAppRegistration.ps1')\n    ];\n    for (const scriptPath of possiblePaths) {\n        if (fs.existsSync(scriptPath)) {\n            console.log(`[AppRegistrationService] Found script at: ${scriptPath}`);\n            return scriptPath;\n        }\n    }\n    console.error('[AppRegistrationService] Script not found in any location');\n    return null;\n}\n/**\n * Builds PowerShell command arguments\n */\nfunction buildPowerShellArgs(scriptPath, options) {\n    const args = [\n        '-NoProfile',\n        '-ExecutionPolicy', 'Bypass',\n        '-File', `\"${scriptPath}\"`,\n        '-CompanyName', `\"${options.companyName}\"`\n    ];\n    if (options.autoInstallModules) {\n        args.push('-AutoInstallModules');\n    }\n    if (options.secretValidityYears) {\n        args.push('-SecretValidityYears', options.secretValidityYears.toString());\n    }\n    if (options.skipAzureRoles) {\n        args.push('-SkipAzureRoles');\n    }\n    return args;\n}\n/**\n * Checks if app registration credentials exist for a company\n *\n * Looks for credential_summary.json or discoverycredentials.summary.json\n */\nexport function hasAppRegistrationCredentials(companyName) {\n    const credentialsDir = path.join('C:', 'DiscoveryData', companyName, 'Credentials');\n    if (!fs.existsSync(credentialsDir)) {\n        return false;\n    }\n    const summaryPaths = [\n        path.join(credentialsDir, 'credential_summary.json'),\n        path.join(credentialsDir, 'discoverycredentials.summary.json'),\n        path.join(credentialsDir, 'credential-summary.json')\n    ];\n    return summaryPaths.some(p => fs.existsSync(p));\n}\n/**\n * Reads app registration credential summary with enhanced error handling\n *\n * Pattern from GUI/Services/TargetProfileService.cs:189-250\n */\nexport async function readCredentialSummary(companyName) {\n    const possiblePaths = [\n        path.join('C:', 'DiscoveryData', companyName, 'Credentials', 'credential_summary.json'),\n        path.join('C:', 'DiscoveryData', companyName, 'Credentials', 'discoverycredentials.summary.json'),\n        path.join('C:', 'DiscoveryData', companyName, 'Credentials', 'credential-summary.json')\n    ];\n    let lastError = '';\n    for (const summaryPath of possiblePaths) {\n        try {\n            if (!fs.existsSync(summaryPath)) {\n                continue; // Try next path\n            }\n            console.log(`[AppRegistrationService] Attempting to read summary from: ${summaryPath}`);\n            let content = await fs.promises.readFile(summaryPath, 'utf8');\n            // Strip BOM (Byte Order Mark) if present - PowerShell often writes UTF-8 with BOM\n            if (content.charCodeAt(0) === 0xFEFF) {\n                content = content.slice(1);\n            }\n            if (!content || content.trim().length === 0) {\n                lastError = `File exists but is empty: ${summaryPath}`;\n                continue;\n            }\n            let rawSummary;\n            try {\n                rawSummary = JSON.parse(content);\n            }\n            catch (parseError) {\n                lastError = `Invalid JSON in file ${summaryPath}: ${parseError.message}`;\n                continue;\n            }\n            // Validate required fields\n            if (!rawSummary.TenantId || !rawSummary.ClientId) {\n                lastError = `Missing required fields (TenantId, ClientId) in ${summaryPath}`;\n                continue;\n            }\n            const credentialsDir = path.dirname(summaryPath);\n            const summary = {\n                TenantId: rawSummary.TenantId,\n                ClientId: rawSummary.ClientId,\n                CredentialFile: rawSummary.CredentialFile,\n                Created: rawSummary.Created || rawSummary.CreatedDate || new Date().toISOString(),\n                Domain: rawSummary.Domain || ''\n            };\n            // Ensure credential file path is absolute\n            if (summary.CredentialFile && !path.isAbsolute(summary.CredentialFile)) {\n                summary.CredentialFile = path.join(credentialsDir, summary.CredentialFile);\n            }\n            // If no CredentialFile specified, try default locations\n            if (!summary.CredentialFile) {\n                const defaultCredPaths = [\n                    path.join(credentialsDir, 'discoverycredentials.config'),\n                    path.join(credentialsDir, 'credentials.config'),\n                    path.join(credentialsDir, 'app-credentials.config')\n                ];\n                for (const defaultPath of defaultCredPaths) {\n                    if (fs.existsSync(defaultPath)) {\n                        summary.CredentialFile = defaultPath;\n                        break;\n                    }\n                }\n                if (!summary.CredentialFile) {\n                    lastError = `No credential file specified and default not found in: ${credentialsDir}`;\n                    continue;\n                }\n            }\n            // Validate credential file exists\n            if (!fs.existsSync(summary.CredentialFile)) {\n                lastError = `Credential file not found: ${summary.CredentialFile}`;\n                continue;\n            }\n            console.log(`[AppRegistrationService] Successfully read credential summary from: ${summaryPath}`);\n            return summary;\n        }\n        catch (error) {\n            lastError = `Unexpected error reading ${summaryPath}: ${error.message}`;\n            continue;\n        }\n    }\n    // If we get here, none of the paths worked\n    const errorMsg = lastError || `No credential summary file found in any expected location: ${possiblePaths.join(', ')}`;\n    console.error(`[AppRegistrationService] ${errorMsg}`);\n    throw new Error(`Failed to read credential summary: ${errorMsg}`);\n}\n/**\n * Reads credential file - handles both plain JSON and DPAPI encrypted formats\n *\n * Pattern from GUI/Models/TargetProfile.cs:226-251\n */\nexport async function decryptCredentialFile(credentialFilePath) {\n    try {\n        if (!fs.existsSync(credentialFilePath)) {\n            console.error(`[AppRegistrationService] Credential file not found: ${credentialFilePath}`);\n            return null;\n        }\n        // First try to read as plain JSON\n        let content = await fs.promises.readFile(credentialFilePath, 'utf8');\n        // Strip BOM (Byte Order Mark) if present - PowerShell often writes UTF-8 with BOM\n        if (content.charCodeAt(0) === 0xFEFF) {\n            content = content.slice(1);\n        }\n        try {\n            // Try parsing as plain JSON first\n            const credData = JSON.parse(content);\n            if (credData.ClientSecret) {\n                console.log(`[AppRegistrationService] Read client secret from plain JSON credential file`);\n                return credData.ClientSecret;\n            }\n        }\n        catch {\n            // Not valid JSON, try DPAPI decryption\n            console.log(`[AppRegistrationService] Credential file is not plain JSON, trying DPAPI decryption`);\n        }\n        // Fall back to DPAPI decryption for encrypted files\n        // Escape single quotes in file path\n        const escapedPath = credentialFilePath.replace(/'/g, \"''\");\n        const script = `\r\n      try {\r\n        $enc = (Get-Content -Raw -Path '${escapedPath}').Trim()\r\n        $ss = $enc | ConvertTo-SecureString\r\n        $bstr = [Runtime.InteropServices.Marshal]::SecureStringToBSTR($ss)\r\n        $json = [Runtime.InteropServices.Marshal]::PtrToStringUni($bstr)\r\n        [Runtime.InteropServices.Marshal]::ZeroFreeBSTR($bstr)\r\n        $credData = $json | ConvertFrom-Json\r\n        Write-Output $credData.ClientSecret\r\n      } catch {\r\n        Write-Error $_.Exception.Message\r\n        exit 1\r\n      }\r\n    `;\n        return new Promise((resolve) => {\n            const child = spawn('powershell.exe', [\n                '-NoProfile',\n                '-ExecutionPolicy', 'Bypass',\n                '-Command', script\n            ]);\n            let stdout = '';\n            let stderr = '';\n            child.stdout?.on('data', (data) => {\n                stdout += data.toString();\n            });\n            child.stderr?.on('data', (data) => {\n                stderr += data.toString();\n            });\n            child.on('close', (code) => {\n                if (code === 0 && stdout.trim()) {\n                    resolve(stdout.trim());\n                }\n                else {\n                    console.error(`[AppRegistrationService] Decryption failed:`, stderr);\n                    resolve(null);\n                }\n            });\n            child.on('error', (error) => {\n                console.error(`[AppRegistrationService] PowerShell execution failed:`, error);\n                resolve(null);\n            });\n        });\n    }\n    catch (error) {\n        console.error(`[AppRegistrationService] Credential read error:`, error);\n        return null;\n    }\n}\n/**\n * Monitors for app registration credential files\n *\n * Returns a cleanup function to stop monitoring\n */\nexport function watchForCredentials(companyName, callback, options) {\n    const pollInterval = options?.pollInterval || 5000; // Default: 5 seconds\n    const maxDuration = options?.maxDuration || 300000; // Default: 5 minutes\n    let intervalHandle = null;\n    let timeoutHandle = null;\n    let stopped = false;\n    const checkForCredentials = async () => {\n        if (stopped)\n            return;\n        const summary = await readCredentialSummary(companyName);\n        if (summary) {\n            console.log(`[AppRegistrationService] Credentials detected for ${companyName}`);\n            cleanup();\n            callback(summary);\n        }\n    };\n    const cleanup = () => {\n        stopped = true;\n        if (intervalHandle) {\n            clearInterval(intervalHandle);\n            intervalHandle = null;\n        }\n        if (timeoutHandle) {\n            clearTimeout(timeoutHandle);\n            timeoutHandle = null;\n        }\n    };\n    // Start polling\n    intervalHandle = setInterval(checkForCredentials, pollInterval);\n    // Set maximum duration\n    if (maxDuration > 0) {\n        timeoutHandle = setTimeout(() => {\n            console.log(`[AppRegistrationService] Credential watch timeout for ${companyName}`);\n            cleanup();\n        }, maxDuration);\n    }\n    // Initial check\n    checkForCredentials();\n    // Return cleanup function\n    return cleanup;\n}\n/**\n * Reads the registration status file written by the PowerShell script\n *\n * The script writes status updates to: {LogPath}_status.json\n * This allows the GUI to track progress in real-time\n */\nexport async function readRegistrationStatus(companyName) {\n    try {\n        const statusPath = path.join('C:', 'DiscoveryData', companyName, 'Logs', 'MandADiscovery_Registration_Log_status.json');\n        if (!fs.existsSync(statusPath)) {\n            return null;\n        }\n        let content = await fs.promises.readFile(statusPath, 'utf8');\n        // Strip BOM (Byte Order Mark) if present - PowerShell often writes UTF-8 with BOM\n        if (content.charCodeAt(0) === 0xFEFF) {\n            content = content.slice(1);\n        }\n        const status = JSON.parse(content);\n        return status;\n    }\n    catch (error) {\n        console.error(`[AppRegistrationService] Failed to read status file:`, error);\n        return null;\n    }\n}\n/**\n * Clears the registration status file to prepare for a new run\n */\nexport async function clearRegistrationStatus(companyName) {\n    try {\n        const statusPath = path.join('C:', 'DiscoveryData', companyName, 'Logs', 'MandADiscovery_Registration_Log_status.json');\n        if (fs.existsSync(statusPath)) {\n            await fs.promises.unlink(statusPath);\n            console.log(`[AppRegistrationService] Cleared status file for ${companyName}`);\n        }\n    }\n    catch (error) {\n        console.error(`[AppRegistrationService] Failed to clear status file:`, error);\n    }\n}\nexport default {\n    launchAppRegistration,\n    hasAppRegistrationCredentials,\n    readCredentialSummary,\n    decryptCredentialFile,\n    watchForCredentials,\n    readRegistrationStatus,\n    clearRegistrationStatus\n};\n"],"names":["registerAppRegistrationHandlers","ipcMain","handle","async","event","options","console","log","companyName","error","message","credentialFilePath","status","step","progress","on","windows","BrowserWindow","getAllWindows","window","isDestroyed","webContents","send","STEP_ORDER","mapSectionToStep","section","sectionMap","lowerSection","toLowerCase","key","value","Object","entries","includes","getStepProgress","inProgress","index","indexOf","baseProgress","Math","round","length","max","inferStepFromMessage","lowerMessage","parsePowerShellOutput","line","trim","match","timestamp","Date","toISOString","exec","ts","duration","errorMsg","getStatusFilePath","writeStatusFile","statusPath","dir","mkdir","recursive","statusData","logFile","writeFile","JSON","stringify","broadcastStatusUpdate","launchAppRegistration","scriptPath","possiblePaths","app","getAppPath","process","resourcesPath","cwd","findAppRegistrationScript","success","args","autoInstallModules","push","secretValidityYears","toString","skipAzureRoles","buildPowerShellArgs","initialStatus","writeInitialStatus","showWindow","scriptArgs","cmdArgs","child","spawn","detached","stdio","windowsHide","shell","unref","pid","statusFilePath","credentialSummaryPath","startTime","now","lastStatusContent","pollInterval","setInterval","elapsed","clearInterval","warn","timeoutStatus","successStatus","content","parse","substring","parseError","startFileBasedMonitoring","processId","Promise","resolve","lastStatus","outputBuffer","errorBuffer","stdout","data","chunk","lines","split","trimmedLine","parsed","stderr","errorStatus","code","hasAppRegistrationCredentials","credentialsDir","some","p","readCredentialSummary","lastError","summaryPath","rawSummary","readFile","charCodeAt","slice","TenantId","ClientId","summary","CredentialFile","Created","CreatedDate","Domain","defaultCredPaths","defaultPath","join","Error","decryptCredentialFile","credData","ClientSecret","script","replace","readRegistrationStatus","clearRegistrationStatus","unlink"],"sourceRoot":""}