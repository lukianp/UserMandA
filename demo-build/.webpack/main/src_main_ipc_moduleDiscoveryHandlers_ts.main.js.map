{"version":3,"file":"src_main_ipc_moduleDiscoveryHandlers_ts.main.js","mappings":"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","sources":["webpack://enterprise-discovery-suite/./src/main/ipc/moduleDiscoveryHandlers.ts","webpack://enterprise-discovery-suite/./src/main/services/enhancedModuleDiscovery.ts"],"sourcesContent":["/**\n * Module Discovery IPC Handlers\n *\n * IPC handlers for PowerShell module discovery service\n */\nimport path from 'path';\nimport { ipcMain } from 'electron';\nimport { getEnhancedModuleDiscoveryService } from '../services/enhancedModuleDiscovery';\n/**\n * Register all module discovery IPC handlers\n */\nexport function registerModuleDiscoveryHandlers() {\n    // Discover modules\n    ipcMain.handle('module-discovery:discover', async (event) => {\n        try {\n            const service = getEnhancedModuleDiscoveryService();\n            // Determine scripts root path\n            const scriptsRoot = process.env.SCRIPTS_ROOT || path.join(__dirname, '../../Scripts');\n            const modules = await service.discoverModules(scriptsRoot);\n            return { success: true, modules };\n        }\n        catch (error) {\n            return { success: false, error: error.message, modules: [] };\n        }\n    });\n    // Get module by ID\n    ipcMain.handle('module-discovery:get-by-id', async (event, moduleId) => {\n        try {\n            const service = getEnhancedModuleDiscoveryService();\n            const module = service.getModuleById(moduleId);\n            if (!module) {\n                return { success: false, error: 'Module not found' };\n            }\n            return { success: true, module };\n        }\n        catch (error) {\n            return { success: false, error: error.message };\n        }\n    });\n    // Search modules\n    ipcMain.handle('module-discovery:search', async (event, query) => {\n        try {\n            const service = getEnhancedModuleDiscoveryService();\n            const modules = service.searchModules(query);\n            return { success: true, modules };\n        }\n        catch (error) {\n            return { success: false, error: error.message, modules: [] };\n        }\n    });\n    // Get modules by category\n    ipcMain.handle('module-discovery:get-by-category', async (event, category) => {\n        try {\n            const service = getEnhancedModuleDiscoveryService();\n            const modules = service.getModulesByCategory(category);\n            return { success: true, modules };\n        }\n        catch (error) {\n            return { success: false, error: error.message, modules: [] };\n        }\n    });\n    // Get all categories\n    ipcMain.handle('module-discovery:get-categories', async (event) => {\n        try {\n            const service = getEnhancedModuleDiscoveryService();\n            const categories = service.getCategories();\n            return { success: true, categories };\n        }\n        catch (error) {\n            return { success: false, error: error.message, categories: [] };\n        }\n    });\n}\n","/**\n * Enhanced PowerShell Module Discovery Service\n *\n * Automatically discovers and catalogs PowerShell scripts and modules\n * from the Scripts directory structure.\n *\n * Pattern from GUI/Services/ModuleDiscoveryService.cs\n */\nimport * as fs from 'fs';\nimport * as path from 'path';\n/**\n * Enhanced Module Discovery Service\n */\nexport class EnhancedModuleDiscoveryService {\n    modulesCache = new Map();\n    lastScanTime = null;\n    /**\n     * Discover all PowerShell modules in the Scripts directory\n     */\n    async discoverModules(scriptsRoot) {\n        console.log(`[ModuleDiscovery] Scanning scripts directory: ${scriptsRoot}`);\n        const modules = [];\n        try {\n            if (!fs.existsSync(scriptsRoot)) {\n                console.warn(`[ModuleDiscovery] Scripts directory not found: ${scriptsRoot}`);\n                return [];\n            }\n            // Scan Scripts directory structure\n            await this.scanDirectory(scriptsRoot, modules);\n            // Cache results\n            modules.forEach(module => {\n                this.modulesCache.set(module.id, module);\n            });\n            this.lastScanTime = new Date();\n            console.log(`[ModuleDiscovery] Discovered ${modules.length} modules`);\n            return modules;\n        }\n        catch (error) {\n            console.error(`[ModuleDiscovery] Discovery failed:`, error);\n            return [];\n        }\n    }\n    /**\n     * Recursively scan directory for PowerShell scripts\n     */\n    async scanDirectory(dirPath, modules, category) {\n        try {\n            const entries = await fs.promises.readdir(dirPath, { withFileTypes: true });\n            for (const entry of entries) {\n                const fullPath = path.join(dirPath, entry.name);\n                if (entry.isDirectory()) {\n                    // Use directory name as category\n                    await this.scanDirectory(fullPath, modules, entry.name);\n                }\n                else if (entry.isFile() && (entry.name.endsWith('.ps1') || entry.name.endsWith('.psm1'))) {\n                    // Parse PowerShell script\n                    const module = await this.parseModule(fullPath, category || 'General');\n                    if (module) {\n                        modules.push(module);\n                    }\n                }\n            }\n        }\n        catch (error) {\n            console.error(`[ModuleDiscovery] Failed to scan directory ${dirPath}:`, error);\n        }\n    }\n    /**\n     * Parse PowerShell script metadata and parameters\n     */\n    async parseModule(scriptPath, category) {\n        try {\n            const content = await fs.promises.readFile(scriptPath, 'utf8');\n            // Extract module metadata from comments\n            const metadata = this.extractMetadata(content);\n            const parameters = await this.extractParameters(scriptPath, content);\n            const moduleName = path.basename(scriptPath, path.extname(scriptPath));\n            const moduleId = `${category.toLowerCase()}-${moduleName.toLowerCase()}`;\n            return {\n                id: moduleId,\n                name: metadata.name || moduleName,\n                path: scriptPath,\n                category,\n                description: metadata.description || '',\n                parameters,\n                dependencies: metadata.dependencies || [],\n                version: metadata.version,\n                author: metadata.author\n            };\n        }\n        catch (error) {\n            console.error(`[ModuleDiscovery] Failed to parse module ${scriptPath}:`, error);\n            return null;\n        }\n    }\n    /**\n     * Extract metadata from PowerShell script comments\n     */\n    extractMetadata(content) {\n        const metadata = {};\n        // Look for .SYNOPSIS, .DESCRIPTION, etc. in help comments\n        const synopsisMatch = content.match(/\\.SYNOPSIS\\s+(.*?)(?=\\.|$)/is);\n        if (synopsisMatch) {\n            metadata.description = synopsisMatch[1].trim();\n        }\n        const descriptionMatch = content.match(/\\.DESCRIPTION\\s+(.*?)(?=\\.|$)/is);\n        if (descriptionMatch) {\n            metadata.description = descriptionMatch[1].trim();\n        }\n        const versionMatch = content.match(/\\.VERSION\\s+(\\S+)/i);\n        if (versionMatch) {\n            metadata.version = versionMatch[1].trim();\n        }\n        const authorMatch = content.match(/\\.AUTHOR\\s+(.*?)(?=\\n|$)/i);\n        if (authorMatch) {\n            metadata.author = authorMatch[1].trim();\n        }\n        // Look for #Requires statements for dependencies\n        const requiresMatches = content.matchAll(/#Requires\\s+-Modules\\s+([^\\n]+)/gi);\n        metadata.dependencies = [];\n        for (const match of requiresMatches) {\n            const modules = match[1].split(',').map(m => m.trim());\n            metadata.dependencies.push(...modules);\n        }\n        return metadata;\n    }\n    /**\n     * Extract parameters using PowerShell Get-Help\n     */\n    async extractParameters(scriptPath, content) {\n        const parameters = [];\n        // Parse param block from script\n        const paramBlockMatch = content.match(/param\\s*\\(([\\s\\S]*?)\\)/i);\n        if (!paramBlockMatch) {\n            return parameters;\n        }\n        const paramBlock = paramBlockMatch[1];\n        // Extract individual parameters\n        const paramMatches = paramBlock.matchAll(/\\[Parameter[^\\]]*\\]\\s*\\[(\\w+)\\]\\s*\\$(\\w+)\\s*=?\\s*([^,\\n]*)/gi);\n        for (const match of paramMatches) {\n            const type = match[1];\n            const name = match[2];\n            const defaultValue = match[3]?.trim();\n            parameters.push({\n                name,\n                type,\n                required: /Mandatory\\s*=\\s*\\$true/i.test(match[0]),\n                defaultValue: defaultValue || undefined,\n                description: undefined\n            });\n        }\n        return parameters;\n    }\n    /**\n     * Get module by ID\n     */\n    getModule(moduleId) {\n        return this.modulesCache.get(moduleId) || null;\n    }\n    /**\n     * Get all modules\n     */\n    getAllModules() {\n        return Array.from(this.modulesCache.values());\n    }\n    /**\n     * Get modules by category\n     */\n    getModulesByCategory(category) {\n        return Array.from(this.modulesCache.values()).filter(m => m.category.toLowerCase() === category.toLowerCase());\n    }\n    /**\n     * Search modules by name or description\n     */\n    searchModules(query) {\n        const lowerQuery = query.toLowerCase();\n        return Array.from(this.modulesCache.values()).filter(m => m.name.toLowerCase().includes(lowerQuery) ||\n            m.description.toLowerCase().includes(lowerQuery));\n    }\n    /**\n     * Get discovery statistics\n     */\n    getStatistics() {\n        return {\n            totalModules: this.modulesCache.size,\n            lastScanTime: this.lastScanTime,\n            categories: Array.from(new Set(Array.from(this.modulesCache.values()).map(m => m.category)))\n        };\n    }\n    /**\n     * Clear cache\n     */\n    clearCache() {\n        this.modulesCache.clear();\n        this.lastScanTime = null;\n    }\n}\n// Singleton instance\nlet enhancedModuleDiscoveryService = null;\nexport function getEnhancedModuleDiscoveryService() {\n    if (!enhancedModuleDiscoveryService) {\n        enhancedModuleDiscoveryService = new EnhancedModuleDiscoveryService();\n    }\n    return enhancedModuleDiscoveryService;\n}\nexport default EnhancedModuleDiscoveryService;\n"],"names":["registerModuleDiscoveryHandlers","ipcMain","handle","async","event","service","getEnhancedModuleDiscoveryService","scriptsRoot","process","env","SCRIPTS_ROOT","__dirname","success","modules","discoverModules","error","message","moduleId","module","getModuleById","query","searchModules","category","getModulesByCategory","categories","getCategories","EnhancedModuleDiscoveryService","modulesCache","Map","lastScanTime","console","log","this","scanDirectory","forEach","set","id","Date","length","warn","dirPath","entries","readdir","withFileTypes","entry","fullPath","name","isDirectory","isFile","endsWith","parseModule","push","scriptPath","content","readFile","metadata","extractMetadata","parameters","extractParameters","moduleName","toLowerCase","path","description","dependencies","version","author","synopsisMatch","match","trim","descriptionMatch","versionMatch","authorMatch","requiresMatches","matchAll","split","map","m","paramBlockMatch","paramMatches","type","defaultValue","required","test","undefined","getModule","get","getAllModules","Array","from","values","filter","lowerQuery","includes","getStatistics","totalModules","size","Set","clearCache","clear","enhancedModuleDiscoveryService"],"sourceRoot":""}