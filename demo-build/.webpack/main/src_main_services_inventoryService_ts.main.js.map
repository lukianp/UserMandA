{"version":3,"file":"src_main_services_inventoryService_ts.main.js","mappings":"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","sources":["webpack://enterprise-discovery-suite/./src/main/services/inventoryService.ts"],"sourcesContent":["/**\n * Inventory Service (Backend)\n *\n * Manages consolidated inventory consolidation pipeline.\n * Reads raw discovery CSVs and builds canonical entities with evidence and relations.\n */\nimport * as path from 'path';\nimport * as fs from 'fs/promises';\nimport { app } from 'electron';\nimport { Low } from 'lowdb';\nimport { JSONFile } from 'lowdb/node';\nimport * as Papa from 'papaparse';\nexport class InventoryService {\n    db;\n    isInitialized = false;\n    inventoryPath;\n    dataRootPath;\n    constructor() {\n        this.inventoryPath = path.join(app.getPath('appData'), 'MandADiscoverySuite', 'inventory.json');\n        this.dataRootPath =\n            process.env.MANDA_DISCOVERY_PATH ||\n                (process.platform === 'win32'\n                    ? path.join('C:', 'DiscoveryData')\n                    : path.join(app.getPath('userData'), 'DiscoveryData'));\n    }\n    async initialize() {\n        if (this.isInitialized)\n            return;\n        await fs.mkdir(path.dirname(this.inventoryPath), { recursive: true });\n        const adapter = new JSONFile(this.inventoryPath);\n        this.db = new Low(adapter, { entities: [], evidence: {}, relations: {}, version: 1 });\n        await this.db.read();\n        this.ensureData();\n        this.isInitialized = true;\n    }\n    ensureData() {\n        if (!this.db.data) {\n            this.db.data = { entities: [], evidence: {}, relations: {}, version: 1 };\n        }\n        if (!this.db.data.entities) {\n            this.db.data.entities = [];\n        }\n        if (!this.db.data.evidence) {\n            this.db.data.evidence = {};\n        }\n        if (!this.db.data.relations) {\n            this.db.data.relations = {};\n        }\n        if (!this.db.data.version) {\n            this.db.data.version = 1;\n        }\n    }\n    // ============================================================================\n    // DEDUPLICATION & CONFLICT DETECTION\n    // ============================================================================\n    /**\n     * Determine which merge key to use for a user record\n     * Priority: GUID > UPN > EMAIL > SAMACCOUNTNAME > DISPLAYNAME\n     */\n    determineUserMergeKey(record) {\n        if (record.id || record.objectId) {\n            return { key: 'GUID', value: record.id || record.objectId };\n        }\n        if (record.userPrincipalName) {\n            return { key: 'UPN', value: record.userPrincipalName.toLowerCase() };\n        }\n        if (record.mail || record.email) {\n            return { key: 'EMAIL', value: (record.mail || record.email).toLowerCase() };\n        }\n        if (record.samAccountName) {\n            return { key: 'SAMACCOUNTNAME', value: record.samAccountName.toLowerCase() };\n        }\n        if (record.displayName) {\n            return { key: 'DISPLAYNAME', value: record.displayName.toLowerCase() };\n        }\n        return null;\n    }\n    /**\n     * Merge attributes from multiple sources with conflict detection\n     */\n    mergeUserAttributes(existingEntity, newRecord, moduleName) {\n        const attributesToCheck = ['displayName', 'mail', 'userPrincipalName', 'samAccountName'];\n        for (const attr of attributesToCheck) {\n            const existingValue = existingEntity.externalIds[attr] || existingEntity[attr];\n            const newValue = newRecord[attr];\n            if (newValue && existingValue && existingValue !== newValue) {\n                // Conflict detected!\n                this.recordConflict(existingEntity, attr, existingValue, newValue, moduleName);\n            }\n            else if (newValue && !existingValue) {\n                // Enrich with new data\n                if (attr === 'displayName') {\n                    existingEntity.displayName = newValue;\n                }\n                else {\n                    existingEntity.externalIds[attr] = newValue;\n                }\n            }\n        }\n        existingEntity.updatedAt = new Date();\n    }\n    /**\n     * Record a conflict between sources\n     */\n    recordConflict(entity, attributeName, existingValue, newValue, newSource) {\n        if (!entity.conflicts) {\n            entity.conflicts = {};\n        }\n        if (!entity.conflicts[attributeName]) {\n            // First conflict for this attribute\n            entity.conflicts[attributeName] = {\n                sources: ['EXISTING', newSource],\n                values: {\n                    EXISTING: existingValue,\n                    [newSource]: newValue,\n                },\n                resolvedValue: existingValue, // Default to existing value\n                resolvedBy: 'SYSTEM',\n                resolvedAt: new Date(),\n                severity: this.determineConflictSeverity(attributeName),\n            };\n        }\n        else {\n            // Additional conflict\n            const conflict = entity.conflicts[attributeName];\n            if (!conflict.sources.includes(newSource)) {\n                conflict.sources.push(newSource);\n                conflict.values[newSource] = newValue;\n            }\n        }\n    }\n    /**\n     * Determine conflict severity based on attribute importance\n     */\n    determineConflictSeverity(attributeName) {\n        const highSeverityAttrs = ['userPrincipalName', 'mail', 'objectId', 'id'];\n        const mediumSeverityAttrs = ['displayName', 'samAccountName', 'department', 'manager'];\n        if (highSeverityAttrs.includes(attributeName))\n            return 'HIGH';\n        if (mediumSeverityAttrs.includes(attributeName))\n            return 'MEDIUM';\n        return 'LOW';\n    }\n    /**\n     * Calculate Levenshtein distance for fuzzy matching\n     */\n    levenshteinDistance(str1, str2) {\n        const matrix = [];\n        for (let i = 0; i <= str2.length; i++) {\n            matrix[i] = [i];\n        }\n        for (let j = 0; j <= str1.length; j++) {\n            matrix[0][j] = j;\n        }\n        for (let i = 1; i <= str2.length; i++) {\n            for (let j = 1; j <= str1.length; j++) {\n                if (str2.charAt(i - 1) === str1.charAt(j - 1)) {\n                    matrix[i][j] = matrix[i - 1][j - 1];\n                }\n                else {\n                    matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, matrix[i][j - 1] + 1, matrix[i - 1][j] + 1);\n                }\n            }\n        }\n        return matrix[str2.length][str1.length];\n    }\n    /**\n     * Apply fuzzy matching to find potential duplicates\n     */\n    applyFuzzyMatching(entities, threshold = 3) {\n        const deduped = [];\n        const processed = new Set();\n        for (const entity of entities) {\n            if (processed.has(entity.id))\n                continue;\n            let isDuplicate = false;\n            for (const existing of deduped) {\n                if (existing.entityType !== entity.entityType)\n                    continue;\n                const distance = this.levenshteinDistance(existing.displayName.toLowerCase(), entity.displayName.toLowerCase());\n                if (distance <= threshold) {\n                    // Potential duplicate found - merge\n                    this.mergeUserAttributes(existing, entity.externalIds, 'FUZZY_MATCH');\n                    processed.add(entity.id);\n                    isDuplicate = true;\n                    break;\n                }\n            }\n            if (!isDuplicate) {\n                deduped.push(entity);\n                processed.add(entity.id);\n            }\n        }\n        console.log(`[InventoryService] Fuzzy matching reduced ${entities.length} to ${deduped.length} entities`);\n        return deduped;\n    }\n    // ============================================================================\n    // CONSOLIDATION PIPELINE\n    // ============================================================================\n    /**\n     * Main consolidation pipeline\n     * Reads raw discovery CSV files and builds consolidated inventory\n     */\n    async rebuildInventory(sourceProfileId) {\n        console.log(`[InventoryService] Starting consolidation for profile: ${sourceProfileId}`);\n        try {\n            // Clear existing inventory for this profile\n            await this.clearInventoryForProfile(sourceProfileId);\n            // Phase 1: Load discovery CSVs\n            const discoveryData = await this.loadDiscoveryFiles(sourceProfileId);\n            // Phase 2: Create canonical entities\n            const entities = await this.consolidateEntities(sourceProfileId, discoveryData);\n            // Phase 3: Create evidence links\n            const evidence = await this.createEvidence(sourceProfileId, entities, discoveryData);\n            // Phase 4: Build relations\n            const relations = await this.buildRelations(sourceProfileId, entities, discoveryData);\n            // Phase 5: Calculate readiness and risk scores\n            await this.calculateScores(entities, evidence, relations);\n            // Phase 6: Persist to database\n            await this.saveInventory(sourceProfileId, entities, evidence, relations);\n            console.log(`[InventoryService] Consolidation complete. Total entities: ${entities.length}`);\n            return { entities, evidence, relations };\n        }\n        catch (error) {\n            console.error('[InventoryService] Consolidation failed:', error);\n            throw error;\n        }\n    }\n    /**\n     * Load all discovery CSV files for a profile\n     */\n    async loadDiscoveryFiles(sourceProfileId) {\n        const profilePath = path.join(this.dataRootPath, sourceProfileId, 'Raw');\n        // Normalize record keys to camelCase for consistent access\n        const normalizeRecord = (record) => {\n            const normalized = {};\n            for (const key of Object.keys(record)) {\n                // Convert PascalCase to camelCase (first letter lowercase)\n                const camelKey = key.charAt(0).toLowerCase() + key.slice(1);\n                normalized[camelKey] = record[key];\n                // Also keep original key for backwards compatibility\n                normalized[key] = record[key];\n            }\n            return normalized;\n        };\n        const loadCsv = async (filename) => {\n            const filePath = path.join(profilePath, filename);\n            try {\n                const fileContent = await fs.readFile(filePath, 'utf-8');\n                const parsed = Papa.parse(fileContent, {\n                    header: true,\n                    skipEmptyLines: true,\n                    dynamicTyping: true,\n                });\n                console.log(`[InventoryService] ✅ Loaded ${parsed.data.length} records from ${filename}`);\n                // Normalize all records to have camelCase keys\n                return parsed.data.map(normalizeRecord);\n            }\n            catch (error) {\n                console.warn(`[InventoryService] Could not load ${filename}:`, error);\n                return [];\n            }\n        };\n        const loadMultipleCsvs = async (filenames) => {\n            const allRecords = [];\n            for (const filename of filenames) {\n                const records = await loadCsv(filename);\n                allRecords.push(...records);\n            }\n            return allRecords;\n        };\n        return {\n            entraUsers: await loadMultipleCsvs(['GraphUsers.csv', 'AzureDiscovery_Users.csv']),\n            entraGroups: await loadMultipleCsvs(['GraphGroups.csv', 'AzureDiscovery_Groups.csv', 'ExchangeDistributionGroups.csv']),\n            azureResources: await loadMultipleCsvs(['AzureResourceDiscovery_ResourceGroups.csv', 'AzureResourceDiscovery_NetworkSecurityGroups.csv']),\n            applications: await loadMultipleCsvs(['EntraIDAppRegistrations.csv', 'EntraIDEnterpriseApps.csv', 'AzureDiscovery_Applications.csv']),\n            infrastructure: await loadCsv('SecurityInfrastructureDiscovery.csv'),\n        };\n    }\n    /**\n     * Load discovery CSV files in chunks for large files\n     * Uses streaming to process 1000 rows at a time\n     */\n    async loadDiscoveryDataChunked(sourceProfileId, onChunk) {\n        const profilePath = path.join(this.dataRootPath, sourceProfileId, 'Raw');\n        const files = [\n            'GraphUsers.csv',\n            'AzureDiscovery_Users.csv',\n            'GraphGroups.csv',\n            'AzureDiscovery_Groups.csv',\n            'ExchangeDistributionGroups.csv',\n            'EntraIDAppRegistrations.csv',\n            'EntraIDEnterpriseApps.csv',\n            'AzureDiscovery_Applications.csv',\n            'AzureResourceDiscovery_ResourceGroups.csv',\n            'AzureResourceDiscovery_NetworkSecurityGroups.csv',\n            'SecurityInfrastructureDiscovery.csv',\n        ];\n        for (const filename of files) {\n            const filePath = path.join(profilePath, filename);\n            try {\n                const fileContent = await fs.readFile(filePath, 'utf-8');\n                let chunk = [];\n                const chunkSize = 1000;\n                await new Promise((resolve, reject) => {\n                    Papa.parse(fileContent, {\n                        header: true,\n                        skipEmptyLines: true,\n                        dynamicTyping: true,\n                        chunk: async (results, parser) => {\n                            // Pause parsing while we process chunk\n                            parser.pause();\n                            chunk.push(...results.data);\n                            if (chunk.length >= chunkSize) {\n                                try {\n                                    await onChunk(chunk, filename);\n                                    chunk = [];\n                                }\n                                catch (error) {\n                                    reject(error);\n                                    return;\n                                }\n                            }\n                            parser.resume();\n                        },\n                        complete: async () => {\n                            // Process remaining chunk\n                            if (chunk.length > 0) {\n                                try {\n                                    await onChunk(chunk, filename);\n                                }\n                                catch (error) {\n                                    reject(error);\n                                    return;\n                                }\n                            }\n                            resolve();\n                        },\n                        error: (error) => {\n                            reject(error);\n                        },\n                    });\n                });\n                console.log(`[InventoryService] Completed chunked loading of ${filename}`);\n            }\n            catch (error) {\n                console.warn(`[InventoryService] Could not load ${filename}:`, error);\n            }\n        }\n    }\n    /**\n     * Consolidate raw discovery data into canonical entities\n     */\n    async consolidateEntities(sourceProfileId, discoveryData) {\n        const entities = [];\n        const mergeKeyIndex = new Map();\n        // USER entities from Entra ID with sophisticated deduplication\n        for (const record of discoveryData.entraUsers) {\n            const mergeKeyData = this.determineUserMergeKey(record);\n            if (!mergeKeyData) {\n                console.warn('[InventoryService] Skipping user record with no valid merge key:', record);\n                continue;\n            }\n            const mergeKeyValue = `${mergeKeyData.key}:${mergeKeyData.value}`;\n            const existingEntity = mergeKeyIndex.get(mergeKeyValue);\n            if (existingEntity) {\n                // Merge with existing entity and detect conflicts\n                this.mergeUserAttributes(existingEntity, record, 'ENTRA_USERS');\n            }\n            else {\n                // Create new entity\n                const newEntity = {\n                    id: this.generateUUID(),\n                    sourceProfileId,\n                    entityType: 'USER',\n                    displayName: record.displayName || record.userPrincipalName || 'Unknown User',\n                    externalIds: {\n                        objectId: record.id || record.objectId,\n                        upn: record.userPrincipalName,\n                        mail: record.mail || record.userPrincipalName,\n                        samAccountName: record.samAccountName,\n                    },\n                    status: 'DISCOVERED',\n                    createdAt: new Date(),\n                    updatedAt: new Date(),\n                };\n                entities.push(newEntity);\n                mergeKeyIndex.set(mergeKeyValue, newEntity);\n            }\n        }\n        // GROUP entities from Entra ID\n        for (const record of discoveryData.entraGroups) {\n            entities.push({\n                id: this.generateUUID(),\n                sourceProfileId,\n                entityType: 'GROUP',\n                displayName: record.displayName || 'Unknown Group',\n                externalIds: {\n                    objectId: record.id || record.objectId,\n                },\n                status: 'DISCOVERED',\n                createdAt: new Date(),\n                updatedAt: new Date(),\n            });\n        }\n        // APPLICATION entities from Azure and discovery\n        for (const record of [...discoveryData.azureResources, ...discoveryData.applications]) {\n            if (record.resourceType === 'Application' ||\n                record.resourceType === 'ServicePrincipal' ||\n                record.type === 'Application') {\n                entities.push({\n                    id: this.generateUUID(),\n                    sourceProfileId,\n                    entityType: 'APPLICATION',\n                    displayName: record.displayName || record.name || 'Unknown Application',\n                    externalIds: {\n                        appId: record.appId,\n                        objectId: record.id || record.objectId,\n                    },\n                    status: 'DISCOVERED',\n                    createdAt: new Date(),\n                    updatedAt: new Date(),\n                });\n            }\n        }\n        // INFRASTRUCTURE entities from Azure resources\n        for (const record of [...discoveryData.azureResources, ...discoveryData.infrastructure]) {\n            if (['VirtualMachine', 'StorageAccount', 'ResourceGroup', 'NetworkInterface'].includes(record.resourceType || record.type)) {\n                entities.push({\n                    id: this.generateUUID(),\n                    sourceProfileId,\n                    entityType: 'INFRASTRUCTURE',\n                    displayName: record.name || record.displayName || 'Unknown Resource',\n                    externalIds: {\n                        resourceId: record.id,\n                        subscriptionId: record.subscriptionId,\n                        hostname: record.computerName || record.dnsName,\n                    },\n                    status: 'DISCOVERED',\n                    createdAt: new Date(),\n                    updatedAt: new Date(),\n                });\n            }\n        }\n        console.log(`[InventoryService] Created ${entities.length} entities: ${entities.filter((e) => e.entityType === 'USER').length} users, ${entities.filter((e) => e.entityType === 'GROUP').length} groups, ${entities.filter((e) => e.entityType === 'APPLICATION').length} apps, ${entities.filter((e) => e.entityType === 'INFRASTRUCTURE').length} infra`);\n        // Apply fuzzy matching for additional deduplication\n        const dedupedEntities = this.applyFuzzyMatching(entities, 3);\n        return dedupedEntities;\n    }\n    /**\n     * Create evidence links from discovery modules\n     */\n    async createEvidence(sourceProfileId, entities, discoveryData) {\n        const evidence = {};\n        // Link users to Entra evidence\n        for (const entity of entities.filter((e) => e.entityType === 'USER')) {\n            const sourceRecord = discoveryData.entraUsers.find((r) => r.id === entity.externalIds.objectId || r.userPrincipalName === entity.externalIds.upn);\n            if (sourceRecord) {\n                if (!evidence[entity.id])\n                    evidence[entity.id] = [];\n                evidence[entity.id].push({\n                    id: this.generateUUID(),\n                    inventoryEntityId: entity.id,\n                    module: 'ENTRA_USERS',\n                    sourceRecordRef: sourceRecord.id || sourceRecord.objectId,\n                    observedAt: new Date(),\n                    payloadSnapshot: sourceRecord,\n                });\n            }\n        }\n        // Link groups to Entra evidence\n        for (const entity of entities.filter((e) => e.entityType === 'GROUP')) {\n            const sourceRecord = discoveryData.entraGroups.find((r) => r.id === entity.externalIds.objectId);\n            if (sourceRecord) {\n                if (!evidence[entity.id])\n                    evidence[entity.id] = [];\n                evidence[entity.id].push({\n                    id: this.generateUUID(),\n                    inventoryEntityId: entity.id,\n                    module: 'ENTRA_GROUPS',\n                    sourceRecordRef: sourceRecord.id || sourceRecord.objectId,\n                    observedAt: new Date(),\n                    payloadSnapshot: sourceRecord,\n                });\n            }\n        }\n        // Link applications and infrastructure to Azure evidence\n        for (const entity of entities.filter((e) => e.entityType === 'APPLICATION' || e.entityType === 'INFRASTRUCTURE')) {\n            const sourceRecord = discoveryData.azureResources.find((r) => r.id === entity.externalIds.resourceId || r.appId === entity.externalIds.appId);\n            if (sourceRecord) {\n                if (!evidence[entity.id])\n                    evidence[entity.id] = [];\n                evidence[entity.id].push({\n                    id: this.generateUUID(),\n                    inventoryEntityId: entity.id,\n                    module: 'AZURE_RESOURCES',\n                    sourceRecordRef: sourceRecord.id,\n                    observedAt: new Date(),\n                    payloadSnapshot: sourceRecord,\n                });\n            }\n        }\n        console.log(`[InventoryService] Created evidence for ${Object.keys(evidence).length} entities`);\n        return evidence;\n    }\n    /**\n     * Build typed relationships between entities\n     */\n    async buildRelations(sourceProfileId, entities, discoveryData) {\n        const relations = {};\n        const addRelation = (fromEntityId, toEntityId, relationType, metadata) => {\n            const relation = {\n                id: this.generateUUID(),\n                sourceProfileId,\n                fromEntityId,\n                toEntityId,\n                relationType,\n                metadata,\n                createdAt: new Date(),\n            };\n            // Store bidirectionally for efficient lookups\n            if (!relations[fromEntityId])\n                relations[fromEntityId] = [];\n            if (!relations[toEntityId])\n                relations[toEntityId] = [];\n            relations[fromEntityId].push(relation);\n            relations[toEntityId].push(relation);\n        };\n        // Build USER → GROUP relations from group memberships\n        for (const groupRecord of discoveryData.entraGroups) {\n            const group = entities.find((e) => e.externalIds.objectId === groupRecord.id && e.entityType === 'GROUP');\n            if (group && groupRecord.members) {\n                const memberIds = Array.isArray(groupRecord.members)\n                    ? groupRecord.members\n                    : groupRecord.members.split(';');\n                for (const memberId of memberIds) {\n                    const user = entities.find((e) => (e.externalIds.objectId === memberId || e.externalIds.upn === memberId) && e.entityType === 'USER');\n                    if (user) {\n                        addRelation(user.id, group.id, 'MEMBER_OF_GROUP', { source: 'ENTRA_GROUPS' });\n                    }\n                }\n            }\n        }\n        // Build ownership relations for applications\n        for (const appRecord of [...discoveryData.azureResources, ...discoveryData.applications]) {\n            const app = entities.find((e) => (e.externalIds.appId === appRecord.appId || e.externalIds.objectId === appRecord.id) &&\n                e.entityType === 'APPLICATION');\n            if (app && appRecord.owners) {\n                const owners = Array.isArray(appRecord.owners) ? appRecord.owners : appRecord.owners.split(';');\n                for (const ownerId of owners) {\n                    const owner = entities.find((e) => (e.externalIds.objectId === ownerId || e.externalIds.upn === ownerId) &&\n                        (e.entityType === 'USER' || e.entityType === 'GROUP'));\n                    if (owner) {\n                        addRelation(owner.id, app.id, 'OWNS_APPLICATION', { source: 'AZURE_RESOURCES', role: 'owner' });\n                    }\n                }\n            }\n        }\n        console.log(`[InventoryService] Built relations for ${Object.keys(relations).length} entities`);\n        return relations;\n    }\n    /**\n     * Calculate readiness and risk scores for entities\n     */\n    async calculateScores(entities, evidence, relations) {\n        for (const entity of entities) {\n            let readinessScore = 0;\n            let riskScore = 0;\n            // Readiness factors\n            if (relations[entity.id]?.length > 0)\n                readinessScore += 0.3; // Has relationships\n            if (evidence[entity.id]?.length > 1)\n                readinessScore += 0.2; // Multiple evidence sources\n            if (Object.keys(entity.externalIds).length > 1)\n                readinessScore += 0.2; // Complete IDs\n            if (entity.status !== 'DISCOVERED')\n                readinessScore += 0.3; // Enriched/verified\n            // Risk factors\n            if (entity.entityType === 'APPLICATION') {\n                const owners = relations[entity.id]?.filter((r) => r.relationType === 'OWNS_APPLICATION' && r.toEntityId === entity.id) || [];\n                if (owners.length === 0)\n                    riskScore += 0.3; // No owners = risky\n            }\n            if (entity.entityType === 'USER') {\n                const groups = relations[entity.id]?.filter((r) => r.relationType === 'MEMBER_OF_GROUP' && r.fromEntityId === entity.id) || [];\n                if (groups.length === 0)\n                    riskScore += 0.2; // Orphaned user\n            }\n            if (!evidence[entity.id] || evidence[entity.id].length < 2) {\n                riskScore += 0.2; // Single source = less validated\n            }\n            entity.readinessScore = Math.min(readinessScore, 1.0);\n            entity.riskScore = Math.min(riskScore, 1.0);\n        }\n        console.log(`[InventoryService] Calculated scores for ${entities.length} entities`);\n    }\n    // ============================================================================\n    // PERSISTENCE\n    // ============================================================================\n    /**\n     * Save consolidated inventory to database\n     */\n    async saveInventory(sourceProfileId, entities, evidence, relations) {\n        await this.db.read();\n        this.ensureData();\n        // Add new entities\n        this.db.data.entities.push(...entities);\n        // Merge evidence\n        for (const [entityId, evidenceList] of Object.entries(evidence)) {\n            if (!this.db.data.evidence[entityId]) {\n                this.db.data.evidence[entityId] = [];\n            }\n            this.db.data.evidence[entityId].push(...evidenceList);\n        }\n        // Merge relations\n        for (const [entityId, relationList] of Object.entries(relations)) {\n            if (!this.db.data.relations[entityId]) {\n                this.db.data.relations[entityId] = [];\n            }\n            this.db.data.relations[entityId].push(...relationList);\n        }\n        await this.db.write();\n        console.log(`[InventoryService] Persisted inventory to database`);\n    }\n    /**\n     * Clear inventory for a specific profile\n     */\n    async clearInventoryForProfile(sourceProfileId) {\n        await this.db.read();\n        this.ensureData();\n        // Remove entities\n        this.db.data.entities = this.db.data.entities.filter((e) => e.sourceProfileId !== sourceProfileId);\n        // Remove evidence\n        const entityIds = this.db.data.entities.map((e) => e.id);\n        const newEvidence = {};\n        for (const [entityId, evidenceList] of Object.entries(this.db.data.evidence)) {\n            if (entityIds.includes(entityId)) {\n                newEvidence[entityId] = evidenceList;\n            }\n        }\n        this.db.data.evidence = newEvidence;\n        // Remove relations\n        const newRelations = {};\n        for (const [entityId, relationList] of Object.entries(this.db.data.relations)) {\n            const filtered = relationList.filter((r) => r.sourceProfileId !== sourceProfileId);\n            if (filtered.length > 0) {\n                newRelations[entityId] = filtered;\n            }\n        }\n        this.db.data.relations = newRelations;\n        await this.db.write();\n        console.log(`[InventoryService] Cleared inventory for profile: ${sourceProfileId}`);\n    }\n    // ============================================================================\n    // UTILITY METHODS\n    // ============================================================================\n    /**\n     * Generate a UUID\n     */\n    generateUUID() {\n        return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n    }\n    /**\n     * Get inventory statistics\n     */\n    async getStats(sourceProfileId) {\n        await this.db.read();\n        this.ensureData();\n        const entities = sourceProfileId\n            ? this.db.data.entities.filter((e) => e.sourceProfileId === sourceProfileId)\n            : this.db.data.entities;\n        const byType = {\n            USER: 0,\n            GROUP: 0,\n            APPLICATION: 0,\n            INFRASTRUCTURE: 0,\n        };\n        const byStatus = {\n            DISCOVERED: 0,\n            TRIAGED: 0,\n            VERIFIED: 0,\n            ENRICHED: 0,\n            MIGRATION_READY: 0,\n            MIGRATED: 0,\n        };\n        let totalReadiness = 0;\n        let totalRisk = 0;\n        let entitiesWithEvidence = 0;\n        let entitiesWithRelations = 0;\n        let entitiesAssignedToWaves = 0;\n        for (const entity of entities) {\n            byType[entity.entityType]++;\n            byStatus[entity.status]++;\n            if (entity.readinessScore)\n                totalReadiness += entity.readinessScore;\n            if (entity.riskScore)\n                totalRisk += entity.riskScore;\n            if (this.db.data.evidence[entity.id])\n                entitiesWithEvidence++;\n            if (this.db.data.relations[entity.id])\n                entitiesWithRelations++;\n            if (entity.waveId)\n                entitiesAssignedToWaves++;\n        }\n        return {\n            totalEntities: entities.length,\n            byType,\n            byStatus,\n            averageReadiness: entities.length > 0 ? totalReadiness / entities.length : 0,\n            averageRisk: entities.length > 0 ? totalRisk / entities.length : 0,\n            entitiesWithEvidence,\n            entitiesWithRelations,\n            entitiesAssignedToWaves,\n        };\n    }\n}\n// Export singleton instance\nlet inventoryServiceInstance = null;\nexport function getInventoryService() {\n    if (!inventoryServiceInstance) {\n        inventoryServiceInstance = new InventoryService();\n    }\n    return inventoryServiceInstance;\n}\n"],"names":["InventoryService","db","isInitialized","inventoryPath","dataRootPath","constructor","this","app","getPath","process","env","MANDA_DISCOVERY_PATH","platform","initialize","recursive","adapter","JSONFile","Low","entities","evidence","relations","version","read","ensureData","data","determineUserMergeKey","record","id","objectId","key","value","userPrincipalName","toLowerCase","mail","email","samAccountName","displayName","mergeUserAttributes","existingEntity","newRecord","moduleName","attributesToCheck","attr","existingValue","externalIds","newValue","recordConflict","updatedAt","Date","entity","attributeName","newSource","conflicts","conflict","sources","includes","push","values","EXISTING","resolvedValue","resolvedBy","resolvedAt","severity","determineConflictSeverity","levenshteinDistance","str1","str2","matrix","i","length","j","charAt","Math","min","applyFuzzyMatching","threshold","deduped","processed","Set","has","isDuplicate","existing","entityType","add","console","log","rebuildInventory","sourceProfileId","clearInventoryForProfile","discoveryData","loadDiscoveryFiles","consolidateEntities","createEvidence","buildRelations","calculateScores","saveInventory","error","profilePath","normalizeRecord","normalized","Object","keys","slice","loadCsv","async","filename","filePath","fileContent","parsed","header","skipEmptyLines","dynamicTyping","map","warn","loadMultipleCsvs","filenames","allRecords","records","entraUsers","entraGroups","azureResources","applications","infrastructure","loadDiscoveryDataChunked","onChunk","files","chunk","chunkSize","Promise","resolve","reject","results","parser","pause","resume","complete","mergeKeyIndex","Map","mergeKeyData","mergeKeyValue","get","newEntity","generateUUID","upn","status","createdAt","set","resourceType","type","name","appId","resourceId","subscriptionId","hostname","computerName","dnsName","filter","e","sourceRecord","find","r","inventoryEntityId","module","sourceRecordRef","observedAt","payloadSnapshot","addRelation","fromEntityId","toEntityId","relationType","metadata","relation","groupRecord","group","members","memberIds","Array","isArray","split","memberId","user","source","appRecord","owners","ownerId","owner","role","readinessScore","riskScore","entityId","evidenceList","entries","relationList","write","entityIds","newEvidence","newRelations","filtered","now","random","toString","substr","getStats","byType","USER","GROUP","APPLICATION","INFRASTRUCTURE","byStatus","DISCOVERED","TRIAGED","VERIFIED","ENRICHED","MIGRATION_READY","MIGRATED","totalReadiness","totalRisk","entitiesWithEvidence","entitiesWithRelations","entitiesAssignedToWaves","waveId","totalEntities","averageReadiness","averageRisk","inventoryServiceInstance","getInventoryService"],"sourceRoot":""}