{"version":3,"file":"src_main_ipcHandlers_waves_ts.main.js","mappings":"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","sources":["webpack://enterprise-discovery-suite/./src/main/ipcHandlers.waves.ts","webpack://enterprise-discovery-suite/./src/main/services/migrationService.ts"],"sourcesContent":["/**\n * Migration Wave IPC Handlers\n *\n * IPC handlers for migration wave CRUD operations including:\n * - Wave creation, update, deletion\n * - Entity wave assignments (single and batch)\n * - Wave summaries and statistics\n */\nimport { ipcMain } from 'electron';\nimport { getMigrationService } from './services/migrationService';\n/**\n * Register migration wave IPC handlers\n */\nexport function registerMigrationWaveHandlers() {\n    const service = getMigrationService();\n    // Initialize service\n    service.initialize().catch((error) => {\n        console.error('[WaveHandlers] Failed to initialize migration service:', error);\n    });\n    // ============================================================================\n    // WAVE CRUD OPERATIONS\n    // ============================================================================\n    /**\n     * Create a new migration wave\n     */\n    ipcMain.handle('wave:create', async (event, waveData) => {\n        try {\n            console.log(`[WaveHandlers] Creating wave: ${waveData.name}`);\n            const wave = await service.createWave(waveData);\n            return { success: true, data: wave };\n        }\n        catch (error) {\n            console.error('[WaveHandlers] Create wave failed:', error);\n            return { success: false, error: error.message };\n        }\n    });\n    /**\n     * Update an existing migration wave\n     */\n    ipcMain.handle('wave:update', async (event, waveId, updates) => {\n        try {\n            console.log(`[WaveHandlers] Updating wave: ${waveId}`);\n            const wave = await service.updateWave(waveId, updates);\n            if (!wave) {\n                return { success: false, error: `Wave not found: ${waveId}` };\n            }\n            return { success: true, data: wave };\n        }\n        catch (error) {\n            console.error('[WaveHandlers] Update wave failed:', error);\n            return { success: false, error: error.message };\n        }\n    });\n    /**\n     * Delete a migration wave\n     */\n    ipcMain.handle('wave:delete', async (event, waveId) => {\n        try {\n            console.log(`[WaveHandlers] Deleting wave: ${waveId}`);\n            const success = await service.deleteWave(waveId);\n            if (!success) {\n                return { success: false, error: `Wave not found: ${waveId}` };\n            }\n            return { success: true };\n        }\n        catch (error) {\n            console.error('[WaveHandlers] Delete wave failed:', error);\n            return { success: false, error: error.message };\n        }\n    });\n    /**\n     * Get a specific wave by ID\n     */\n    ipcMain.handle('wave:get', async (event, waveId) => {\n        try {\n            const wave = await service.getWave(waveId);\n            if (!wave) {\n                return { success: false, error: `Wave not found: ${waveId}` };\n            }\n            return { success: true, data: wave };\n        }\n        catch (error) {\n            console.error('[WaveHandlers] Get wave failed:', error);\n            return { success: false, error: error.message };\n        }\n    });\n    /**\n     * Get all waves for a profile\n     */\n    ipcMain.handle('wave:get-by-profile', async (event, sourceProfileId) => {\n        try {\n            const waves = await service.getWavesByProfile(sourceProfileId);\n            return { success: true, data: waves };\n        }\n        catch (error) {\n            console.error('[WaveHandlers] Get waves by profile failed:', error);\n            return { success: false, error: error.message };\n        }\n    });\n    /**\n     * Get all waves\n     */\n    ipcMain.handle('wave:get-all', async () => {\n        try {\n            const waves = await service.getAllWaves();\n            return { success: true, data: waves };\n        }\n        catch (error) {\n            console.error('[WaveHandlers] Get all waves failed:', error);\n            return { success: false, error: error.message };\n        }\n    });\n    // ============================================================================\n    // WAVE ASSIGNMENT OPERATIONS\n    // ============================================================================\n    /**\n     * Assign a single entity to a wave\n     */\n    ipcMain.handle('wave:assign-entity', async (event, waveId, inventoryEntityId, assignmentReason) => {\n        try {\n            console.log(`[WaveHandlers] Assigning entity ${inventoryEntityId} to wave ${waveId}`);\n            const assignment = await service.assignEntityToWave(waveId, inventoryEntityId, assignmentReason);\n            return { success: true, data: assignment };\n        }\n        catch (error) {\n            console.error('[WaveHandlers] Assign entity failed:', error);\n            return { success: false, error: error.message };\n        }\n    });\n    /**\n     * Assign multiple entities to a wave (batch operation)\n     */\n    ipcMain.handle('wave:assign-entities', async (event, waveId, inventoryEntityIds, assignmentReason) => {\n        try {\n            console.log(`[WaveHandlers] Batch assigning ${inventoryEntityIds.length} entities to wave ${waveId}`);\n            const assignments = await service.assignEntitiesToWave(waveId, inventoryEntityIds, assignmentReason);\n            return { success: true, data: assignments };\n        }\n        catch (error) {\n            console.error('[WaveHandlers] Batch assign entities failed:', error);\n            return { success: false, error: error.message };\n        }\n    });\n    /**\n     * Remove an entity from a wave\n     */\n    ipcMain.handle('wave:remove-entity', async (event, waveId, inventoryEntityId) => {\n        try {\n            console.log(`[WaveHandlers] Removing entity ${inventoryEntityId} from wave ${waveId}`);\n            const success = await service.removeEntityFromWave(waveId, inventoryEntityId);\n            if (!success) {\n                return { success: false, error: `Assignment not found` };\n            }\n            return { success: true };\n        }\n        catch (error) {\n            console.error('[WaveHandlers] Remove entity failed:', error);\n            return { success: false, error: error.message };\n        }\n    });\n    /**\n     * Get all assignments for a wave\n     */\n    ipcMain.handle('wave:get-assignments', async (event, waveId) => {\n        try {\n            const assignments = await service.getWaveAssignments(waveId);\n            return { success: true, data: assignments };\n        }\n        catch (error) {\n            console.error('[WaveHandlers] Get wave assignments failed:', error);\n            return { success: false, error: error.message };\n        }\n    });\n    /**\n     * Get wave assignment for a specific entity\n     */\n    ipcMain.handle('wave:get-entity-assignment', async (event, inventoryEntityId) => {\n        try {\n            const assignment = await service.getEntityWaveAssignment(inventoryEntityId);\n            return { success: true, data: assignment };\n        }\n        catch (error) {\n            console.error('[WaveHandlers] Get entity assignment failed:', error);\n            return { success: false, error: error.message };\n        }\n    });\n    // ============================================================================\n    // WAVE SUMMARY & STATISTICS\n    // ============================================================================\n    /**\n     * Get comprehensive wave summary with statistics\n     */\n    ipcMain.handle('wave:get-summary', async (event, waveId) => {\n        try {\n            const summary = await service.getWaveSummary(waveId);\n            if (!summary) {\n                return { success: false, error: `Wave not found: ${waveId}` };\n            }\n            return { success: true, data: summary };\n        }\n        catch (error) {\n            console.error('[WaveHandlers] Get wave summary failed:', error);\n            return { success: false, error: error.message };\n        }\n    });\n    console.log('[WaveHandlers] Migration wave IPC handlers registered');\n}\n","/**\n * Migration Service\n *\n * Manages migration waves with full CRUD operations, wave assignments,\n * and statistics tracking for the consolidated inventory layer.\n */\nimport * as path from 'path';\nimport * as fs from 'fs/promises';\nimport { app } from 'electron';\nimport { Low } from 'lowdb';\nimport { JSONFile } from 'lowdb/node';\nimport { getInventoryService } from './inventoryService';\nexport class MigrationService {\n    db;\n    isInitialized = false;\n    dbPath;\n    constructor() {\n        this.dbPath = path.join(app.getPath('appData'), 'MandADiscoverySuite', 'migration-waves.json');\n    }\n    async initialize() {\n        if (this.isInitialized)\n            return;\n        await fs.mkdir(path.dirname(this.dbPath), { recursive: true });\n        const adapter = new JSONFile(this.dbPath);\n        this.db = new Low(adapter, { waves: [], assignments: [], version: 1 });\n        await this.db.read();\n        this.ensureData();\n        this.isInitialized = true;\n    }\n    ensureData() {\n        if (!this.db.data) {\n            this.db.data = { waves: [], assignments: [], version: 1 };\n        }\n        if (!this.db.data.waves) {\n            this.db.data.waves = [];\n        }\n        if (!this.db.data.assignments) {\n            this.db.data.assignments = [];\n        }\n        if (!this.db.data.version) {\n            this.db.data.version = 1;\n        }\n    }\n    // ============================================================================\n    // WAVE CRUD OPERATIONS\n    // ============================================================================\n    /**\n     * Create a new migration wave\n     */\n    async createWave(wave) {\n        await this.db.read();\n        this.ensureData();\n        const newWave = {\n            id: this.generateUUID(),\n            ...wave,\n            createdAt: new Date(),\n            updatedAt: new Date(),\n        };\n        this.db.data.waves.push(newWave);\n        await this.db.write();\n        console.log(`[MigrationService] Created wave: ${newWave.name} (${newWave.id})`);\n        return newWave;\n    }\n    /**\n     * Update an existing migration wave\n     */\n    async updateWave(waveId, updates) {\n        await this.db.read();\n        this.ensureData();\n        const waveIndex = this.db.data.waves.findIndex((w) => w.id === waveId);\n        if (waveIndex === -1) {\n            console.warn(`[MigrationService] Wave not found: ${waveId}`);\n            return null;\n        }\n        const updatedWave = {\n            ...this.db.data.waves[waveIndex],\n            ...updates,\n            id: waveId, // Prevent ID change\n            updatedAt: new Date(),\n        };\n        this.db.data.waves[waveIndex] = updatedWave;\n        await this.db.write();\n        console.log(`[MigrationService] Updated wave: ${waveId}`);\n        return updatedWave;\n    }\n    /**\n     * Delete a migration wave and all its assignments\n     */\n    async deleteWave(waveId) {\n        await this.db.read();\n        this.ensureData();\n        const initialLength = this.db.data.waves.length;\n        this.db.data.waves = this.db.data.waves.filter((w) => w.id !== waveId);\n        if (this.db.data.waves.length === initialLength) {\n            console.warn(`[MigrationService] Wave not found: ${waveId}`);\n            return false;\n        }\n        // Remove all assignments for this wave\n        this.db.data.assignments = this.db.data.assignments.filter((a) => a.waveId !== waveId);\n        await this.db.write();\n        console.log(`[MigrationService] Deleted wave: ${waveId}`);\n        return true;\n    }\n    /**\n     * Get a specific wave by ID\n     */\n    async getWave(waveId) {\n        await this.db.read();\n        this.ensureData();\n        return this.db.data.waves.find((w) => w.id === waveId) || null;\n    }\n    /**\n     * Get all waves for a profile\n     */\n    async getWavesByProfile(sourceProfileId) {\n        await this.db.read();\n        this.ensureData();\n        return this.db.data.waves.filter((w) => w.sourceProfileId === sourceProfileId);\n    }\n    /**\n     * Get all waves\n     */\n    async getAllWaves() {\n        await this.db.read();\n        this.ensureData();\n        return [...this.db.data.waves];\n    }\n    // ============================================================================\n    // WAVE ASSIGNMENT OPERATIONS\n    // ============================================================================\n    /**\n     * Assign a single entity to a wave\n     */\n    async assignEntityToWave(waveId, inventoryEntityId, assignmentReason) {\n        await this.db.read();\n        this.ensureData();\n        // Check if wave exists\n        const wave = this.db.data.waves.find((w) => w.id === waveId);\n        if (!wave) {\n            throw new Error(`Wave not found: ${waveId}`);\n        }\n        // Check if assignment already exists\n        const existing = this.db.data.assignments.find((a) => a.waveId === waveId && a.inventoryEntityId === inventoryEntityId);\n        if (existing) {\n            console.warn(`[MigrationService] Entity already assigned to wave: ${inventoryEntityId}`);\n            return existing;\n        }\n        const assignment = {\n            id: this.generateUUID(),\n            waveId,\n            inventoryEntityId,\n            assignmentReason,\n            createdAt: new Date(),\n        };\n        this.db.data.assignments.push(assignment);\n        await this.db.write();\n        console.log(`[MigrationService] Assigned entity ${inventoryEntityId} to wave ${waveId}`);\n        return assignment;\n    }\n    /**\n     * Assign multiple entities to a wave (batch operation)\n     */\n    async assignEntitiesToWave(waveId, inventoryEntityIds, assignmentReason) {\n        await this.db.read();\n        this.ensureData();\n        // Check if wave exists\n        const wave = this.db.data.waves.find((w) => w.id === waveId);\n        if (!wave) {\n            throw new Error(`Wave not found: ${waveId}`);\n        }\n        const assignments = [];\n        const existingEntityIds = new Set(this.db.data.assignments.filter((a) => a.waveId === waveId).map((a) => a.inventoryEntityId));\n        for (const entityId of inventoryEntityIds) {\n            if (!existingEntityIds.has(entityId)) {\n                const assignment = {\n                    id: this.generateUUID(),\n                    waveId,\n                    inventoryEntityId: entityId,\n                    assignmentReason,\n                    createdAt: new Date(),\n                };\n                assignments.push(assignment);\n                this.db.data.assignments.push(assignment);\n            }\n            else {\n                console.warn(`[MigrationService] Entity ${entityId} already assigned to wave`);\n            }\n        }\n        await this.db.write();\n        console.log(`[MigrationService] Assigned ${assignments.length} entities to wave ${waveId}`);\n        return assignments;\n    }\n    /**\n     * Remove an entity assignment from a wave\n     */\n    async removeEntityFromWave(waveId, inventoryEntityId) {\n        await this.db.read();\n        this.ensureData();\n        const initialLength = this.db.data.assignments.length;\n        this.db.data.assignments = this.db.data.assignments.filter((a) => !(a.waveId === waveId && a.inventoryEntityId === inventoryEntityId));\n        if (this.db.data.assignments.length === initialLength) {\n            console.warn(`[MigrationService] Assignment not found: ${inventoryEntityId} in wave ${waveId}`);\n            return false;\n        }\n        await this.db.write();\n        console.log(`[MigrationService] Removed entity ${inventoryEntityId} from wave ${waveId}`);\n        return true;\n    }\n    /**\n     * Get all assignments for a wave\n     */\n    async getWaveAssignments(waveId) {\n        await this.db.read();\n        this.ensureData();\n        return this.db.data.assignments.filter((a) => a.waveId === waveId);\n    }\n    /**\n     * Get wave assignment for a specific entity\n     */\n    async getEntityWaveAssignment(inventoryEntityId) {\n        await this.db.read();\n        this.ensureData();\n        return this.db.data.assignments.find((a) => a.inventoryEntityId === inventoryEntityId) || null;\n    }\n    // ============================================================================\n    // WAVE SUMMARY & STATISTICS\n    // ============================================================================\n    /**\n     * Get comprehensive wave summary with statistics\n     */\n    async getWaveSummary(waveId) {\n        const wave = await this.getWave(waveId);\n        if (!wave) {\n            return null;\n        }\n        const assignments = await this.getWaveAssignments(waveId);\n        const inventoryService = getInventoryService();\n        await inventoryService.initialize();\n        const entityCounts = {\n            USER: 0,\n            GROUP: 0,\n            APPLICATION: 0,\n            INFRASTRUCTURE: 0,\n        };\n        let totalReadiness = 0;\n        let entitiesWithReadiness = 0;\n        const blockers = [];\n        // This is a simplified version - in production, we'd fetch entities from inventoryService\n        // For now, we're just counting assignments\n        // TODO: Integrate with InventoryService to fetch actual entities\n        return {\n            waveId,\n            entityCounts,\n            readinessAverage: entitiesWithReadiness > 0 ? totalReadiness / entitiesWithReadiness : 0,\n            blockers,\n            totalEntities: assignments.length,\n        };\n    }\n    // ============================================================================\n    // UTILITY METHODS\n    // ============================================================================\n    /**\n     * Generate a UUID\n     */\n    generateUUID() {\n        return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n    }\n}\n// Export singleton instance\nlet migrationServiceInstance = null;\nexport function getMigrationService() {\n    if (!migrationServiceInstance) {\n        migrationServiceInstance = new MigrationService();\n    }\n    return migrationServiceInstance;\n}\n"],"names":["registerMigrationWaveHandlers","service","getMigrationService","initialize","catch","error","console","ipcMain","handle","async","event","waveData","log","name","success","data","createWave","message","waveId","updates","wave","updateWave","deleteWave","getWave","sourceProfileId","getWavesByProfile","getAllWaves","inventoryEntityId","assignmentReason","assignEntityToWave","inventoryEntityIds","length","assignEntitiesToWave","removeEntityFromWave","getWaveAssignments","getEntityWaveAssignment","summary","getWaveSummary","MigrationService","db","isInitialized","dbPath","constructor","this","app","getPath","recursive","adapter","JSONFile","Low","waves","assignments","version","read","ensureData","newWave","id","generateUUID","createdAt","Date","updatedAt","push","write","waveIndex","findIndex","w","warn","updatedWave","initialLength","filter","a","find","Error","existing","assignment","existingEntityIds","Set","map","entityId","has","inventoryService","getInventoryService","entityCounts","USER","GROUP","APPLICATION","INFRASTRUCTURE","readinessAverage","blockers","totalEntities","now","Math","random","toString","substr","migrationServiceInstance"],"sourceRoot":""}