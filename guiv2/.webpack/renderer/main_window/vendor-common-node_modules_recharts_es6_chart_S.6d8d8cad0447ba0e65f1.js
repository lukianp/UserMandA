"use strict";
(global["webpackChunkguiv2"] = global["webpackChunkguiv2"] || []).push([[5471],{

/***/ 26435:
/*!**********************************************************!*\
  !*** ./node_modules/recharts/es6/chart/SunburstChart.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* unused harmony exports payloadSearcher, addToSunburstNodeIndex, SunburstChart */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ 96540);
/* harmony import */ var victory_vendor_d3_scale__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! victory-vendor/d3-scale */ 39625);
/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! clsx */ 34164);
/* harmony import */ var es_toolkit_compat_get__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! es-toolkit/compat/get */ 80305);
/* harmony import */ var es_toolkit_compat_get__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(es_toolkit_compat_get__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _container_Surface__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../container/Surface */ 49303);
/* harmony import */ var _container_Layer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../container/Layer */ 86069);
/* harmony import */ var _shape_Sector__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../shape/Sector */ 58522);
/* harmony import */ var _component_Text__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../component/Text */ 20261);
/* harmony import */ var _util_PolarUtils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/PolarUtils */ 14040);
/* harmony import */ var _context_chartLayoutContext__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../context/chartLayoutContext */ 19287);
/* harmony import */ var _context_tooltipPortalContext__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../context/tooltipPortalContext */ 74354);
/* harmony import */ var _RechartsWrapper__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./RechartsWrapper */ 41940);
/* harmony import */ var _state_tooltipSlice__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../state/tooltipSlice */ 74531);
/* harmony import */ var _state_SetTooltipEntrySettings__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../state/SetTooltipEntrySettings */ 59482);
/* harmony import */ var _state_RechartsStoreProvider__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../state/RechartsStoreProvider */ 11970);
/* harmony import */ var _state_hooks__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../state/hooks */ 49082);
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }

















var defaultTextProps = {
  fontWeight: 'bold',
  paintOrder: 'stroke fill',
  fontSize: '.75rem',
  stroke: '#FFF',
  fill: 'black',
  pointerEvents: 'none'
};
function getMaxDepthOf(node) {
  if (!node.children || node.children.length === 0) return 1;

  // Calculate depth for each child and find the maximum
  var childDepths = node.children.map(d => getMaxDepthOf(d));
  return 1 + Math.max(...childDepths);
}
function convertMapToRecord(map) {
  var record = {};
  map.forEach((value, key) => {
    record[key] = value;
  });
  return record;
}
function getTooltipEntrySettings(_ref) {
  var {
    dataKey,
    nameKey,
    data,
    stroke,
    fill,
    positions
  } = _ref;
  return {
    dataDefinedOnItem: data.children,
    // Redux store will not accept a Map because it's not serializable
    positions: convertMapToRecord(positions),
    // Sunburst does not support many of the properties as other charts do so there's plenty of defaults here
    settings: {
      stroke,
      strokeWidth: undefined,
      fill,
      nameKey,
      dataKey,
      // if there is a nameKey use it, otherwise make the name of the tooltip the dataKey itself
      name: nameKey ? undefined : dataKey,
      hide: false,
      type: undefined,
      color: fill,
      unit: ''
    }
  };
}

// Why is margin not a sunburst prop? No clue. Probably it should be
var defaultSunburstMargin = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0
};
var payloadSearcher = (data, activeIndex) => {
  return es_toolkit_compat_get__WEBPACK_IMPORTED_MODULE_3___default()(data, activeIndex);
};
var addToSunburstNodeIndex = function addToSunburstNodeIndex(indexInChildrenArr) {
  var activeTooltipIndexSoFar = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  return "".concat(activeTooltipIndexSoFar, "children[").concat(indexInChildrenArr, "]");
};
var preloadedState = {
  options: {
    validateTooltipEventTypes: ['item'],
    defaultTooltipEventType: 'item',
    chartName: 'Sunburst',
    tooltipPayloadSearcher: payloadSearcher,
    eventEmitter: undefined
  }
};
var SunburstChartImpl = _ref2 => {
  var {
    className,
    data,
    children,
    padding = 2,
    dataKey = 'value',
    nameKey = 'name',
    ringPadding = 2,
    innerRadius = 50,
    fill = '#333',
    stroke = '#FFF',
    textOptions = defaultTextProps,
    outerRadius: outerRadiusFromProps,
    cx: cxFromProps,
    cy: cyFromProps,
    startAngle = 0,
    endAngle = 360,
    onClick,
    onMouseEnter,
    onMouseLeave,
    responsive = false,
    style
  } = _ref2;
  var dispatch = useAppDispatch();
  var width = useChartWidth();
  var height = useChartHeight();
  var outerRadius = outerRadiusFromProps !== null && outerRadiusFromProps !== void 0 ? outerRadiusFromProps : Math.min(width, height) / 2;
  var cx = cxFromProps !== null && cxFromProps !== void 0 ? cxFromProps : width / 2;
  var cy = cyFromProps !== null && cyFromProps !== void 0 ? cyFromProps : height / 2;
  var rScale = scaleLinear([0, data[dataKey]], [0, endAngle]);
  var treeDepth = getMaxDepthOf(data);
  var thickness = (outerRadius - innerRadius) / treeDepth;
  var sectors = [];
  var positions = new Map([]);
  var [tooltipPortal, setTooltipPortal] = useState(null);
  // event handlers
  function handleMouseEnter(node, e) {
    if (onMouseEnter) onMouseEnter(node, e);
    dispatch(setActiveMouseOverItemIndex({
      activeIndex: node.tooltipIndex,
      activeDataKey: dataKey,
      activeCoordinate: positions.get(node.name)
    }));
  }
  function handleMouseLeave(node, e) {
    if (onMouseLeave) onMouseLeave(node, e);
    dispatch(mouseLeaveItem());
  }
  function handleClick(node) {
    if (onClick) onClick(node);
    dispatch(setActiveClickItemIndex({
      activeIndex: node.tooltipIndex,
      activeDataKey: dataKey,
      activeCoordinate: positions.get(node.name)
    }));
  }

  // recursively add nodes for each data point and its children
  function drawArcs(childNodes, options) {
    var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var {
      radius,
      innerR,
      initialAngle,
      childColor,
      nestedActiveTooltipIndex
    } = options;
    var currentAngle = initialAngle;
    if (!childNodes) return; // base case: no children of this node

    childNodes.forEach((d, i) => {
      var _ref3, _d$fill;
      var currentTooltipIndex = depth === 1 ? "[".concat(i, "]") : addToSunburstNodeIndex(i, nestedActiveTooltipIndex);
      var nodeWithIndex = _objectSpread(_objectSpread({}, d), {}, {
        tooltipIndex: currentTooltipIndex
      });
      var arcLength = rScale(d[dataKey]);
      var start = currentAngle;
      // color priority - if there's a color on the individual point use that, otherwise use parent color or default
      var fillColor = (_ref3 = (_d$fill = d === null || d === void 0 ? void 0 : d.fill) !== null && _d$fill !== void 0 ? _d$fill : childColor) !== null && _ref3 !== void 0 ? _ref3 : fill;
      var {
        x: textX,
        y: textY
      } = polarToCartesian(0, 0, innerR + radius / 2, -(start + arcLength - arcLength / 2));
      currentAngle += arcLength;
      sectors.push(
      /*#__PURE__*/
      // eslint-disable-next-line react/no-array-index-key
      React.createElement("g", {
        key: "sunburst-sector-".concat(d.name, "-").concat(i)
      }, /*#__PURE__*/React.createElement(Sector, {
        onClick: () => handleClick(nodeWithIndex),
        onMouseEnter: e => handleMouseEnter(nodeWithIndex, e),
        onMouseLeave: e => handleMouseLeave(nodeWithIndex, e),
        fill: fillColor,
        stroke: stroke,
        strokeWidth: padding,
        startAngle: start,
        endAngle: start + arcLength,
        innerRadius: innerR,
        outerRadius: innerR + radius,
        cx: cx,
        cy: cy
      }), /*#__PURE__*/React.createElement(Text, _extends({}, textOptions, {
        alignmentBaseline: "middle",
        textAnchor: "middle",
        x: textX + cx,
        y: cy - textY
      }), d[dataKey])));
      var {
        x: tooltipX,
        y: tooltipY
      } = polarToCartesian(cx, cy, innerR + radius / 2, start);
      positions.set(d.name, {
        x: tooltipX,
        y: tooltipY
      });
      return drawArcs(d.children, {
        radius,
        innerR: innerR + radius + ringPadding,
        initialAngle: start,
        childColor: fillColor,
        nestedActiveTooltipIndex: currentTooltipIndex
      }, depth + 1);
    });
  }
  drawArcs(data.children, {
    radius: thickness,
    innerR: innerRadius,
    initialAngle: startAngle
  });
  var layerClass = clsx('recharts-sunburst', className);
  return /*#__PURE__*/React.createElement(TooltipPortalContext.Provider, {
    value: tooltipPortal
  }, /*#__PURE__*/React.createElement(RechartsWrapper, {
    className: className,
    width: width,
    height: height,
    responsive: responsive,
    style: style,
    ref: node => {
      if (tooltipPortal == null && node != null) {
        setTooltipPortal(node);
      }
    },
    onMouseEnter: undefined,
    onMouseLeave: undefined,
    onClick: undefined,
    onMouseMove: undefined,
    onMouseDown: undefined,
    onMouseUp: undefined,
    onContextMenu: undefined,
    onDoubleClick: undefined,
    onTouchStart: undefined,
    onTouchMove: undefined,
    onTouchEnd: undefined
  }, /*#__PURE__*/React.createElement(Surface, {
    width: width,
    height: height
  }, /*#__PURE__*/React.createElement(Layer, {
    className: layerClass
  }, sectors), /*#__PURE__*/React.createElement(SetTooltipEntrySettings, {
    fn: getTooltipEntrySettings,
    args: {
      dataKey,
      data,
      stroke,
      fill,
      nameKey,
      positions
    }
  }), children)));
};
var SunburstChart = props => {
  var _props$className;
  return /*#__PURE__*/React.createElement(RechartsStoreProvider, {
    preloadedState: preloadedState,
    reduxStoreName: (_props$className = props.className) !== null && _props$className !== void 0 ? _props$className : 'SunburstChart'
  }, /*#__PURE__*/React.createElement(ReportChartSize, {
    width: props.width,
    height: props.height
  }), /*#__PURE__*/React.createElement(ReportChartMargin, {
    margin: defaultSunburstMargin
  }), /*#__PURE__*/React.createElement(SunburstChartImpl, props));
};

/***/ }),

/***/ 33737:
/*!****************************************************!*\
  !*** ./node_modules/recharts/es6/chart/Treemap.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* unused harmony exports treemapPayloadSearcher, addToTreemapNodeIndex, computeNode, Treemap */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ 96540);
/* harmony import */ var es_toolkit_compat_omit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! es-toolkit/compat/omit */ 11576);
/* harmony import */ var es_toolkit_compat_omit__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(es_toolkit_compat_omit__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var es_toolkit_compat_get__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! es-toolkit/compat/get */ 80305);
/* harmony import */ var es_toolkit_compat_get__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(es_toolkit_compat_get__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _container_Layer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../container/Layer */ 86069);
/* harmony import */ var _container_Surface__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../container/Surface */ 49303);
/* harmony import */ var _shape_Polygon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../shape/Polygon */ 20852);
/* harmony import */ var _shape_Rectangle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../shape/Rectangle */ 34723);
/* harmony import */ var _util_ChartUtils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util/ChartUtils */ 33964);
/* harmony import */ var _util_Constants__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/Constants */ 4364);
/* harmony import */ var _util_DataUtils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../util/DataUtils */ 59744);
/* harmony import */ var _util_DOMUtils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../util/DOMUtils */ 81636);
/* harmony import */ var _util_Global__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../util/Global */ 59938);
/* harmony import */ var _context_chartLayoutContext__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../context/chartLayoutContext */ 19287);
/* harmony import */ var _context_tooltipPortalContext__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../context/tooltipPortalContext */ 74354);
/* harmony import */ var _RechartsWrapper__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./RechartsWrapper */ 41940);
/* harmony import */ var _state_tooltipSlice__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../state/tooltipSlice */ 74531);
/* harmony import */ var _state_SetTooltipEntrySettings__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../state/SetTooltipEntrySettings */ 59482);
/* harmony import */ var _state_RechartsStoreProvider__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../state/RechartsStoreProvider */ 11970);
/* harmony import */ var _state_hooks__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../state/hooks */ 49082);
/* harmony import */ var _util_isWellBehavedNumber__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../util/isWellBehavedNumber */ 8813);
/* harmony import */ var _util_svgPropertiesNoEvents__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../util/svgPropertiesNoEvents */ 55448);
/* harmony import */ var _animation_CSSTransitionAnimate__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../animation/CSSTransitionAnimate */ 97950);
/* harmony import */ var _util_resolveDefaultProps__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../util/resolveDefaultProps */ 77404);
var _excluded = ["width", "height", "className", "style", "children", "type"];
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
























var NODE_VALUE_KEY = 'value';

/**
 * This is what end users defines as `data` on Treemap.
 */

/**
 * This is what is returned from `squarify`, the final treemap data structure
 * that gets rendered and is stored in
 */

var treemapPayloadSearcher = (data, activeIndex) => {
  if (!data || !activeIndex) {
    return undefined;
  }
  return es_toolkit_compat_get__WEBPACK_IMPORTED_MODULE_2___default()(data, activeIndex);
};
var addToTreemapNodeIndex = function addToTreemapNodeIndex(indexInChildrenArr) {
  var activeTooltipIndexSoFar = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  return "".concat(activeTooltipIndexSoFar, "children[").concat(indexInChildrenArr, "]");
};
var options = {
  chartName: 'Treemap',
  defaultTooltipEventType: 'item',
  validateTooltipEventTypes: ['item'],
  tooltipPayloadSearcher: treemapPayloadSearcher,
  eventEmitter: undefined
};
var computeNode = _ref => {
  var {
    depth,
    node,
    index,
    dataKey,
    nameKey,
    nestedActiveTooltipIndex
  } = _ref;
  var currentTooltipIndex = depth === 0 ? '' : addToTreemapNodeIndex(index, nestedActiveTooltipIndex);
  var {
    children
  } = node;
  var childDepth = depth + 1;
  var computedChildren = children && children.length ? children.map((child, i) => computeNode({
    depth: childDepth,
    node: child,
    index: i,
    dataKey,
    nameKey,
    nestedActiveTooltipIndex: currentTooltipIndex
  })) : null;
  var nodeValue;
  if (computedChildren && computedChildren.length) {
    nodeValue = computedChildren.reduce((result, child) => result + child[NODE_VALUE_KEY], 0);
  } else {
    // TODO need to verify dataKey
    nodeValue = (0,_util_DataUtils__WEBPACK_IMPORTED_MODULE_9__.isNan)(node[dataKey]) || node[dataKey] <= 0 ? 0 : node[dataKey];
  }
  return _objectSpread(_objectSpread({}, node), {}, {
    children: computedChildren,
    // @ts-expect-error getValueByDataKey does not validate the output type
    name: (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_7__.getValueByDataKey)(node, nameKey, ''),
    [NODE_VALUE_KEY]: nodeValue,
    depth,
    index,
    tooltipIndex: currentTooltipIndex
  });
};
var filterRect = node => ({
  x: node.x,
  y: node.y,
  width: node.width,
  height: node.height
});
// Compute the area for each child based on value & scale.
var getAreaOfChildren = (children, areaValueRatio) => {
  var ratio = areaValueRatio < 0 ? 0 : areaValueRatio;
  return children.map(child => {
    var area = child[NODE_VALUE_KEY] * ratio;
    return _objectSpread(_objectSpread({}, child), {}, {
      area: (0,_util_DataUtils__WEBPACK_IMPORTED_MODULE_9__.isNan)(area) || area <= 0 ? 0 : area
    });
  });
};

// Computes the score for the specified row, as the worst aspect ratio.
var getWorstScore = (row, parentSize, aspectRatio) => {
  var parentArea = parentSize * parentSize;
  var rowArea = row.area * row.area;
  var {
    min,
    max
  } = row.reduce((result, child) => ({
    min: Math.min(result.min, child.area),
    max: Math.max(result.max, child.area)
  }), {
    min: Infinity,
    max: 0
  });
  return rowArea ? Math.max(parentArea * max * aspectRatio / rowArea, rowArea / (parentArea * min * aspectRatio)) : Infinity;
};
var horizontalPosition = (row, parentSize, parentRect, isFlush) => {
  var rowHeight = parentSize ? Math.round(row.area / parentSize) : 0;
  if (isFlush || rowHeight > parentRect.height) {
    rowHeight = parentRect.height;
  }
  var curX = parentRect.x;
  var child;
  for (var i = 0, len = row.length; i < len; i++) {
    child = row[i];
    child.x = curX;
    child.y = parentRect.y;
    child.height = rowHeight;
    child.width = Math.min(rowHeight ? Math.round(child.area / rowHeight) : 0, parentRect.x + parentRect.width - curX);
    curX += child.width;
  }
  // add the remain x to the last one of row
  if (child != null) {
    child.width += parentRect.x + parentRect.width - curX;
  }
  return _objectSpread(_objectSpread({}, parentRect), {}, {
    y: parentRect.y + rowHeight,
    height: parentRect.height - rowHeight
  });
};
var verticalPosition = (row, parentSize, parentRect, isFlush) => {
  var rowWidth = parentSize ? Math.round(row.area / parentSize) : 0;
  if (isFlush || rowWidth > parentRect.width) {
    rowWidth = parentRect.width;
  }
  var curY = parentRect.y;
  var child;
  for (var i = 0, len = row.length; i < len; i++) {
    child = row[i];
    child.x = parentRect.x;
    child.y = curY;
    child.width = rowWidth;
    child.height = Math.min(rowWidth ? Math.round(child.area / rowWidth) : 0, parentRect.y + parentRect.height - curY);
    curY += child.height;
  }
  if (child) {
    child.height += parentRect.y + parentRect.height - curY;
  }
  return _objectSpread(_objectSpread({}, parentRect), {}, {
    x: parentRect.x + rowWidth,
    width: parentRect.width - rowWidth
  });
};
var position = (row, parentSize, parentRect, isFlush) => {
  if (parentSize === parentRect.width) {
    return horizontalPosition(row, parentSize, parentRect, isFlush);
  }
  return verticalPosition(row, parentSize, parentRect, isFlush);
};
// Recursively arranges the specified node's children into squarified rows.
var squarify = (node, aspectRatio) => {
  var {
    children
  } = node;
  if (children && children.length) {
    var rect = filterRect(node);
    // @ts-expect-error we can't create an array with static property on a single line so typescript will complain.
    var row = [];
    var best = Infinity; // the best row score so far
    var child, score; // the current row score
    var size = Math.min(rect.width, rect.height); // initial orientation
    var scaleChildren = getAreaOfChildren(children, rect.width * rect.height / node[NODE_VALUE_KEY]);
    var tempChildren = scaleChildren.slice();

    // why are we setting static properties on an array?
    row.area = 0;
    while (tempChildren.length > 0) {
      // row first
      // eslint-disable-next-line prefer-destructuring
      row.push(child = tempChildren[0]);
      row.area += child.area;
      score = getWorstScore(row, size, aspectRatio);
      if (score <= best) {
        // continue with this orientation
        tempChildren.shift();
        best = score;
      } else {
        var _row$pop$area, _row$pop;
        // abort, and try a different orientation
        row.area -= (_row$pop$area = (_row$pop = row.pop()) === null || _row$pop === void 0 ? void 0 : _row$pop.area) !== null && _row$pop$area !== void 0 ? _row$pop$area : 0;
        rect = position(row, size, rect, false);
        size = Math.min(rect.width, rect.height);
        row.length = row.area = 0;
        best = Infinity;
      }
    }
    if (row.length) {
      rect = position(row, size, rect, true);
      row.length = row.area = 0;
    }
    return _objectSpread(_objectSpread({}, node), {}, {
      children: scaleChildren.map(c => squarify(c, aspectRatio))
    });
  }
  return node;
};
var defaultTreeMapProps = {
  aspectRatio: 0.5 * (1 + Math.sqrt(5)),
  dataKey: 'value',
  nameKey: 'name',
  type: 'flat',
  isAnimationActive: !_util_Global__WEBPACK_IMPORTED_MODULE_11__.Global.isSsr,
  isUpdateAnimationActive: !_util_Global__WEBPACK_IMPORTED_MODULE_11__.Global.isSsr,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: 'linear'
};
var defaultState = {
  isAnimationFinished: false,
  formatRoot: null,
  currentRoot: null,
  nestIndex: [],
  prevAspectRatio: defaultTreeMapProps.aspectRatio,
  prevDataKey: defaultTreeMapProps.dataKey
};
function ContentItem(_ref2) {
  var {
    content,
    nodeProps,
    type,
    colorPanel,
    onMouseEnter,
    onMouseLeave,
    onClick
  } = _ref2;
  if (/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(content)) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_container_Layer__WEBPACK_IMPORTED_MODULE_3__.Layer, {
      onMouseEnter: onMouseEnter,
      onMouseLeave: onMouseLeave,
      onClick: onClick
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(content, nodeProps));
  }
  if (typeof content === 'function') {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_container_Layer__WEBPACK_IMPORTED_MODULE_3__.Layer, {
      onMouseEnter: onMouseEnter,
      onMouseLeave: onMouseLeave,
      onClick: onClick
    }, content(nodeProps));
  }
  // optimize default shape
  var {
    x,
    y,
    width,
    height,
    index
  } = nodeProps;
  var arrow = null;
  if (width > 10 && height > 10 && nodeProps.children && type === 'nest') {
    arrow = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_shape_Polygon__WEBPACK_IMPORTED_MODULE_5__.Polygon, {
      points: [{
        x: x + 2,
        y: y + height / 2
      }, {
        x: x + 6,
        y: y + height / 2 + 3
      }, {
        x: x + 2,
        y: y + height / 2 + 6
      }]
    });
  }
  var text = null;
  var nameSize = (0,_util_DOMUtils__WEBPACK_IMPORTED_MODULE_10__.getStringSize)(nodeProps.name);
  if (width > 20 && height > 20 && nameSize.width < width && nameSize.height < height) {
    text = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("text", {
      x: x + 8,
      y: y + height / 2 + 7,
      fontSize: 14
    }, nodeProps.name);
  }
  var colors = colorPanel || _util_Constants__WEBPACK_IMPORTED_MODULE_8__.COLOR_PANEL;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("g", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_shape_Rectangle__WEBPACK_IMPORTED_MODULE_6__.Rectangle, _extends({
    fill: nodeProps.depth < 2 ? colors[index % colors.length] : 'rgba(255,255,255,0)',
    stroke: "#fff"
  }, es_toolkit_compat_omit__WEBPACK_IMPORTED_MODULE_1___default()(nodeProps, ['children']), {
    onMouseEnter: onMouseEnter,
    onMouseLeave: onMouseLeave,
    onClick: onClick,
    "data-recharts-item-index": nodeProps.tooltipIndex
  })), arrow, text);
}
function ContentItemWithEvents(props) {
  var dispatch = (0,_state_hooks__WEBPACK_IMPORTED_MODULE_18__.useAppDispatch)();
  var activeCoordinate = {
    x: props.nodeProps.x + props.nodeProps.width / 2,
    y: props.nodeProps.y + props.nodeProps.height / 2
  };
  var onMouseEnter = () => {
    dispatch((0,_state_tooltipSlice__WEBPACK_IMPORTED_MODULE_15__.setActiveMouseOverItemIndex)({
      activeIndex: props.nodeProps.tooltipIndex,
      activeDataKey: props.dataKey,
      activeCoordinate
    }));
  };
  var onMouseLeave = () => {
    // clearing state on mouseLeaveItem causes re-rendering issues
    // we don't actually want to do this for TreeMap - we clear state when we leave the entire chart instead
  };
  var onClick = () => {
    dispatch((0,_state_tooltipSlice__WEBPACK_IMPORTED_MODULE_15__.setActiveClickItemIndex)({
      activeIndex: props.nodeProps.tooltipIndex,
      activeDataKey: props.dataKey,
      activeCoordinate
    }));
  };
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(ContentItem, _extends({}, props, {
    onMouseEnter: onMouseEnter,
    onMouseLeave: onMouseLeave,
    onClick: onClick
  }));
}
function getTooltipEntrySettings(_ref3) {
  var {
    props,
    currentRoot
  } = _ref3;
  var {
    dataKey,
    nameKey,
    stroke,
    fill
  } = props;
  return {
    dataDefinedOnItem: currentRoot,
    positions: undefined,
    // TODO I think Treemap has the capability of computing positions and supporting defaultIndex? Except it doesn't yet
    settings: {
      stroke,
      strokeWidth: undefined,
      fill,
      dataKey,
      nameKey,
      name: undefined,
      // Each TreemapNode has its own name
      hide: false,
      type: undefined,
      color: fill,
      unit: ''
    }
  };
}

// Why is margin not a treemap prop? No clue. Probably it should be
var defaultTreemapMargin = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0
};
function TreemapItem(_ref4) {
  var {
    content,
    nodeProps,
    isLeaf,
    treemapProps,
    onNestClick
  } = _ref4;
  var {
    isAnimationActive,
    animationBegin,
    animationDuration,
    animationEasing,
    isUpdateAnimationActive,
    type,
    colorPanel,
    dataKey,
    onAnimationStart,
    onAnimationEnd,
    onMouseEnter: onMouseEnterFromProps,
    onClick: onItemClickFromProps,
    onMouseLeave: onMouseLeaveFromProps
  } = treemapProps;
  var {
    width,
    height,
    x,
    y
  } = nodeProps;
  var translateX = -x - width;
  var translateY = 0;
  var onMouseEnter = e => {
    if ((isLeaf || type === 'nest') && typeof onMouseEnterFromProps === 'function') {
      onMouseEnterFromProps(nodeProps, e);
    }
  };
  var onMouseLeave = e => {
    if ((isLeaf || type === 'nest') && typeof onMouseLeaveFromProps === 'function') {
      onMouseLeaveFromProps(nodeProps, e);
    }
  };
  var onClick = () => {
    if (type === 'nest') {
      onNestClick(nodeProps);
    }
    if ((isLeaf || type === 'nest') && typeof onItemClickFromProps === 'function') {
      onItemClickFromProps(nodeProps);
    }
  };
  var handleAnimationEnd = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {
    if (typeof onAnimationEnd === 'function') {
      onAnimationEnd();
    }
  }, [onAnimationEnd]);
  var handleAnimationStart = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {
    if (typeof onAnimationStart === 'function') {
      onAnimationStart();
    }
  }, [onAnimationStart]);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_animation_CSSTransitionAnimate__WEBPACK_IMPORTED_MODULE_21__.CSSTransitionAnimate, {
    animationId: "treemap-".concat(nodeProps.tooltipIndex),
    from: "translate(".concat(translateX, "px, ").concat(translateY, "px)"),
    to: "translate(0, 0)",
    attributeName: "transform",
    begin: animationBegin,
    easing: animationEasing,
    isActive: isAnimationActive,
    duration: animationDuration,
    onAnimationStart: handleAnimationStart,
    onAnimationEnd: handleAnimationEnd
  }, style => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_container_Layer__WEBPACK_IMPORTED_MODULE_3__.Layer, {
    onMouseEnter: onMouseEnter,
    onMouseLeave: onMouseLeave,
    onClick: onClick,
    style: _objectSpread(_objectSpread({}, style), {}, {
      transformOrigin: "".concat(x, " ").concat(y)
    })
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(ContentItemWithEvents, {
    content: content,
    dataKey: dataKey,
    nodeProps: _objectSpread(_objectSpread({}, nodeProps), {}, {
      isAnimationActive,
      isUpdateAnimationActive: !isUpdateAnimationActive,
      width,
      height,
      x,
      y
    }),
    type: type,
    colorPanel: colorPanel
  })));
}
class TreemapWithState extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {
  constructor() {
    super(...arguments);
    _defineProperty(this, "state", _objectSpread({}, defaultState));
    _defineProperty(this, "handleClick", node => {
      var {
        onClick,
        type
      } = this.props;
      if (type === 'nest' && node.children) {
        var {
          width,
          height,
          dataKey,
          nameKey,
          aspectRatio
        } = this.props;
        var root = computeNode({
          depth: 0,
          node: _objectSpread(_objectSpread({}, node), {}, {
            x: 0,
            y: 0,
            width,
            height
          }),
          index: 0,
          dataKey,
          nameKey,
          // with Treemap nesting, should this continue nesting the index or start from empty string?
          nestedActiveTooltipIndex: node.tooltipIndex
        });
        var formatRoot = squarify(root, aspectRatio);
        var {
          nestIndex
        } = this.state;
        nestIndex.push(node);
        this.setState({
          formatRoot,
          currentRoot: root,
          nestIndex
        });
      }
      if (onClick) {
        onClick(node);
      }
    });
    _defineProperty(this, "handleTouchMove", e => {
      var touchEvent = e.touches[0];
      var target = document.elementFromPoint(touchEvent.clientX, touchEvent.clientY);
      if (!target || !target.getAttribute || this.state.formatRoot == null) {
        return;
      }
      var itemIndex = target.getAttribute('data-recharts-item-index');
      var activeNode = treemapPayloadSearcher(this.state.formatRoot, itemIndex);
      if (!activeNode) {
        return;
      }
      var {
        dataKey,
        dispatch
      } = this.props;
      var activeCoordinate = {
        x: activeNode.x + activeNode.width / 2,
        y: activeNode.y + activeNode.height / 2
      };

      // Treemap does not support onTouchMove prop, but it could
      // onTouchMove?.(activeNode, Number(itemIndex), e);
      dispatch((0,_state_tooltipSlice__WEBPACK_IMPORTED_MODULE_15__.setActiveMouseOverItemIndex)({
        activeIndex: itemIndex,
        activeDataKey: dataKey,
        activeCoordinate
      }));
    });
  }
  static getDerivedStateFromProps(nextProps, prevState) {
    if (nextProps.data !== prevState.prevData || nextProps.type !== prevState.prevType || nextProps.width !== prevState.prevWidth || nextProps.height !== prevState.prevHeight || nextProps.dataKey !== prevState.prevDataKey || nextProps.aspectRatio !== prevState.prevAspectRatio) {
      var root = computeNode({
        depth: 0,
        // @ts-expect-error missing properties
        node: {
          children: nextProps.data,
          x: 0,
          y: 0,
          width: nextProps.width,
          height: nextProps.height
        },
        index: 0,
        dataKey: nextProps.dataKey,
        nameKey: nextProps.nameKey
      });
      var formatRoot = squarify(root, nextProps.aspectRatio);
      return _objectSpread(_objectSpread({}, prevState), {}, {
        formatRoot,
        currentRoot: root,
        nestIndex: [root],
        prevAspectRatio: nextProps.aspectRatio,
        prevData: nextProps.data,
        prevWidth: nextProps.width,
        prevHeight: nextProps.height,
        prevDataKey: nextProps.dataKey,
        prevType: nextProps.type
      });
    }
    return null;
  }
  handleNestIndex(node, i) {
    var {
      nestIndex
    } = this.state;
    var {
      width,
      height,
      dataKey,
      nameKey,
      aspectRatio
    } = this.props;
    var root = computeNode({
      depth: 0,
      node: _objectSpread(_objectSpread({}, node), {}, {
        x: 0,
        y: 0,
        width,
        height
      }),
      index: 0,
      dataKey,
      nameKey,
      // with Treemap nesting, should this continue nesting the index or start from empty string?
      nestedActiveTooltipIndex: node.tooltipIndex
    });
    var formatRoot = squarify(root, aspectRatio);
    nestIndex = nestIndex.slice(0, i + 1);
    this.setState({
      formatRoot,
      currentRoot: node,
      nestIndex
    });
  }
  renderNode(root, node) {
    var {
      content,
      type
    } = this.props;
    var nodeProps = _objectSpread(_objectSpread(_objectSpread({}, (0,_util_svgPropertiesNoEvents__WEBPACK_IMPORTED_MODULE_20__.svgPropertiesNoEvents)(this.props)), node), {}, {
      root
    });
    var isLeaf = !node.children || !node.children.length;
    var {
      currentRoot
    } = this.state;
    var isCurrentRootChild = ((currentRoot === null || currentRoot === void 0 ? void 0 : currentRoot.children) || []).filter(item => item.depth === node.depth && item.name === node.name);
    if (!isCurrentRootChild.length && root.depth && type === 'nest') {
      return null;
    }
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_container_Layer__WEBPACK_IMPORTED_MODULE_3__.Layer, {
      key: "recharts-treemap-node-".concat(nodeProps.x, "-").concat(nodeProps.y, "-").concat(nodeProps.name),
      className: "recharts-treemap-depth-".concat(node.depth)
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(TreemapItem, {
      isLeaf: isLeaf,
      content: content,
      nodeProps: nodeProps,
      treemapProps: this.props,
      onNestClick: this.handleClick
    }), node.children && node.children.length ? node.children.map(child => this.renderNode(node, child)) : null);
  }
  renderAllNodes() {
    var {
      formatRoot
    } = this.state;
    if (!formatRoot) {
      return null;
    }
    return this.renderNode(formatRoot, formatRoot);
  }

  // render nest treemap
  renderNestIndex() {
    var {
      nameKey,
      nestIndexContent
    } = this.props;
    var {
      nestIndex
    } = this.state;
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
      className: "recharts-treemap-nest-index-wrapper",
      style: {
        marginTop: '8px',
        textAlign: 'center'
      }
    }, nestIndex.map((item, i) => {
      // TODO need to verify nameKey type
      var name = es_toolkit_compat_get__WEBPACK_IMPORTED_MODULE_2___default()(item, nameKey, 'root');
      var content;
      if (/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(nestIndexContent)) {
        // the cloned content is ignored at all times - let's remove it?
        content = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(nestIndexContent, item, i);
      }
      if (typeof nestIndexContent === 'function') {
        content = nestIndexContent(item, i);
      } else {
        content = name;
      }
      return (
        /*#__PURE__*/
        // eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions
        react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
          onClick: this.handleNestIndex.bind(this, item, i),
          key: "nest-index-".concat((0,_util_DataUtils__WEBPACK_IMPORTED_MODULE_9__.uniqueId)()),
          className: "recharts-treemap-nest-index-box",
          style: {
            cursor: 'pointer',
            display: 'inline-block',
            padding: '0 7px',
            background: '#000',
            color: '#fff',
            marginRight: '3px'
          }
        }, content)
      );
    }));
  }
  render() {
    var _this$props = this.props,
      {
        width,
        height,
        className,
        style,
        children,
        type
      } = _this$props,
      others = _objectWithoutProperties(_this$props, _excluded);
    var attrs = (0,_util_svgPropertiesNoEvents__WEBPACK_IMPORTED_MODULE_20__.svgPropertiesNoEvents)(others);
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_state_SetTooltipEntrySettings__WEBPACK_IMPORTED_MODULE_16__.SetTooltipEntrySettings, {
      fn: getTooltipEntrySettings,
      args: {
        props: this.props,
        currentRoot: this.state.currentRoot
      }
    }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_container_Surface__WEBPACK_IMPORTED_MODULE_4__.Surface, _extends({}, attrs, {
      width: width,
      height: type === 'nest' ? height - 30 : height,
      onTouchMove: this.handleTouchMove
    }), this.renderAllNodes(), children), type === 'nest' && this.renderNestIndex());
  }
}
_defineProperty(TreemapWithState, "displayName", 'Treemap');
function TreemapDispatchInject(props) {
  var dispatch = useAppDispatch();
  var width = useChartWidth();
  var height = useChartHeight();
  if (!isPositiveNumber(width) || !isPositiveNumber(height)) {
    return null;
  }
  return /*#__PURE__*/React.createElement(TreemapWithState, _extends({}, props, {
    width: width,
    height: height,
    dispatch: dispatch
  }));
}
function Treemap(outsideProps) {
  var _props$className;
  var props = resolveDefaultProps(outsideProps, defaultTreeMapProps);
  var {
    className,
    style,
    width,
    height
  } = props;
  var [tooltipPortal, setTooltipPortal] = useState(null);
  return /*#__PURE__*/React.createElement(RechartsStoreProvider, {
    preloadedState: {
      options
    },
    reduxStoreName: (_props$className = props.className) !== null && _props$className !== void 0 ? _props$className : 'Treemap'
  }, /*#__PURE__*/React.createElement(ReportChartMargin, {
    margin: defaultTreemapMargin
  }), /*#__PURE__*/React.createElement(RechartsWrapper, {
    dispatchTouchEvents: false,
    className: className,
    style: style,
    width: width,
    height: height
    /*
     * Treemap has a bug where it doesn't include strokeWidth in its dimension calculation
     * which makes the actual chart exactly {strokeWidth} larger than asked for.
     * It's not a huge deal usually, but it makes the responsive option cycle infinitely.
     */,
    responsive: false,
    ref: node => {
      if (tooltipPortal == null && node != null) {
        setTooltipPortal(node);
      }
    },
    onMouseEnter: undefined,
    onMouseLeave: undefined,
    onClick: undefined,
    onMouseMove: undefined,
    onMouseDown: undefined,
    onMouseUp: undefined,
    onContextMenu: undefined,
    onDoubleClick: undefined,
    onTouchStart: undefined,
    onTouchMove: undefined,
    onTouchEnd: undefined
  }, /*#__PURE__*/React.createElement(TooltipPortalContext.Provider, {
    value: tooltipPortal
  }, /*#__PURE__*/React.createElement(TreemapDispatchInject, props))));
}

/***/ }),

/***/ 59853:
/*!*********************************************************!*\
  !*** ./node_modules/recharts/es6/chart/ScatterChart.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* unused harmony export ScatterChart */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ 96540);
/* harmony import */ var _state_optionsSlice__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../state/optionsSlice */ 26960);
/* harmony import */ var _CartesianChart__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CartesianChart */ 72685);




var allowedTooltipTypes = (/* unused pure expression or super */ null && (['item']));
var ScatterChart = /*#__PURE__*/(/* unused pure expression or super */ null && (forwardRef((props, ref) => {
  return /*#__PURE__*/React.createElement(CartesianChart, {
    chartName: "ScatterChart",
    defaultTooltipEventType: "item",
    validateTooltipEventTypes: allowedTooltipTypes,
    tooltipPayloadSearcher: arrayTooltipSearcher,
    categoricalChartProps: props,
    ref: ref
  });
})));

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9yLWNvbW1vbi1ub2RlX21vZHVsZXNfcmVjaGFydHNfZXM2X2NoYXJ0X1MuNmQ4ZDhjYWQwNDQ3YmEwZTY1ZjEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsc0JBQXNCLHdFQUF3RSxnQkFBZ0Isc0JBQXNCLE9BQU8sc0JBQXNCLG9CQUFvQixnREFBZ0QsV0FBVztBQUNoUCx5QkFBeUIsd0JBQXdCLG9DQUFvQyx5Q0FBeUMsa0NBQWtDLDBEQUEwRCwwQkFBMEI7QUFDcFAsNEJBQTRCLGdCQUFnQixzQkFBc0IsT0FBTyxrREFBa0Qsc0RBQXNELDhCQUE4QixtSkFBbUoscUVBQXFFLEtBQUs7QUFDNWEsb0NBQW9DLG9FQUFvRSwwREFBMEQ7QUFDbEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsMENBQTBDLCtCQUErQixvQkFBb0IsbUNBQW1DLG9DQUFvQyx1RUFBdUU7QUFDMU87QUFDRTtBQUNxQjtBQUMxQjtBQUNZO0FBQ087QUFDSjtBQUNGO0FBQ0E7QUFDYTtBQUM0RDtBQUMzQztBQUNuQjtBQUN5RDtBQUNsQztBQUNKO0FBQ3ZCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsU0FBUyw0REFBRztBQUNaO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0EsS0FBSyxnQkFBZ0IsZ0RBQW1CLENBQUMsdURBQU8sYUFBYTtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxhQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0gsQzs7Ozs7Ozs7Ozs7Ozs7QUNyeEIrQjtBQUNJO0FBQzBCO0FBQ1g7QUFDbEQsMEJBQTBCLHdEQUFRO0FBQzNCLGdDQUFnQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDLENBQUMsRyIsInNvdXJjZXMiOlsid2VicGFjazovL2d1aXYyLy4vbm9kZV9tb2R1bGVzL3JlY2hhcnRzL2VzNi9jaGFydC9TdW5idXJzdENoYXJ0LmpzIiwid2VicGFjazovL2d1aXYyLy4vbm9kZV9tb2R1bGVzL3JlY2hhcnRzL2VzNi9jaGFydC9UcmVlbWFwLmpzIiwid2VicGFjazovL2d1aXYyLy4vbm9kZV9tb2R1bGVzL3JlY2hhcnRzL2VzNi9jaGFydC9TY2F0dGVyQ2hhcnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2V4dGVuZHMoKSB7IHJldHVybiBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uIChuKSB7IGZvciAodmFyIGUgPSAxOyBlIDwgYXJndW1lbnRzLmxlbmd0aDsgZSsrKSB7IHZhciB0ID0gYXJndW1lbnRzW2VdOyBmb3IgKHZhciByIGluIHQpICh7fSkuaGFzT3duUHJvcGVydHkuY2FsbCh0LCByKSAmJiAobltyXSA9IHRbcl0pOyB9IHJldHVybiBuOyB9LCBfZXh0ZW5kcy5hcHBseShudWxsLCBhcmd1bWVudHMpOyB9XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7IHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHsgdmFsdWU6IHQsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSkgOiBlW3JdID0gdCwgZTsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gdHlwZW9mIGkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiB0IHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiBpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgc2NhbGVMaW5lYXIgfSBmcm9tICd2aWN0b3J5LXZlbmRvci9kMy1zY2FsZSc7XG5pbXBvcnQgeyBjbHN4IH0gZnJvbSAnY2xzeCc7XG5pbXBvcnQgZ2V0IGZyb20gJ2VzLXRvb2xraXQvY29tcGF0L2dldCc7XG5pbXBvcnQgeyBTdXJmYWNlIH0gZnJvbSAnLi4vY29udGFpbmVyL1N1cmZhY2UnO1xuaW1wb3J0IHsgTGF5ZXIgfSBmcm9tICcuLi9jb250YWluZXIvTGF5ZXInO1xuaW1wb3J0IHsgU2VjdG9yIH0gZnJvbSAnLi4vc2hhcGUvU2VjdG9yJztcbmltcG9ydCB7IFRleHQgfSBmcm9tICcuLi9jb21wb25lbnQvVGV4dCc7XG5pbXBvcnQgeyBwb2xhclRvQ2FydGVzaWFuIH0gZnJvbSAnLi4vdXRpbC9Qb2xhclV0aWxzJztcbmltcG9ydCB7IFJlcG9ydENoYXJ0TWFyZ2luLCBSZXBvcnRDaGFydFNpemUsIHVzZUNoYXJ0SGVpZ2h0LCB1c2VDaGFydFdpZHRoIH0gZnJvbSAnLi4vY29udGV4dC9jaGFydExheW91dENvbnRleHQnO1xuaW1wb3J0IHsgVG9vbHRpcFBvcnRhbENvbnRleHQgfSBmcm9tICcuLi9jb250ZXh0L3Rvb2x0aXBQb3J0YWxDb250ZXh0JztcbmltcG9ydCB7IFJlY2hhcnRzV3JhcHBlciB9IGZyb20gJy4vUmVjaGFydHNXcmFwcGVyJztcbmltcG9ydCB7IG1vdXNlTGVhdmVJdGVtLCBzZXRBY3RpdmVDbGlja0l0ZW1JbmRleCwgc2V0QWN0aXZlTW91c2VPdmVySXRlbUluZGV4IH0gZnJvbSAnLi4vc3RhdGUvdG9vbHRpcFNsaWNlJztcbmltcG9ydCB7IFNldFRvb2x0aXBFbnRyeVNldHRpbmdzIH0gZnJvbSAnLi4vc3RhdGUvU2V0VG9vbHRpcEVudHJ5U2V0dGluZ3MnO1xuaW1wb3J0IHsgUmVjaGFydHNTdG9yZVByb3ZpZGVyIH0gZnJvbSAnLi4vc3RhdGUvUmVjaGFydHNTdG9yZVByb3ZpZGVyJztcbmltcG9ydCB7IHVzZUFwcERpc3BhdGNoIH0gZnJvbSAnLi4vc3RhdGUvaG9va3MnO1xudmFyIGRlZmF1bHRUZXh0UHJvcHMgPSB7XG4gIGZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgcGFpbnRPcmRlcjogJ3N0cm9rZSBmaWxsJyxcbiAgZm9udFNpemU6ICcuNzVyZW0nLFxuICBzdHJva2U6ICcjRkZGJyxcbiAgZmlsbDogJ2JsYWNrJyxcbiAgcG9pbnRlckV2ZW50czogJ25vbmUnXG59O1xuZnVuY3Rpb24gZ2V0TWF4RGVwdGhPZihub2RlKSB7XG4gIGlmICghbm9kZS5jaGlsZHJlbiB8fCBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDE7XG5cbiAgLy8gQ2FsY3VsYXRlIGRlcHRoIGZvciBlYWNoIGNoaWxkIGFuZCBmaW5kIHRoZSBtYXhpbXVtXG4gIHZhciBjaGlsZERlcHRocyA9IG5vZGUuY2hpbGRyZW4ubWFwKGQgPT4gZ2V0TWF4RGVwdGhPZihkKSk7XG4gIHJldHVybiAxICsgTWF0aC5tYXgoLi4uY2hpbGREZXB0aHMpO1xufVxuZnVuY3Rpb24gY29udmVydE1hcFRvUmVjb3JkKG1hcCkge1xuICB2YXIgcmVjb3JkID0ge307XG4gIG1hcC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgcmVjb3JkW2tleV0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZWNvcmQ7XG59XG5mdW5jdGlvbiBnZXRUb29sdGlwRW50cnlTZXR0aW5ncyhfcmVmKSB7XG4gIHZhciB7XG4gICAgZGF0YUtleSxcbiAgICBuYW1lS2V5LFxuICAgIGRhdGEsXG4gICAgc3Ryb2tlLFxuICAgIGZpbGwsXG4gICAgcG9zaXRpb25zXG4gIH0gPSBfcmVmO1xuICByZXR1cm4ge1xuICAgIGRhdGFEZWZpbmVkT25JdGVtOiBkYXRhLmNoaWxkcmVuLFxuICAgIC8vIFJlZHV4IHN0b3JlIHdpbGwgbm90IGFjY2VwdCBhIE1hcCBiZWNhdXNlIGl0J3Mgbm90IHNlcmlhbGl6YWJsZVxuICAgIHBvc2l0aW9uczogY29udmVydE1hcFRvUmVjb3JkKHBvc2l0aW9ucyksXG4gICAgLy8gU3VuYnVyc3QgZG9lcyBub3Qgc3VwcG9ydCBtYW55IG9mIHRoZSBwcm9wZXJ0aWVzIGFzIG90aGVyIGNoYXJ0cyBkbyBzbyB0aGVyZSdzIHBsZW50eSBvZiBkZWZhdWx0cyBoZXJlXG4gICAgc2V0dGluZ3M6IHtcbiAgICAgIHN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoOiB1bmRlZmluZWQsXG4gICAgICBmaWxsLFxuICAgICAgbmFtZUtleSxcbiAgICAgIGRhdGFLZXksXG4gICAgICAvLyBpZiB0aGVyZSBpcyBhIG5hbWVLZXkgdXNlIGl0LCBvdGhlcndpc2UgbWFrZSB0aGUgbmFtZSBvZiB0aGUgdG9vbHRpcCB0aGUgZGF0YUtleSBpdHNlbGZcbiAgICAgIG5hbWU6IG5hbWVLZXkgPyB1bmRlZmluZWQgOiBkYXRhS2V5LFxuICAgICAgaGlkZTogZmFsc2UsXG4gICAgICB0eXBlOiB1bmRlZmluZWQsXG4gICAgICBjb2xvcjogZmlsbCxcbiAgICAgIHVuaXQ6ICcnXG4gICAgfVxuICB9O1xufVxuXG4vLyBXaHkgaXMgbWFyZ2luIG5vdCBhIHN1bmJ1cnN0IHByb3A/IE5vIGNsdWUuIFByb2JhYmx5IGl0IHNob3VsZCBiZVxudmFyIGRlZmF1bHRTdW5idXJzdE1hcmdpbiA9IHtcbiAgdG9wOiAwLFxuICByaWdodDogMCxcbiAgYm90dG9tOiAwLFxuICBsZWZ0OiAwXG59O1xuZXhwb3J0IHZhciBwYXlsb2FkU2VhcmNoZXIgPSAoZGF0YSwgYWN0aXZlSW5kZXgpID0+IHtcbiAgcmV0dXJuIGdldChkYXRhLCBhY3RpdmVJbmRleCk7XG59O1xuZXhwb3J0IHZhciBhZGRUb1N1bmJ1cnN0Tm9kZUluZGV4ID0gZnVuY3Rpb24gYWRkVG9TdW5idXJzdE5vZGVJbmRleChpbmRleEluQ2hpbGRyZW5BcnIpIHtcbiAgdmFyIGFjdGl2ZVRvb2x0aXBJbmRleFNvRmFyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnJztcbiAgcmV0dXJuIFwiXCIuY29uY2F0KGFjdGl2ZVRvb2x0aXBJbmRleFNvRmFyLCBcImNoaWxkcmVuW1wiKS5jb25jYXQoaW5kZXhJbkNoaWxkcmVuQXJyLCBcIl1cIik7XG59O1xudmFyIHByZWxvYWRlZFN0YXRlID0ge1xuICBvcHRpb25zOiB7XG4gICAgdmFsaWRhdGVUb29sdGlwRXZlbnRUeXBlczogWydpdGVtJ10sXG4gICAgZGVmYXVsdFRvb2x0aXBFdmVudFR5cGU6ICdpdGVtJyxcbiAgICBjaGFydE5hbWU6ICdTdW5idXJzdCcsXG4gICAgdG9vbHRpcFBheWxvYWRTZWFyY2hlcjogcGF5bG9hZFNlYXJjaGVyLFxuICAgIGV2ZW50RW1pdHRlcjogdW5kZWZpbmVkXG4gIH1cbn07XG52YXIgU3VuYnVyc3RDaGFydEltcGwgPSBfcmVmMiA9PiB7XG4gIHZhciB7XG4gICAgY2xhc3NOYW1lLFxuICAgIGRhdGEsXG4gICAgY2hpbGRyZW4sXG4gICAgcGFkZGluZyA9IDIsXG4gICAgZGF0YUtleSA9ICd2YWx1ZScsXG4gICAgbmFtZUtleSA9ICduYW1lJyxcbiAgICByaW5nUGFkZGluZyA9IDIsXG4gICAgaW5uZXJSYWRpdXMgPSA1MCxcbiAgICBmaWxsID0gJyMzMzMnLFxuICAgIHN0cm9rZSA9ICcjRkZGJyxcbiAgICB0ZXh0T3B0aW9ucyA9IGRlZmF1bHRUZXh0UHJvcHMsXG4gICAgb3V0ZXJSYWRpdXM6IG91dGVyUmFkaXVzRnJvbVByb3BzLFxuICAgIGN4OiBjeEZyb21Qcm9wcyxcbiAgICBjeTogY3lGcm9tUHJvcHMsXG4gICAgc3RhcnRBbmdsZSA9IDAsXG4gICAgZW5kQW5nbGUgPSAzNjAsXG4gICAgb25DbGljayxcbiAgICBvbk1vdXNlRW50ZXIsXG4gICAgb25Nb3VzZUxlYXZlLFxuICAgIHJlc3BvbnNpdmUgPSBmYWxzZSxcbiAgICBzdHlsZVxuICB9ID0gX3JlZjI7XG4gIHZhciBkaXNwYXRjaCA9IHVzZUFwcERpc3BhdGNoKCk7XG4gIHZhciB3aWR0aCA9IHVzZUNoYXJ0V2lkdGgoKTtcbiAgdmFyIGhlaWdodCA9IHVzZUNoYXJ0SGVpZ2h0KCk7XG4gIHZhciBvdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzRnJvbVByb3BzICE9PSBudWxsICYmIG91dGVyUmFkaXVzRnJvbVByb3BzICE9PSB2b2lkIDAgPyBvdXRlclJhZGl1c0Zyb21Qcm9wcyA6IE1hdGgubWluKHdpZHRoLCBoZWlnaHQpIC8gMjtcbiAgdmFyIGN4ID0gY3hGcm9tUHJvcHMgIT09IG51bGwgJiYgY3hGcm9tUHJvcHMgIT09IHZvaWQgMCA/IGN4RnJvbVByb3BzIDogd2lkdGggLyAyO1xuICB2YXIgY3kgPSBjeUZyb21Qcm9wcyAhPT0gbnVsbCAmJiBjeUZyb21Qcm9wcyAhPT0gdm9pZCAwID8gY3lGcm9tUHJvcHMgOiBoZWlnaHQgLyAyO1xuICB2YXIgclNjYWxlID0gc2NhbGVMaW5lYXIoWzAsIGRhdGFbZGF0YUtleV1dLCBbMCwgZW5kQW5nbGVdKTtcbiAgdmFyIHRyZWVEZXB0aCA9IGdldE1heERlcHRoT2YoZGF0YSk7XG4gIHZhciB0aGlja25lc3MgPSAob3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cykgLyB0cmVlRGVwdGg7XG4gIHZhciBzZWN0b3JzID0gW107XG4gIHZhciBwb3NpdGlvbnMgPSBuZXcgTWFwKFtdKTtcbiAgdmFyIFt0b29sdGlwUG9ydGFsLCBzZXRUb29sdGlwUG9ydGFsXSA9IHVzZVN0YXRlKG51bGwpO1xuICAvLyBldmVudCBoYW5kbGVyc1xuICBmdW5jdGlvbiBoYW5kbGVNb3VzZUVudGVyKG5vZGUsIGUpIHtcbiAgICBpZiAob25Nb3VzZUVudGVyKSBvbk1vdXNlRW50ZXIobm9kZSwgZSk7XG4gICAgZGlzcGF0Y2goc2V0QWN0aXZlTW91c2VPdmVySXRlbUluZGV4KHtcbiAgICAgIGFjdGl2ZUluZGV4OiBub2RlLnRvb2x0aXBJbmRleCxcbiAgICAgIGFjdGl2ZURhdGFLZXk6IGRhdGFLZXksXG4gICAgICBhY3RpdmVDb29yZGluYXRlOiBwb3NpdGlvbnMuZ2V0KG5vZGUubmFtZSlcbiAgICB9KSk7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlTW91c2VMZWF2ZShub2RlLCBlKSB7XG4gICAgaWYgKG9uTW91c2VMZWF2ZSkgb25Nb3VzZUxlYXZlKG5vZGUsIGUpO1xuICAgIGRpc3BhdGNoKG1vdXNlTGVhdmVJdGVtKCkpO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKG5vZGUpIHtcbiAgICBpZiAob25DbGljaykgb25DbGljayhub2RlKTtcbiAgICBkaXNwYXRjaChzZXRBY3RpdmVDbGlja0l0ZW1JbmRleCh7XG4gICAgICBhY3RpdmVJbmRleDogbm9kZS50b29sdGlwSW5kZXgsXG4gICAgICBhY3RpdmVEYXRhS2V5OiBkYXRhS2V5LFxuICAgICAgYWN0aXZlQ29vcmRpbmF0ZTogcG9zaXRpb25zLmdldChub2RlLm5hbWUpXG4gICAgfSkpO1xuICB9XG5cbiAgLy8gcmVjdXJzaXZlbHkgYWRkIG5vZGVzIGZvciBlYWNoIGRhdGEgcG9pbnQgYW5kIGl0cyBjaGlsZHJlblxuICBmdW5jdGlvbiBkcmF3QXJjcyhjaGlsZE5vZGVzLCBvcHRpb25zKSB7XG4gICAgdmFyIGRlcHRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxO1xuICAgIHZhciB7XG4gICAgICByYWRpdXMsXG4gICAgICBpbm5lclIsXG4gICAgICBpbml0aWFsQW5nbGUsXG4gICAgICBjaGlsZENvbG9yLFxuICAgICAgbmVzdGVkQWN0aXZlVG9vbHRpcEluZGV4XG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIGN1cnJlbnRBbmdsZSA9IGluaXRpYWxBbmdsZTtcbiAgICBpZiAoIWNoaWxkTm9kZXMpIHJldHVybjsgLy8gYmFzZSBjYXNlOiBubyBjaGlsZHJlbiBvZiB0aGlzIG5vZGVcblxuICAgIGNoaWxkTm9kZXMuZm9yRWFjaCgoZCwgaSkgPT4ge1xuICAgICAgdmFyIF9yZWYzLCBfZCRmaWxsO1xuICAgICAgdmFyIGN1cnJlbnRUb29sdGlwSW5kZXggPSBkZXB0aCA9PT0gMSA/IFwiW1wiLmNvbmNhdChpLCBcIl1cIikgOiBhZGRUb1N1bmJ1cnN0Tm9kZUluZGV4KGksIG5lc3RlZEFjdGl2ZVRvb2x0aXBJbmRleCk7XG4gICAgICB2YXIgbm9kZVdpdGhJbmRleCA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZCksIHt9LCB7XG4gICAgICAgIHRvb2x0aXBJbmRleDogY3VycmVudFRvb2x0aXBJbmRleFxuICAgICAgfSk7XG4gICAgICB2YXIgYXJjTGVuZ3RoID0gclNjYWxlKGRbZGF0YUtleV0pO1xuICAgICAgdmFyIHN0YXJ0ID0gY3VycmVudEFuZ2xlO1xuICAgICAgLy8gY29sb3IgcHJpb3JpdHkgLSBpZiB0aGVyZSdzIGEgY29sb3Igb24gdGhlIGluZGl2aWR1YWwgcG9pbnQgdXNlIHRoYXQsIG90aGVyd2lzZSB1c2UgcGFyZW50IGNvbG9yIG9yIGRlZmF1bHRcbiAgICAgIHZhciBmaWxsQ29sb3IgPSAoX3JlZjMgPSAoX2QkZmlsbCA9IGQgPT09IG51bGwgfHwgZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZC5maWxsKSAhPT0gbnVsbCAmJiBfZCRmaWxsICE9PSB2b2lkIDAgPyBfZCRmaWxsIDogY2hpbGRDb2xvcikgIT09IG51bGwgJiYgX3JlZjMgIT09IHZvaWQgMCA/IF9yZWYzIDogZmlsbDtcbiAgICAgIHZhciB7XG4gICAgICAgIHg6IHRleHRYLFxuICAgICAgICB5OiB0ZXh0WVxuICAgICAgfSA9IHBvbGFyVG9DYXJ0ZXNpYW4oMCwgMCwgaW5uZXJSICsgcmFkaXVzIC8gMiwgLShzdGFydCArIGFyY0xlbmd0aCAtIGFyY0xlbmd0aCAvIDIpKTtcbiAgICAgIGN1cnJlbnRBbmdsZSArPSBhcmNMZW5ndGg7XG4gICAgICBzZWN0b3JzLnB1c2goXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tYXJyYXktaW5kZXgta2V5XG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZ1wiLCB7XG4gICAgICAgIGtleTogXCJzdW5idXJzdC1zZWN0b3ItXCIuY29uY2F0KGQubmFtZSwgXCItXCIpLmNvbmNhdChpKVxuICAgICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoU2VjdG9yLCB7XG4gICAgICAgIG9uQ2xpY2s6ICgpID0+IGhhbmRsZUNsaWNrKG5vZGVXaXRoSW5kZXgpLFxuICAgICAgICBvbk1vdXNlRW50ZXI6IGUgPT4gaGFuZGxlTW91c2VFbnRlcihub2RlV2l0aEluZGV4LCBlKSxcbiAgICAgICAgb25Nb3VzZUxlYXZlOiBlID0+IGhhbmRsZU1vdXNlTGVhdmUobm9kZVdpdGhJbmRleCwgZSksXG4gICAgICAgIGZpbGw6IGZpbGxDb2xvcixcbiAgICAgICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgICAgIHN0cm9rZVdpZHRoOiBwYWRkaW5nLFxuICAgICAgICBzdGFydEFuZ2xlOiBzdGFydCxcbiAgICAgICAgZW5kQW5nbGU6IHN0YXJ0ICsgYXJjTGVuZ3RoLFxuICAgICAgICBpbm5lclJhZGl1czogaW5uZXJSLFxuICAgICAgICBvdXRlclJhZGl1czogaW5uZXJSICsgcmFkaXVzLFxuICAgICAgICBjeDogY3gsXG4gICAgICAgIGN5OiBjeVxuICAgICAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFRleHQsIF9leHRlbmRzKHt9LCB0ZXh0T3B0aW9ucywge1xuICAgICAgICBhbGlnbm1lbnRCYXNlbGluZTogXCJtaWRkbGVcIixcbiAgICAgICAgdGV4dEFuY2hvcjogXCJtaWRkbGVcIixcbiAgICAgICAgeDogdGV4dFggKyBjeCxcbiAgICAgICAgeTogY3kgLSB0ZXh0WVxuICAgICAgfSksIGRbZGF0YUtleV0pKSk7XG4gICAgICB2YXIge1xuICAgICAgICB4OiB0b29sdGlwWCxcbiAgICAgICAgeTogdG9vbHRpcFlcbiAgICAgIH0gPSBwb2xhclRvQ2FydGVzaWFuKGN4LCBjeSwgaW5uZXJSICsgcmFkaXVzIC8gMiwgc3RhcnQpO1xuICAgICAgcG9zaXRpb25zLnNldChkLm5hbWUsIHtcbiAgICAgICAgeDogdG9vbHRpcFgsXG4gICAgICAgIHk6IHRvb2x0aXBZXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkcmF3QXJjcyhkLmNoaWxkcmVuLCB7XG4gICAgICAgIHJhZGl1cyxcbiAgICAgICAgaW5uZXJSOiBpbm5lclIgKyByYWRpdXMgKyByaW5nUGFkZGluZyxcbiAgICAgICAgaW5pdGlhbEFuZ2xlOiBzdGFydCxcbiAgICAgICAgY2hpbGRDb2xvcjogZmlsbENvbG9yLFxuICAgICAgICBuZXN0ZWRBY3RpdmVUb29sdGlwSW5kZXg6IGN1cnJlbnRUb29sdGlwSW5kZXhcbiAgICAgIH0sIGRlcHRoICsgMSk7XG4gICAgfSk7XG4gIH1cbiAgZHJhd0FyY3MoZGF0YS5jaGlsZHJlbiwge1xuICAgIHJhZGl1czogdGhpY2tuZXNzLFxuICAgIGlubmVyUjogaW5uZXJSYWRpdXMsXG4gICAgaW5pdGlhbEFuZ2xlOiBzdGFydEFuZ2xlXG4gIH0pO1xuICB2YXIgbGF5ZXJDbGFzcyA9IGNsc3goJ3JlY2hhcnRzLXN1bmJ1cnN0JywgY2xhc3NOYW1lKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFRvb2x0aXBQb3J0YWxDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHRvb2x0aXBQb3J0YWxcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVjaGFydHNXcmFwcGVyLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHJlc3BvbnNpdmU6IHJlc3BvbnNpdmUsXG4gICAgc3R5bGU6IHN0eWxlLFxuICAgIHJlZjogbm9kZSA9PiB7XG4gICAgICBpZiAodG9vbHRpcFBvcnRhbCA9PSBudWxsICYmIG5vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRUb29sdGlwUG9ydGFsKG5vZGUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgb25Nb3VzZUVudGVyOiB1bmRlZmluZWQsXG4gICAgb25Nb3VzZUxlYXZlOiB1bmRlZmluZWQsXG4gICAgb25DbGljazogdW5kZWZpbmVkLFxuICAgIG9uTW91c2VNb3ZlOiB1bmRlZmluZWQsXG4gICAgb25Nb3VzZURvd246IHVuZGVmaW5lZCxcbiAgICBvbk1vdXNlVXA6IHVuZGVmaW5lZCxcbiAgICBvbkNvbnRleHRNZW51OiB1bmRlZmluZWQsXG4gICAgb25Eb3VibGVDbGljazogdW5kZWZpbmVkLFxuICAgIG9uVG91Y2hTdGFydDogdW5kZWZpbmVkLFxuICAgIG9uVG91Y2hNb3ZlOiB1bmRlZmluZWQsXG4gICAgb25Ub3VjaEVuZDogdW5kZWZpbmVkXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFN1cmZhY2UsIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTGF5ZXIsIHtcbiAgICBjbGFzc05hbWU6IGxheWVyQ2xhc3NcbiAgfSwgc2VjdG9ycyksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFNldFRvb2x0aXBFbnRyeVNldHRpbmdzLCB7XG4gICAgZm46IGdldFRvb2x0aXBFbnRyeVNldHRpbmdzLFxuICAgIGFyZ3M6IHtcbiAgICAgIGRhdGFLZXksXG4gICAgICBkYXRhLFxuICAgICAgc3Ryb2tlLFxuICAgICAgZmlsbCxcbiAgICAgIG5hbWVLZXksXG4gICAgICBwb3NpdGlvbnNcbiAgICB9XG4gIH0pLCBjaGlsZHJlbikpKTtcbn07XG5leHBvcnQgdmFyIFN1bmJ1cnN0Q2hhcnQgPSBwcm9wcyA9PiB7XG4gIHZhciBfcHJvcHMkY2xhc3NOYW1lO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVjaGFydHNTdG9yZVByb3ZpZGVyLCB7XG4gICAgcHJlbG9hZGVkU3RhdGU6IHByZWxvYWRlZFN0YXRlLFxuICAgIHJlZHV4U3RvcmVOYW1lOiAoX3Byb3BzJGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSkgIT09IG51bGwgJiYgX3Byb3BzJGNsYXNzTmFtZSAhPT0gdm9pZCAwID8gX3Byb3BzJGNsYXNzTmFtZSA6ICdTdW5idXJzdENoYXJ0J1xuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZXBvcnRDaGFydFNpemUsIHtcbiAgICB3aWR0aDogcHJvcHMud2lkdGgsXG4gICAgaGVpZ2h0OiBwcm9wcy5oZWlnaHRcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlcG9ydENoYXJ0TWFyZ2luLCB7XG4gICAgbWFyZ2luOiBkZWZhdWx0U3VuYnVyc3RNYXJnaW5cbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFN1bmJ1cnN0Q2hhcnRJbXBsLCBwcm9wcykpO1xufTsiLCJ2YXIgX2V4Y2x1ZGVkID0gW1wid2lkdGhcIiwgXCJoZWlnaHRcIiwgXCJjbGFzc05hbWVcIiwgXCJzdHlsZVwiLCBcImNoaWxkcmVuXCIsIFwidHlwZVwiXTtcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhlLCB0KSB7IGlmIChudWxsID09IGUpIHJldHVybiB7fTsgdmFyIG8sIHIsIGkgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShlLCB0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG4gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyBmb3IgKHIgPSAwOyByIDwgbi5sZW5ndGg7IHIrKykgbyA9IG5bcl0sIC0xID09PSB0LmluZGV4T2YobykgJiYge30ucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlLCBvKSAmJiAoaVtvXSA9IGVbb10pOyB9IHJldHVybiBpOyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShyLCBlKSB7IGlmIChudWxsID09IHIpIHJldHVybiB7fTsgdmFyIHQgPSB7fTsgZm9yICh2YXIgbiBpbiByKSBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChyLCBuKSkgeyBpZiAoLTEgIT09IGUuaW5kZXhPZihuKSkgY29udGludWU7IHRbbl0gPSByW25dOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgcmV0dXJuIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKG4pIHsgZm9yICh2YXIgZSA9IDE7IGUgPCBhcmd1bWVudHMubGVuZ3RoOyBlKyspIHsgdmFyIHQgPSBhcmd1bWVudHNbZV07IGZvciAodmFyIHIgaW4gdCkgKHt9KS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsIHIpICYmIChuW3JdID0gdFtyXSk7IH0gcmV0dXJuIG47IH0sIF9leHRlbmRzLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHsgcmV0dXJuIChyID0gX3RvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgeyB2YWx1ZTogdCwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbcl0gPSB0LCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSB0eXBlb2YgaSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIGkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUHVyZUNvbXBvbmVudCwgdXNlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IG9taXQgZnJvbSAnZXMtdG9vbGtpdC9jb21wYXQvb21pdCc7XG5pbXBvcnQgZ2V0IGZyb20gJ2VzLXRvb2xraXQvY29tcGF0L2dldCc7XG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uL2NvbnRhaW5lci9MYXllcic7XG5pbXBvcnQgeyBTdXJmYWNlIH0gZnJvbSAnLi4vY29udGFpbmVyL1N1cmZhY2UnO1xuaW1wb3J0IHsgUG9seWdvbiB9IGZyb20gJy4uL3NoYXBlL1BvbHlnb24nO1xuaW1wb3J0IHsgUmVjdGFuZ2xlIH0gZnJvbSAnLi4vc2hhcGUvUmVjdGFuZ2xlJztcbmltcG9ydCB7IGdldFZhbHVlQnlEYXRhS2V5IH0gZnJvbSAnLi4vdXRpbC9DaGFydFV0aWxzJztcbmltcG9ydCB7IENPTE9SX1BBTkVMIH0gZnJvbSAnLi4vdXRpbC9Db25zdGFudHMnO1xuaW1wb3J0IHsgaXNOYW4sIHVuaXF1ZUlkIH0gZnJvbSAnLi4vdXRpbC9EYXRhVXRpbHMnO1xuaW1wb3J0IHsgZ2V0U3RyaW5nU2l6ZSB9IGZyb20gJy4uL3V0aWwvRE9NVXRpbHMnO1xuaW1wb3J0IHsgR2xvYmFsIH0gZnJvbSAnLi4vdXRpbC9HbG9iYWwnO1xuaW1wb3J0IHsgUmVwb3J0Q2hhcnRNYXJnaW4sIHVzZUNoYXJ0SGVpZ2h0LCB1c2VDaGFydFdpZHRoIH0gZnJvbSAnLi4vY29udGV4dC9jaGFydExheW91dENvbnRleHQnO1xuaW1wb3J0IHsgVG9vbHRpcFBvcnRhbENvbnRleHQgfSBmcm9tICcuLi9jb250ZXh0L3Rvb2x0aXBQb3J0YWxDb250ZXh0JztcbmltcG9ydCB7IFJlY2hhcnRzV3JhcHBlciB9IGZyb20gJy4vUmVjaGFydHNXcmFwcGVyJztcbmltcG9ydCB7IHNldEFjdGl2ZUNsaWNrSXRlbUluZGV4LCBzZXRBY3RpdmVNb3VzZU92ZXJJdGVtSW5kZXggfSBmcm9tICcuLi9zdGF0ZS90b29sdGlwU2xpY2UnO1xuaW1wb3J0IHsgU2V0VG9vbHRpcEVudHJ5U2V0dGluZ3MgfSBmcm9tICcuLi9zdGF0ZS9TZXRUb29sdGlwRW50cnlTZXR0aW5ncyc7XG5pbXBvcnQgeyBSZWNoYXJ0c1N0b3JlUHJvdmlkZXIgfSBmcm9tICcuLi9zdGF0ZS9SZWNoYXJ0c1N0b3JlUHJvdmlkZXInO1xuaW1wb3J0IHsgdXNlQXBwRGlzcGF0Y2ggfSBmcm9tICcuLi9zdGF0ZS9ob29rcyc7XG5pbXBvcnQgeyBpc1Bvc2l0aXZlTnVtYmVyIH0gZnJvbSAnLi4vdXRpbC9pc1dlbGxCZWhhdmVkTnVtYmVyJztcbmltcG9ydCB7IHN2Z1Byb3BlcnRpZXNOb0V2ZW50cyB9IGZyb20gJy4uL3V0aWwvc3ZnUHJvcGVydGllc05vRXZlbnRzJztcbmltcG9ydCB7IENTU1RyYW5zaXRpb25BbmltYXRlIH0gZnJvbSAnLi4vYW5pbWF0aW9uL0NTU1RyYW5zaXRpb25BbmltYXRlJztcbmltcG9ydCB7IHJlc29sdmVEZWZhdWx0UHJvcHMgfSBmcm9tICcuLi91dGlsL3Jlc29sdmVEZWZhdWx0UHJvcHMnO1xudmFyIE5PREVfVkFMVUVfS0VZID0gJ3ZhbHVlJztcblxuLyoqXG4gKiBUaGlzIGlzIHdoYXQgZW5kIHVzZXJzIGRlZmluZXMgYXMgYGRhdGFgIG9uIFRyZWVtYXAuXG4gKi9cblxuLyoqXG4gKiBUaGlzIGlzIHdoYXQgaXMgcmV0dXJuZWQgZnJvbSBgc3F1YXJpZnlgLCB0aGUgZmluYWwgdHJlZW1hcCBkYXRhIHN0cnVjdHVyZVxuICogdGhhdCBnZXRzIHJlbmRlcmVkIGFuZCBpcyBzdG9yZWQgaW5cbiAqL1xuXG5leHBvcnQgdmFyIHRyZWVtYXBQYXlsb2FkU2VhcmNoZXIgPSAoZGF0YSwgYWN0aXZlSW5kZXgpID0+IHtcbiAgaWYgKCFkYXRhIHx8ICFhY3RpdmVJbmRleCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIGdldChkYXRhLCBhY3RpdmVJbmRleCk7XG59O1xuZXhwb3J0IHZhciBhZGRUb1RyZWVtYXBOb2RlSW5kZXggPSBmdW5jdGlvbiBhZGRUb1RyZWVtYXBOb2RlSW5kZXgoaW5kZXhJbkNoaWxkcmVuQXJyKSB7XG4gIHZhciBhY3RpdmVUb29sdGlwSW5kZXhTb0ZhciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJyc7XG4gIHJldHVybiBcIlwiLmNvbmNhdChhY3RpdmVUb29sdGlwSW5kZXhTb0ZhciwgXCJjaGlsZHJlbltcIikuY29uY2F0KGluZGV4SW5DaGlsZHJlbkFyciwgXCJdXCIpO1xufTtcbnZhciBvcHRpb25zID0ge1xuICBjaGFydE5hbWU6ICdUcmVlbWFwJyxcbiAgZGVmYXVsdFRvb2x0aXBFdmVudFR5cGU6ICdpdGVtJyxcbiAgdmFsaWRhdGVUb29sdGlwRXZlbnRUeXBlczogWydpdGVtJ10sXG4gIHRvb2x0aXBQYXlsb2FkU2VhcmNoZXI6IHRyZWVtYXBQYXlsb2FkU2VhcmNoZXIsXG4gIGV2ZW50RW1pdHRlcjogdW5kZWZpbmVkXG59O1xuZXhwb3J0IHZhciBjb21wdXRlTm9kZSA9IF9yZWYgPT4ge1xuICB2YXIge1xuICAgIGRlcHRoLFxuICAgIG5vZGUsXG4gICAgaW5kZXgsXG4gICAgZGF0YUtleSxcbiAgICBuYW1lS2V5LFxuICAgIG5lc3RlZEFjdGl2ZVRvb2x0aXBJbmRleFxuICB9ID0gX3JlZjtcbiAgdmFyIGN1cnJlbnRUb29sdGlwSW5kZXggPSBkZXB0aCA9PT0gMCA/ICcnIDogYWRkVG9UcmVlbWFwTm9kZUluZGV4KGluZGV4LCBuZXN0ZWRBY3RpdmVUb29sdGlwSW5kZXgpO1xuICB2YXIge1xuICAgIGNoaWxkcmVuXG4gIH0gPSBub2RlO1xuICB2YXIgY2hpbGREZXB0aCA9IGRlcHRoICsgMTtcbiAgdmFyIGNvbXB1dGVkQ2hpbGRyZW4gPSBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGggPyBjaGlsZHJlbi5tYXAoKGNoaWxkLCBpKSA9PiBjb21wdXRlTm9kZSh7XG4gICAgZGVwdGg6IGNoaWxkRGVwdGgsXG4gICAgbm9kZTogY2hpbGQsXG4gICAgaW5kZXg6IGksXG4gICAgZGF0YUtleSxcbiAgICBuYW1lS2V5LFxuICAgIG5lc3RlZEFjdGl2ZVRvb2x0aXBJbmRleDogY3VycmVudFRvb2x0aXBJbmRleFxuICB9KSkgOiBudWxsO1xuICB2YXIgbm9kZVZhbHVlO1xuICBpZiAoY29tcHV0ZWRDaGlsZHJlbiAmJiBjb21wdXRlZENoaWxkcmVuLmxlbmd0aCkge1xuICAgIG5vZGVWYWx1ZSA9IGNvbXB1dGVkQ2hpbGRyZW4ucmVkdWNlKChyZXN1bHQsIGNoaWxkKSA9PiByZXN1bHQgKyBjaGlsZFtOT0RFX1ZBTFVFX0tFWV0sIDApO1xuICB9IGVsc2Uge1xuICAgIC8vIFRPRE8gbmVlZCB0byB2ZXJpZnkgZGF0YUtleVxuICAgIG5vZGVWYWx1ZSA9IGlzTmFuKG5vZGVbZGF0YUtleV0pIHx8IG5vZGVbZGF0YUtleV0gPD0gMCA/IDAgOiBub2RlW2RhdGFLZXldO1xuICB9XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG5vZGUpLCB7fSwge1xuICAgIGNoaWxkcmVuOiBjb21wdXRlZENoaWxkcmVuLFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZ2V0VmFsdWVCeURhdGFLZXkgZG9lcyBub3QgdmFsaWRhdGUgdGhlIG91dHB1dCB0eXBlXG4gICAgbmFtZTogZ2V0VmFsdWVCeURhdGFLZXkobm9kZSwgbmFtZUtleSwgJycpLFxuICAgIFtOT0RFX1ZBTFVFX0tFWV06IG5vZGVWYWx1ZSxcbiAgICBkZXB0aCxcbiAgICBpbmRleCxcbiAgICB0b29sdGlwSW5kZXg6IGN1cnJlbnRUb29sdGlwSW5kZXhcbiAgfSk7XG59O1xudmFyIGZpbHRlclJlY3QgPSBub2RlID0+ICh7XG4gIHg6IG5vZGUueCxcbiAgeTogbm9kZS55LFxuICB3aWR0aDogbm9kZS53aWR0aCxcbiAgaGVpZ2h0OiBub2RlLmhlaWdodFxufSk7XG4vLyBDb21wdXRlIHRoZSBhcmVhIGZvciBlYWNoIGNoaWxkIGJhc2VkIG9uIHZhbHVlICYgc2NhbGUuXG52YXIgZ2V0QXJlYU9mQ2hpbGRyZW4gPSAoY2hpbGRyZW4sIGFyZWFWYWx1ZVJhdGlvKSA9PiB7XG4gIHZhciByYXRpbyA9IGFyZWFWYWx1ZVJhdGlvIDwgMCA/IDAgOiBhcmVhVmFsdWVSYXRpbztcbiAgcmV0dXJuIGNoaWxkcmVuLm1hcChjaGlsZCA9PiB7XG4gICAgdmFyIGFyZWEgPSBjaGlsZFtOT0RFX1ZBTFVFX0tFWV0gKiByYXRpbztcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBjaGlsZCksIHt9LCB7XG4gICAgICBhcmVhOiBpc05hbihhcmVhKSB8fCBhcmVhIDw9IDAgPyAwIDogYXJlYVxuICAgIH0pO1xuICB9KTtcbn07XG5cbi8vIENvbXB1dGVzIHRoZSBzY29yZSBmb3IgdGhlIHNwZWNpZmllZCByb3csIGFzIHRoZSB3b3JzdCBhc3BlY3QgcmF0aW8uXG52YXIgZ2V0V29yc3RTY29yZSA9IChyb3csIHBhcmVudFNpemUsIGFzcGVjdFJhdGlvKSA9PiB7XG4gIHZhciBwYXJlbnRBcmVhID0gcGFyZW50U2l6ZSAqIHBhcmVudFNpemU7XG4gIHZhciByb3dBcmVhID0gcm93LmFyZWEgKiByb3cuYXJlYTtcbiAgdmFyIHtcbiAgICBtaW4sXG4gICAgbWF4XG4gIH0gPSByb3cucmVkdWNlKChyZXN1bHQsIGNoaWxkKSA9PiAoe1xuICAgIG1pbjogTWF0aC5taW4ocmVzdWx0Lm1pbiwgY2hpbGQuYXJlYSksXG4gICAgbWF4OiBNYXRoLm1heChyZXN1bHQubWF4LCBjaGlsZC5hcmVhKVxuICB9KSwge1xuICAgIG1pbjogSW5maW5pdHksXG4gICAgbWF4OiAwXG4gIH0pO1xuICByZXR1cm4gcm93QXJlYSA/IE1hdGgubWF4KHBhcmVudEFyZWEgKiBtYXggKiBhc3BlY3RSYXRpbyAvIHJvd0FyZWEsIHJvd0FyZWEgLyAocGFyZW50QXJlYSAqIG1pbiAqIGFzcGVjdFJhdGlvKSkgOiBJbmZpbml0eTtcbn07XG52YXIgaG9yaXpvbnRhbFBvc2l0aW9uID0gKHJvdywgcGFyZW50U2l6ZSwgcGFyZW50UmVjdCwgaXNGbHVzaCkgPT4ge1xuICB2YXIgcm93SGVpZ2h0ID0gcGFyZW50U2l6ZSA/IE1hdGgucm91bmQocm93LmFyZWEgLyBwYXJlbnRTaXplKSA6IDA7XG4gIGlmIChpc0ZsdXNoIHx8IHJvd0hlaWdodCA+IHBhcmVudFJlY3QuaGVpZ2h0KSB7XG4gICAgcm93SGVpZ2h0ID0gcGFyZW50UmVjdC5oZWlnaHQ7XG4gIH1cbiAgdmFyIGN1clggPSBwYXJlbnRSZWN0Lng7XG4gIHZhciBjaGlsZDtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJvdy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNoaWxkID0gcm93W2ldO1xuICAgIGNoaWxkLnggPSBjdXJYO1xuICAgIGNoaWxkLnkgPSBwYXJlbnRSZWN0Lnk7XG4gICAgY2hpbGQuaGVpZ2h0ID0gcm93SGVpZ2h0O1xuICAgIGNoaWxkLndpZHRoID0gTWF0aC5taW4ocm93SGVpZ2h0ID8gTWF0aC5yb3VuZChjaGlsZC5hcmVhIC8gcm93SGVpZ2h0KSA6IDAsIHBhcmVudFJlY3QueCArIHBhcmVudFJlY3Qud2lkdGggLSBjdXJYKTtcbiAgICBjdXJYICs9IGNoaWxkLndpZHRoO1xuICB9XG4gIC8vIGFkZCB0aGUgcmVtYWluIHggdG8gdGhlIGxhc3Qgb25lIG9mIHJvd1xuICBpZiAoY2hpbGQgIT0gbnVsbCkge1xuICAgIGNoaWxkLndpZHRoICs9IHBhcmVudFJlY3QueCArIHBhcmVudFJlY3Qud2lkdGggLSBjdXJYO1xuICB9XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHBhcmVudFJlY3QpLCB7fSwge1xuICAgIHk6IHBhcmVudFJlY3QueSArIHJvd0hlaWdodCxcbiAgICBoZWlnaHQ6IHBhcmVudFJlY3QuaGVpZ2h0IC0gcm93SGVpZ2h0XG4gIH0pO1xufTtcbnZhciB2ZXJ0aWNhbFBvc2l0aW9uID0gKHJvdywgcGFyZW50U2l6ZSwgcGFyZW50UmVjdCwgaXNGbHVzaCkgPT4ge1xuICB2YXIgcm93V2lkdGggPSBwYXJlbnRTaXplID8gTWF0aC5yb3VuZChyb3cuYXJlYSAvIHBhcmVudFNpemUpIDogMDtcbiAgaWYgKGlzRmx1c2ggfHwgcm93V2lkdGggPiBwYXJlbnRSZWN0LndpZHRoKSB7XG4gICAgcm93V2lkdGggPSBwYXJlbnRSZWN0LndpZHRoO1xuICB9XG4gIHZhciBjdXJZID0gcGFyZW50UmVjdC55O1xuICB2YXIgY2hpbGQ7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSByb3cubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjaGlsZCA9IHJvd1tpXTtcbiAgICBjaGlsZC54ID0gcGFyZW50UmVjdC54O1xuICAgIGNoaWxkLnkgPSBjdXJZO1xuICAgIGNoaWxkLndpZHRoID0gcm93V2lkdGg7XG4gICAgY2hpbGQuaGVpZ2h0ID0gTWF0aC5taW4ocm93V2lkdGggPyBNYXRoLnJvdW5kKGNoaWxkLmFyZWEgLyByb3dXaWR0aCkgOiAwLCBwYXJlbnRSZWN0LnkgKyBwYXJlbnRSZWN0LmhlaWdodCAtIGN1clkpO1xuICAgIGN1clkgKz0gY2hpbGQuaGVpZ2h0O1xuICB9XG4gIGlmIChjaGlsZCkge1xuICAgIGNoaWxkLmhlaWdodCArPSBwYXJlbnRSZWN0LnkgKyBwYXJlbnRSZWN0LmhlaWdodCAtIGN1clk7XG4gIH1cbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcGFyZW50UmVjdCksIHt9LCB7XG4gICAgeDogcGFyZW50UmVjdC54ICsgcm93V2lkdGgsXG4gICAgd2lkdGg6IHBhcmVudFJlY3Qud2lkdGggLSByb3dXaWR0aFxuICB9KTtcbn07XG52YXIgcG9zaXRpb24gPSAocm93LCBwYXJlbnRTaXplLCBwYXJlbnRSZWN0LCBpc0ZsdXNoKSA9PiB7XG4gIGlmIChwYXJlbnRTaXplID09PSBwYXJlbnRSZWN0LndpZHRoKSB7XG4gICAgcmV0dXJuIGhvcml6b250YWxQb3NpdGlvbihyb3csIHBhcmVudFNpemUsIHBhcmVudFJlY3QsIGlzRmx1c2gpO1xuICB9XG4gIHJldHVybiB2ZXJ0aWNhbFBvc2l0aW9uKHJvdywgcGFyZW50U2l6ZSwgcGFyZW50UmVjdCwgaXNGbHVzaCk7XG59O1xuLy8gUmVjdXJzaXZlbHkgYXJyYW5nZXMgdGhlIHNwZWNpZmllZCBub2RlJ3MgY2hpbGRyZW4gaW50byBzcXVhcmlmaWVkIHJvd3MuXG52YXIgc3F1YXJpZnkgPSAobm9kZSwgYXNwZWN0UmF0aW8pID0+IHtcbiAgdmFyIHtcbiAgICBjaGlsZHJlblxuICB9ID0gbm9kZTtcbiAgaWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIHZhciByZWN0ID0gZmlsdGVyUmVjdChub2RlKTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHdlIGNhbid0IGNyZWF0ZSBhbiBhcnJheSB3aXRoIHN0YXRpYyBwcm9wZXJ0eSBvbiBhIHNpbmdsZSBsaW5lIHNvIHR5cGVzY3JpcHQgd2lsbCBjb21wbGFpbi5cbiAgICB2YXIgcm93ID0gW107XG4gICAgdmFyIGJlc3QgPSBJbmZpbml0eTsgLy8gdGhlIGJlc3Qgcm93IHNjb3JlIHNvIGZhclxuICAgIHZhciBjaGlsZCwgc2NvcmU7IC8vIHRoZSBjdXJyZW50IHJvdyBzY29yZVxuICAgIHZhciBzaXplID0gTWF0aC5taW4ocmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpOyAvLyBpbml0aWFsIG9yaWVudGF0aW9uXG4gICAgdmFyIHNjYWxlQ2hpbGRyZW4gPSBnZXRBcmVhT2ZDaGlsZHJlbihjaGlsZHJlbiwgcmVjdC53aWR0aCAqIHJlY3QuaGVpZ2h0IC8gbm9kZVtOT0RFX1ZBTFVFX0tFWV0pO1xuICAgIHZhciB0ZW1wQ2hpbGRyZW4gPSBzY2FsZUNoaWxkcmVuLnNsaWNlKCk7XG5cbiAgICAvLyB3aHkgYXJlIHdlIHNldHRpbmcgc3RhdGljIHByb3BlcnRpZXMgb24gYW4gYXJyYXk/XG4gICAgcm93LmFyZWEgPSAwO1xuICAgIHdoaWxlICh0ZW1wQ2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgLy8gcm93IGZpcnN0XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgIHJvdy5wdXNoKGNoaWxkID0gdGVtcENoaWxkcmVuWzBdKTtcbiAgICAgIHJvdy5hcmVhICs9IGNoaWxkLmFyZWE7XG4gICAgICBzY29yZSA9IGdldFdvcnN0U2NvcmUocm93LCBzaXplLCBhc3BlY3RSYXRpbyk7XG4gICAgICBpZiAoc2NvcmUgPD0gYmVzdCkge1xuICAgICAgICAvLyBjb250aW51ZSB3aXRoIHRoaXMgb3JpZW50YXRpb25cbiAgICAgICAgdGVtcENoaWxkcmVuLnNoaWZ0KCk7XG4gICAgICAgIGJlc3QgPSBzY29yZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfcm93JHBvcCRhcmVhLCBfcm93JHBvcDtcbiAgICAgICAgLy8gYWJvcnQsIGFuZCB0cnkgYSBkaWZmZXJlbnQgb3JpZW50YXRpb25cbiAgICAgICAgcm93LmFyZWEgLT0gKF9yb3ckcG9wJGFyZWEgPSAoX3JvdyRwb3AgPSByb3cucG9wKCkpID09PSBudWxsIHx8IF9yb3ckcG9wID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcm93JHBvcC5hcmVhKSAhPT0gbnVsbCAmJiBfcm93JHBvcCRhcmVhICE9PSB2b2lkIDAgPyBfcm93JHBvcCRhcmVhIDogMDtcbiAgICAgICAgcmVjdCA9IHBvc2l0aW9uKHJvdywgc2l6ZSwgcmVjdCwgZmFsc2UpO1xuICAgICAgICBzaXplID0gTWF0aC5taW4ocmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuICAgICAgICByb3cubGVuZ3RoID0gcm93LmFyZWEgPSAwO1xuICAgICAgICBiZXN0ID0gSW5maW5pdHk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyb3cubGVuZ3RoKSB7XG4gICAgICByZWN0ID0gcG9zaXRpb24ocm93LCBzaXplLCByZWN0LCB0cnVlKTtcbiAgICAgIHJvdy5sZW5ndGggPSByb3cuYXJlYSA9IDA7XG4gICAgfVxuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG5vZGUpLCB7fSwge1xuICAgICAgY2hpbGRyZW46IHNjYWxlQ2hpbGRyZW4ubWFwKGMgPT4gc3F1YXJpZnkoYywgYXNwZWN0UmF0aW8pKVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBub2RlO1xufTtcbnZhciBkZWZhdWx0VHJlZU1hcFByb3BzID0ge1xuICBhc3BlY3RSYXRpbzogMC41ICogKDEgKyBNYXRoLnNxcnQoNSkpLFxuICBkYXRhS2V5OiAndmFsdWUnLFxuICBuYW1lS2V5OiAnbmFtZScsXG4gIHR5cGU6ICdmbGF0JyxcbiAgaXNBbmltYXRpb25BY3RpdmU6ICFHbG9iYWwuaXNTc3IsXG4gIGlzVXBkYXRlQW5pbWF0aW9uQWN0aXZlOiAhR2xvYmFsLmlzU3NyLFxuICBhbmltYXRpb25CZWdpbjogMCxcbiAgYW5pbWF0aW9uRHVyYXRpb246IDE1MDAsXG4gIGFuaW1hdGlvbkVhc2luZzogJ2xpbmVhcidcbn07XG52YXIgZGVmYXVsdFN0YXRlID0ge1xuICBpc0FuaW1hdGlvbkZpbmlzaGVkOiBmYWxzZSxcbiAgZm9ybWF0Um9vdDogbnVsbCxcbiAgY3VycmVudFJvb3Q6IG51bGwsXG4gIG5lc3RJbmRleDogW10sXG4gIHByZXZBc3BlY3RSYXRpbzogZGVmYXVsdFRyZWVNYXBQcm9wcy5hc3BlY3RSYXRpbyxcbiAgcHJldkRhdGFLZXk6IGRlZmF1bHRUcmVlTWFwUHJvcHMuZGF0YUtleVxufTtcbmZ1bmN0aW9uIENvbnRlbnRJdGVtKF9yZWYyKSB7XG4gIHZhciB7XG4gICAgY29udGVudCxcbiAgICBub2RlUHJvcHMsXG4gICAgdHlwZSxcbiAgICBjb2xvclBhbmVsLFxuICAgIG9uTW91c2VFbnRlcixcbiAgICBvbk1vdXNlTGVhdmUsXG4gICAgb25DbGlja1xuICB9ID0gX3JlZjI7XG4gIGlmICgvKiNfX1BVUkVfXyovUmVhY3QuaXNWYWxpZEVsZW1lbnQoY29udGVudCkpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTGF5ZXIsIHtcbiAgICAgIG9uTW91c2VFbnRlcjogb25Nb3VzZUVudGVyLFxuICAgICAgb25Nb3VzZUxlYXZlOiBvbk1vdXNlTGVhdmUsXG4gICAgICBvbkNsaWNrOiBvbkNsaWNrXG4gICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChjb250ZW50LCBub2RlUHJvcHMpKTtcbiAgfVxuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTGF5ZXIsIHtcbiAgICAgIG9uTW91c2VFbnRlcjogb25Nb3VzZUVudGVyLFxuICAgICAgb25Nb3VzZUxlYXZlOiBvbk1vdXNlTGVhdmUsXG4gICAgICBvbkNsaWNrOiBvbkNsaWNrXG4gICAgfSwgY29udGVudChub2RlUHJvcHMpKTtcbiAgfVxuICAvLyBvcHRpbWl6ZSBkZWZhdWx0IHNoYXBlXG4gIHZhciB7XG4gICAgeCxcbiAgICB5LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBpbmRleFxuICB9ID0gbm9kZVByb3BzO1xuICB2YXIgYXJyb3cgPSBudWxsO1xuICBpZiAod2lkdGggPiAxMCAmJiBoZWlnaHQgPiAxMCAmJiBub2RlUHJvcHMuY2hpbGRyZW4gJiYgdHlwZSA9PT0gJ25lc3QnKSB7XG4gICAgYXJyb3cgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChQb2x5Z29uLCB7XG4gICAgICBwb2ludHM6IFt7XG4gICAgICAgIHg6IHggKyAyLFxuICAgICAgICB5OiB5ICsgaGVpZ2h0IC8gMlxuICAgICAgfSwge1xuICAgICAgICB4OiB4ICsgNixcbiAgICAgICAgeTogeSArIGhlaWdodCAvIDIgKyAzXG4gICAgICB9LCB7XG4gICAgICAgIHg6IHggKyAyLFxuICAgICAgICB5OiB5ICsgaGVpZ2h0IC8gMiArIDZcbiAgICAgIH1dXG4gICAgfSk7XG4gIH1cbiAgdmFyIHRleHQgPSBudWxsO1xuICB2YXIgbmFtZVNpemUgPSBnZXRTdHJpbmdTaXplKG5vZGVQcm9wcy5uYW1lKTtcbiAgaWYgKHdpZHRoID4gMjAgJiYgaGVpZ2h0ID4gMjAgJiYgbmFtZVNpemUud2lkdGggPCB3aWR0aCAmJiBuYW1lU2l6ZS5oZWlnaHQgPCBoZWlnaHQpIHtcbiAgICB0ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0XCIsIHtcbiAgICAgIHg6IHggKyA4LFxuICAgICAgeTogeSArIGhlaWdodCAvIDIgKyA3LFxuICAgICAgZm9udFNpemU6IDE0XG4gICAgfSwgbm9kZVByb3BzLm5hbWUpO1xuICB9XG4gIHZhciBjb2xvcnMgPSBjb2xvclBhbmVsIHx8IENPTE9SX1BBTkVMO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJnXCIsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlY3RhbmdsZSwgX2V4dGVuZHMoe1xuICAgIGZpbGw6IG5vZGVQcm9wcy5kZXB0aCA8IDIgPyBjb2xvcnNbaW5kZXggJSBjb2xvcnMubGVuZ3RoXSA6ICdyZ2JhKDI1NSwyNTUsMjU1LDApJyxcbiAgICBzdHJva2U6IFwiI2ZmZlwiXG4gIH0sIG9taXQobm9kZVByb3BzLCBbJ2NoaWxkcmVuJ10pLCB7XG4gICAgb25Nb3VzZUVudGVyOiBvbk1vdXNlRW50ZXIsXG4gICAgb25Nb3VzZUxlYXZlOiBvbk1vdXNlTGVhdmUsXG4gICAgb25DbGljazogb25DbGljayxcbiAgICBcImRhdGEtcmVjaGFydHMtaXRlbS1pbmRleFwiOiBub2RlUHJvcHMudG9vbHRpcEluZGV4XG4gIH0pKSwgYXJyb3csIHRleHQpO1xufVxuZnVuY3Rpb24gQ29udGVudEl0ZW1XaXRoRXZlbnRzKHByb3BzKSB7XG4gIHZhciBkaXNwYXRjaCA9IHVzZUFwcERpc3BhdGNoKCk7XG4gIHZhciBhY3RpdmVDb29yZGluYXRlID0ge1xuICAgIHg6IHByb3BzLm5vZGVQcm9wcy54ICsgcHJvcHMubm9kZVByb3BzLndpZHRoIC8gMixcbiAgICB5OiBwcm9wcy5ub2RlUHJvcHMueSArIHByb3BzLm5vZGVQcm9wcy5oZWlnaHQgLyAyXG4gIH07XG4gIHZhciBvbk1vdXNlRW50ZXIgPSAoKSA9PiB7XG4gICAgZGlzcGF0Y2goc2V0QWN0aXZlTW91c2VPdmVySXRlbUluZGV4KHtcbiAgICAgIGFjdGl2ZUluZGV4OiBwcm9wcy5ub2RlUHJvcHMudG9vbHRpcEluZGV4LFxuICAgICAgYWN0aXZlRGF0YUtleTogcHJvcHMuZGF0YUtleSxcbiAgICAgIGFjdGl2ZUNvb3JkaW5hdGVcbiAgICB9KSk7XG4gIH07XG4gIHZhciBvbk1vdXNlTGVhdmUgPSAoKSA9PiB7XG4gICAgLy8gY2xlYXJpbmcgc3RhdGUgb24gbW91c2VMZWF2ZUl0ZW0gY2F1c2VzIHJlLXJlbmRlcmluZyBpc3N1ZXNcbiAgICAvLyB3ZSBkb24ndCBhY3R1YWxseSB3YW50IHRvIGRvIHRoaXMgZm9yIFRyZWVNYXAgLSB3ZSBjbGVhciBzdGF0ZSB3aGVuIHdlIGxlYXZlIHRoZSBlbnRpcmUgY2hhcnQgaW5zdGVhZFxuICB9O1xuICB2YXIgb25DbGljayA9ICgpID0+IHtcbiAgICBkaXNwYXRjaChzZXRBY3RpdmVDbGlja0l0ZW1JbmRleCh7XG4gICAgICBhY3RpdmVJbmRleDogcHJvcHMubm9kZVByb3BzLnRvb2x0aXBJbmRleCxcbiAgICAgIGFjdGl2ZURhdGFLZXk6IHByb3BzLmRhdGFLZXksXG4gICAgICBhY3RpdmVDb29yZGluYXRlXG4gICAgfSkpO1xuICB9O1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGVudEl0ZW0sIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIG9uTW91c2VFbnRlcjogb25Nb3VzZUVudGVyLFxuICAgIG9uTW91c2VMZWF2ZTogb25Nb3VzZUxlYXZlLFxuICAgIG9uQ2xpY2s6IG9uQ2xpY2tcbiAgfSkpO1xufVxuZnVuY3Rpb24gZ2V0VG9vbHRpcEVudHJ5U2V0dGluZ3MoX3JlZjMpIHtcbiAgdmFyIHtcbiAgICBwcm9wcyxcbiAgICBjdXJyZW50Um9vdFxuICB9ID0gX3JlZjM7XG4gIHZhciB7XG4gICAgZGF0YUtleSxcbiAgICBuYW1lS2V5LFxuICAgIHN0cm9rZSxcbiAgICBmaWxsXG4gIH0gPSBwcm9wcztcbiAgcmV0dXJuIHtcbiAgICBkYXRhRGVmaW5lZE9uSXRlbTogY3VycmVudFJvb3QsXG4gICAgcG9zaXRpb25zOiB1bmRlZmluZWQsXG4gICAgLy8gVE9ETyBJIHRoaW5rIFRyZWVtYXAgaGFzIHRoZSBjYXBhYmlsaXR5IG9mIGNvbXB1dGluZyBwb3NpdGlvbnMgYW5kIHN1cHBvcnRpbmcgZGVmYXVsdEluZGV4PyBFeGNlcHQgaXQgZG9lc24ndCB5ZXRcbiAgICBzZXR0aW5nczoge1xuICAgICAgc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGg6IHVuZGVmaW5lZCxcbiAgICAgIGZpbGwsXG4gICAgICBkYXRhS2V5LFxuICAgICAgbmFtZUtleSxcbiAgICAgIG5hbWU6IHVuZGVmaW5lZCxcbiAgICAgIC8vIEVhY2ggVHJlZW1hcE5vZGUgaGFzIGl0cyBvd24gbmFtZVxuICAgICAgaGlkZTogZmFsc2UsXG4gICAgICB0eXBlOiB1bmRlZmluZWQsXG4gICAgICBjb2xvcjogZmlsbCxcbiAgICAgIHVuaXQ6ICcnXG4gICAgfVxuICB9O1xufVxuXG4vLyBXaHkgaXMgbWFyZ2luIG5vdCBhIHRyZWVtYXAgcHJvcD8gTm8gY2x1ZS4gUHJvYmFibHkgaXQgc2hvdWxkIGJlXG52YXIgZGVmYXVsdFRyZWVtYXBNYXJnaW4gPSB7XG4gIHRvcDogMCxcbiAgcmlnaHQ6IDAsXG4gIGJvdHRvbTogMCxcbiAgbGVmdDogMFxufTtcbmZ1bmN0aW9uIFRyZWVtYXBJdGVtKF9yZWY0KSB7XG4gIHZhciB7XG4gICAgY29udGVudCxcbiAgICBub2RlUHJvcHMsXG4gICAgaXNMZWFmLFxuICAgIHRyZWVtYXBQcm9wcyxcbiAgICBvbk5lc3RDbGlja1xuICB9ID0gX3JlZjQ7XG4gIHZhciB7XG4gICAgaXNBbmltYXRpb25BY3RpdmUsXG4gICAgYW5pbWF0aW9uQmVnaW4sXG4gICAgYW5pbWF0aW9uRHVyYXRpb24sXG4gICAgYW5pbWF0aW9uRWFzaW5nLFxuICAgIGlzVXBkYXRlQW5pbWF0aW9uQWN0aXZlLFxuICAgIHR5cGUsXG4gICAgY29sb3JQYW5lbCxcbiAgICBkYXRhS2V5LFxuICAgIG9uQW5pbWF0aW9uU3RhcnQsXG4gICAgb25BbmltYXRpb25FbmQsXG4gICAgb25Nb3VzZUVudGVyOiBvbk1vdXNlRW50ZXJGcm9tUHJvcHMsXG4gICAgb25DbGljazogb25JdGVtQ2xpY2tGcm9tUHJvcHMsXG4gICAgb25Nb3VzZUxlYXZlOiBvbk1vdXNlTGVhdmVGcm9tUHJvcHNcbiAgfSA9IHRyZWVtYXBQcm9wcztcbiAgdmFyIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH0gPSBub2RlUHJvcHM7XG4gIHZhciB0cmFuc2xhdGVYID0gLXggLSB3aWR0aDtcbiAgdmFyIHRyYW5zbGF0ZVkgPSAwO1xuICB2YXIgb25Nb3VzZUVudGVyID0gZSA9PiB7XG4gICAgaWYgKChpc0xlYWYgfHwgdHlwZSA9PT0gJ25lc3QnKSAmJiB0eXBlb2Ygb25Nb3VzZUVudGVyRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvbk1vdXNlRW50ZXJGcm9tUHJvcHMobm9kZVByb3BzLCBlKTtcbiAgICB9XG4gIH07XG4gIHZhciBvbk1vdXNlTGVhdmUgPSBlID0+IHtcbiAgICBpZiAoKGlzTGVhZiB8fCB0eXBlID09PSAnbmVzdCcpICYmIHR5cGVvZiBvbk1vdXNlTGVhdmVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9uTW91c2VMZWF2ZUZyb21Qcm9wcyhub2RlUHJvcHMsIGUpO1xuICAgIH1cbiAgfTtcbiAgdmFyIG9uQ2xpY2sgPSAoKSA9PiB7XG4gICAgaWYgKHR5cGUgPT09ICduZXN0Jykge1xuICAgICAgb25OZXN0Q2xpY2sobm9kZVByb3BzKTtcbiAgICB9XG4gICAgaWYgKChpc0xlYWYgfHwgdHlwZSA9PT0gJ25lc3QnKSAmJiB0eXBlb2Ygb25JdGVtQ2xpY2tGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9uSXRlbUNsaWNrRnJvbVByb3BzKG5vZGVQcm9wcyk7XG4gICAgfVxuICB9O1xuICB2YXIgaGFuZGxlQW5pbWF0aW9uRW5kID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygb25BbmltYXRpb25FbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9uQW5pbWF0aW9uRW5kKCk7XG4gICAgfVxuICB9LCBbb25BbmltYXRpb25FbmRdKTtcbiAgdmFyIGhhbmRsZUFuaW1hdGlvblN0YXJ0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygb25BbmltYXRpb25TdGFydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb25BbmltYXRpb25TdGFydCgpO1xuICAgIH1cbiAgfSwgW29uQW5pbWF0aW9uU3RhcnRdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENTU1RyYW5zaXRpb25BbmltYXRlLCB7XG4gICAgYW5pbWF0aW9uSWQ6IFwidHJlZW1hcC1cIi5jb25jYXQobm9kZVByb3BzLnRvb2x0aXBJbmRleCksXG4gICAgZnJvbTogXCJ0cmFuc2xhdGUoXCIuY29uY2F0KHRyYW5zbGF0ZVgsIFwicHgsIFwiKS5jb25jYXQodHJhbnNsYXRlWSwgXCJweClcIiksXG4gICAgdG86IFwidHJhbnNsYXRlKDAsIDApXCIsXG4gICAgYXR0cmlidXRlTmFtZTogXCJ0cmFuc2Zvcm1cIixcbiAgICBiZWdpbjogYW5pbWF0aW9uQmVnaW4sXG4gICAgZWFzaW5nOiBhbmltYXRpb25FYXNpbmcsXG4gICAgaXNBY3RpdmU6IGlzQW5pbWF0aW9uQWN0aXZlLFxuICAgIGR1cmF0aW9uOiBhbmltYXRpb25EdXJhdGlvbixcbiAgICBvbkFuaW1hdGlvblN0YXJ0OiBoYW5kbGVBbmltYXRpb25TdGFydCxcbiAgICBvbkFuaW1hdGlvbkVuZDogaGFuZGxlQW5pbWF0aW9uRW5kXG4gIH0sIHN0eWxlID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KExheWVyLCB7XG4gICAgb25Nb3VzZUVudGVyOiBvbk1vdXNlRW50ZXIsXG4gICAgb25Nb3VzZUxlYXZlOiBvbk1vdXNlTGVhdmUsXG4gICAgb25DbGljazogb25DbGljayxcbiAgICBzdHlsZTogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzdHlsZSksIHt9LCB7XG4gICAgICB0cmFuc2Zvcm1PcmlnaW46IFwiXCIuY29uY2F0KHgsIFwiIFwiKS5jb25jYXQoeSlcbiAgICB9KVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZW50SXRlbVdpdGhFdmVudHMsIHtcbiAgICBjb250ZW50OiBjb250ZW50LFxuICAgIGRhdGFLZXk6IGRhdGFLZXksXG4gICAgbm9kZVByb3BzOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG5vZGVQcm9wcyksIHt9LCB7XG4gICAgICBpc0FuaW1hdGlvbkFjdGl2ZSxcbiAgICAgIGlzVXBkYXRlQW5pbWF0aW9uQWN0aXZlOiAhaXNVcGRhdGVBbmltYXRpb25BY3RpdmUsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSksXG4gICAgdHlwZTogdHlwZSxcbiAgICBjb2xvclBhbmVsOiBjb2xvclBhbmVsXG4gIH0pKSk7XG59XG5jbGFzcyBUcmVlbWFwV2l0aFN0YXRlIGV4dGVuZHMgUHVyZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdGVcIiwgX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdFN0YXRlKSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlQ2xpY2tcIiwgbm9kZSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBvbkNsaWNrLFxuICAgICAgICB0eXBlXG4gICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGlmICh0eXBlID09PSAnbmVzdCcgJiYgbm9kZS5jaGlsZHJlbikge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICBkYXRhS2V5LFxuICAgICAgICAgIG5hbWVLZXksXG4gICAgICAgICAgYXNwZWN0UmF0aW9cbiAgICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciByb290ID0gY29tcHV0ZU5vZGUoe1xuICAgICAgICAgIGRlcHRoOiAwLFxuICAgICAgICAgIG5vZGU6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbm9kZSksIHt9LCB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0XG4gICAgICAgICAgfSksXG4gICAgICAgICAgaW5kZXg6IDAsXG4gICAgICAgICAgZGF0YUtleSxcbiAgICAgICAgICBuYW1lS2V5LFxuICAgICAgICAgIC8vIHdpdGggVHJlZW1hcCBuZXN0aW5nLCBzaG91bGQgdGhpcyBjb250aW51ZSBuZXN0aW5nIHRoZSBpbmRleCBvciBzdGFydCBmcm9tIGVtcHR5IHN0cmluZz9cbiAgICAgICAgICBuZXN0ZWRBY3RpdmVUb29sdGlwSW5kZXg6IG5vZGUudG9vbHRpcEluZGV4XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZm9ybWF0Um9vdCA9IHNxdWFyaWZ5KHJvb3QsIGFzcGVjdFJhdGlvKTtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBuZXN0SW5kZXhcbiAgICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIG5lc3RJbmRleC5wdXNoKG5vZGUpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBmb3JtYXRSb290LFxuICAgICAgICAgIGN1cnJlbnRSb290OiByb290LFxuICAgICAgICAgIG5lc3RJbmRleFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgIG9uQ2xpY2sobm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlVG91Y2hNb3ZlXCIsIGUgPT4ge1xuICAgICAgdmFyIHRvdWNoRXZlbnQgPSBlLnRvdWNoZXNbMF07XG4gICAgICB2YXIgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh0b3VjaEV2ZW50LmNsaWVudFgsIHRvdWNoRXZlbnQuY2xpZW50WSk7XG4gICAgICBpZiAoIXRhcmdldCB8fCAhdGFyZ2V0LmdldEF0dHJpYnV0ZSB8fCB0aGlzLnN0YXRlLmZvcm1hdFJvb3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaXRlbUluZGV4ID0gdGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1yZWNoYXJ0cy1pdGVtLWluZGV4Jyk7XG4gICAgICB2YXIgYWN0aXZlTm9kZSA9IHRyZWVtYXBQYXlsb2FkU2VhcmNoZXIodGhpcy5zdGF0ZS5mb3JtYXRSb290LCBpdGVtSW5kZXgpO1xuICAgICAgaWYgKCFhY3RpdmVOb2RlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB7XG4gICAgICAgIGRhdGFLZXksXG4gICAgICAgIGRpc3BhdGNoXG4gICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgIHZhciBhY3RpdmVDb29yZGluYXRlID0ge1xuICAgICAgICB4OiBhY3RpdmVOb2RlLnggKyBhY3RpdmVOb2RlLndpZHRoIC8gMixcbiAgICAgICAgeTogYWN0aXZlTm9kZS55ICsgYWN0aXZlTm9kZS5oZWlnaHQgLyAyXG4gICAgICB9O1xuXG4gICAgICAvLyBUcmVlbWFwIGRvZXMgbm90IHN1cHBvcnQgb25Ub3VjaE1vdmUgcHJvcCwgYnV0IGl0IGNvdWxkXG4gICAgICAvLyBvblRvdWNoTW92ZT8uKGFjdGl2ZU5vZGUsIE51bWJlcihpdGVtSW5kZXgpLCBlKTtcbiAgICAgIGRpc3BhdGNoKHNldEFjdGl2ZU1vdXNlT3Zlckl0ZW1JbmRleCh7XG4gICAgICAgIGFjdGl2ZUluZGV4OiBpdGVtSW5kZXgsXG4gICAgICAgIGFjdGl2ZURhdGFLZXk6IGRhdGFLZXksXG4gICAgICAgIGFjdGl2ZUNvb3JkaW5hdGVcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgaWYgKG5leHRQcm9wcy5kYXRhICE9PSBwcmV2U3RhdGUucHJldkRhdGEgfHwgbmV4dFByb3BzLnR5cGUgIT09IHByZXZTdGF0ZS5wcmV2VHlwZSB8fCBuZXh0UHJvcHMud2lkdGggIT09IHByZXZTdGF0ZS5wcmV2V2lkdGggfHwgbmV4dFByb3BzLmhlaWdodCAhPT0gcHJldlN0YXRlLnByZXZIZWlnaHQgfHwgbmV4dFByb3BzLmRhdGFLZXkgIT09IHByZXZTdGF0ZS5wcmV2RGF0YUtleSB8fCBuZXh0UHJvcHMuYXNwZWN0UmF0aW8gIT09IHByZXZTdGF0ZS5wcmV2QXNwZWN0UmF0aW8pIHtcbiAgICAgIHZhciByb290ID0gY29tcHV0ZU5vZGUoe1xuICAgICAgICBkZXB0aDogMCxcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBtaXNzaW5nIHByb3BlcnRpZXNcbiAgICAgICAgbm9kZToge1xuICAgICAgICAgIGNoaWxkcmVuOiBuZXh0UHJvcHMuZGF0YSxcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgd2lkdGg6IG5leHRQcm9wcy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IG5leHRQcm9wcy5oZWlnaHRcbiAgICAgICAgfSxcbiAgICAgICAgaW5kZXg6IDAsXG4gICAgICAgIGRhdGFLZXk6IG5leHRQcm9wcy5kYXRhS2V5LFxuICAgICAgICBuYW1lS2V5OiBuZXh0UHJvcHMubmFtZUtleVxuICAgICAgfSk7XG4gICAgICB2YXIgZm9ybWF0Um9vdCA9IHNxdWFyaWZ5KHJvb3QsIG5leHRQcm9wcy5hc3BlY3RSYXRpbyk7XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcmV2U3RhdGUpLCB7fSwge1xuICAgICAgICBmb3JtYXRSb290LFxuICAgICAgICBjdXJyZW50Um9vdDogcm9vdCxcbiAgICAgICAgbmVzdEluZGV4OiBbcm9vdF0sXG4gICAgICAgIHByZXZBc3BlY3RSYXRpbzogbmV4dFByb3BzLmFzcGVjdFJhdGlvLFxuICAgICAgICBwcmV2RGF0YTogbmV4dFByb3BzLmRhdGEsXG4gICAgICAgIHByZXZXaWR0aDogbmV4dFByb3BzLndpZHRoLFxuICAgICAgICBwcmV2SGVpZ2h0OiBuZXh0UHJvcHMuaGVpZ2h0LFxuICAgICAgICBwcmV2RGF0YUtleTogbmV4dFByb3BzLmRhdGFLZXksXG4gICAgICAgIHByZXZUeXBlOiBuZXh0UHJvcHMudHlwZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGhhbmRsZU5lc3RJbmRleChub2RlLCBpKSB7XG4gICAgdmFyIHtcbiAgICAgIG5lc3RJbmRleFxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIHZhciB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGRhdGFLZXksXG4gICAgICBuYW1lS2V5LFxuICAgICAgYXNwZWN0UmF0aW9cbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICB2YXIgcm9vdCA9IGNvbXB1dGVOb2RlKHtcbiAgICAgIGRlcHRoOiAwLFxuICAgICAgbm9kZTogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBub2RlKSwge30sIHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSksXG4gICAgICBpbmRleDogMCxcbiAgICAgIGRhdGFLZXksXG4gICAgICBuYW1lS2V5LFxuICAgICAgLy8gd2l0aCBUcmVlbWFwIG5lc3RpbmcsIHNob3VsZCB0aGlzIGNvbnRpbnVlIG5lc3RpbmcgdGhlIGluZGV4IG9yIHN0YXJ0IGZyb20gZW1wdHkgc3RyaW5nP1xuICAgICAgbmVzdGVkQWN0aXZlVG9vbHRpcEluZGV4OiBub2RlLnRvb2x0aXBJbmRleFxuICAgIH0pO1xuICAgIHZhciBmb3JtYXRSb290ID0gc3F1YXJpZnkocm9vdCwgYXNwZWN0UmF0aW8pO1xuICAgIG5lc3RJbmRleCA9IG5lc3RJbmRleC5zbGljZSgwLCBpICsgMSk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBmb3JtYXRSb290LFxuICAgICAgY3VycmVudFJvb3Q6IG5vZGUsXG4gICAgICBuZXN0SW5kZXhcbiAgICB9KTtcbiAgfVxuICByZW5kZXJOb2RlKHJvb3QsIG5vZGUpIHtcbiAgICB2YXIge1xuICAgICAgY29udGVudCxcbiAgICAgIHR5cGVcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICB2YXIgbm9kZVByb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHN2Z1Byb3BlcnRpZXNOb0V2ZW50cyh0aGlzLnByb3BzKSksIG5vZGUpLCB7fSwge1xuICAgICAgcm9vdFxuICAgIH0pO1xuICAgIHZhciBpc0xlYWYgPSAhbm9kZS5jaGlsZHJlbiB8fCAhbm9kZS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnRSb290XG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgdmFyIGlzQ3VycmVudFJvb3RDaGlsZCA9ICgoY3VycmVudFJvb3QgPT09IG51bGwgfHwgY3VycmVudFJvb3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRSb290LmNoaWxkcmVuKSB8fCBbXSkuZmlsdGVyKGl0ZW0gPT4gaXRlbS5kZXB0aCA9PT0gbm9kZS5kZXB0aCAmJiBpdGVtLm5hbWUgPT09IG5vZGUubmFtZSk7XG4gICAgaWYgKCFpc0N1cnJlbnRSb290Q2hpbGQubGVuZ3RoICYmIHJvb3QuZGVwdGggJiYgdHlwZSA9PT0gJ25lc3QnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KExheWVyLCB7XG4gICAgICBrZXk6IFwicmVjaGFydHMtdHJlZW1hcC1ub2RlLVwiLmNvbmNhdChub2RlUHJvcHMueCwgXCItXCIpLmNvbmNhdChub2RlUHJvcHMueSwgXCItXCIpLmNvbmNhdChub2RlUHJvcHMubmFtZSksXG4gICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtdHJlZW1hcC1kZXB0aC1cIi5jb25jYXQobm9kZS5kZXB0aClcbiAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChUcmVlbWFwSXRlbSwge1xuICAgICAgaXNMZWFmOiBpc0xlYWYsXG4gICAgICBjb250ZW50OiBjb250ZW50LFxuICAgICAgbm9kZVByb3BzOiBub2RlUHJvcHMsXG4gICAgICB0cmVlbWFwUHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICBvbk5lc3RDbGljazogdGhpcy5oYW5kbGVDbGlja1xuICAgIH0pLCBub2RlLmNoaWxkcmVuICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID8gbm9kZS5jaGlsZHJlbi5tYXAoY2hpbGQgPT4gdGhpcy5yZW5kZXJOb2RlKG5vZGUsIGNoaWxkKSkgOiBudWxsKTtcbiAgfVxuICByZW5kZXJBbGxOb2RlcygpIHtcbiAgICB2YXIge1xuICAgICAgZm9ybWF0Um9vdFxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICghZm9ybWF0Um9vdCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlbmRlck5vZGUoZm9ybWF0Um9vdCwgZm9ybWF0Um9vdCk7XG4gIH1cblxuICAvLyByZW5kZXIgbmVzdCB0cmVlbWFwXG4gIHJlbmRlck5lc3RJbmRleCgpIHtcbiAgICB2YXIge1xuICAgICAgbmFtZUtleSxcbiAgICAgIG5lc3RJbmRleENvbnRlbnRcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICB2YXIge1xuICAgICAgbmVzdEluZGV4XG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy10cmVlbWFwLW5lc3QtaW5kZXgtd3JhcHBlclwiLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgbWFyZ2luVG9wOiAnOHB4JyxcbiAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJ1xuICAgICAgfVxuICAgIH0sIG5lc3RJbmRleC5tYXAoKGl0ZW0sIGkpID0+IHtcbiAgICAgIC8vIFRPRE8gbmVlZCB0byB2ZXJpZnkgbmFtZUtleSB0eXBlXG4gICAgICB2YXIgbmFtZSA9IGdldChpdGVtLCBuYW1lS2V5LCAncm9vdCcpO1xuICAgICAgdmFyIGNvbnRlbnQ7XG4gICAgICBpZiAoLyojX19QVVJFX18qL1JlYWN0LmlzVmFsaWRFbGVtZW50KG5lc3RJbmRleENvbnRlbnQpKSB7XG4gICAgICAgIC8vIHRoZSBjbG9uZWQgY29udGVudCBpcyBpZ25vcmVkIGF0IGFsbCB0aW1lcyAtIGxldCdzIHJlbW92ZSBpdD9cbiAgICAgICAgY29udGVudCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQobmVzdEluZGV4Q29udGVudCwgaXRlbSwgaSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG5lc3RJbmRleENvbnRlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29udGVudCA9IG5lc3RJbmRleENvbnRlbnQoaXRlbSwgaSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZW50ID0gbmFtZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoXG4gICAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzeC1hMTF5L2NsaWNrLWV2ZW50cy1oYXZlLWtleS1ldmVudHMsIGpzeC1hMTF5L25vLXN0YXRpYy1lbGVtZW50LWludGVyYWN0aW9uc1xuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgICBvbkNsaWNrOiB0aGlzLmhhbmRsZU5lc3RJbmRleC5iaW5kKHRoaXMsIGl0ZW0sIGkpLFxuICAgICAgICAgIGtleTogXCJuZXN0LWluZGV4LVwiLmNvbmNhdCh1bmlxdWVJZCgpKSxcbiAgICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtdHJlZW1hcC1uZXN0LWluZGV4LWJveFwiLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBjdXJzb3I6ICdwb2ludGVyJyxcbiAgICAgICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICAgICAgcGFkZGluZzogJzAgN3B4JyxcbiAgICAgICAgICAgIGJhY2tncm91bmQ6ICcjMDAwJyxcbiAgICAgICAgICAgIGNvbG9yOiAnI2ZmZicsXG4gICAgICAgICAgICBtYXJnaW5SaWdodDogJzNweCdcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGNvbnRlbnQpXG4gICAgICApO1xuICAgIH0pKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgIHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICBzdHlsZSxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHR5cGVcbiAgICAgIH0gPSBfdGhpcyRwcm9wcyxcbiAgICAgIG90aGVycyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfdGhpcyRwcm9wcywgX2V4Y2x1ZGVkKTtcbiAgICB2YXIgYXR0cnMgPSBzdmdQcm9wZXJ0aWVzTm9FdmVudHMob3RoZXJzKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFNldFRvb2x0aXBFbnRyeVNldHRpbmdzLCB7XG4gICAgICBmbjogZ2V0VG9vbHRpcEVudHJ5U2V0dGluZ3MsXG4gICAgICBhcmdzOiB7XG4gICAgICAgIHByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICBjdXJyZW50Um9vdDogdGhpcy5zdGF0ZS5jdXJyZW50Um9vdFxuICAgICAgfVxuICAgIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChTdXJmYWNlLCBfZXh0ZW5kcyh7fSwgYXR0cnMsIHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogdHlwZSA9PT0gJ25lc3QnID8gaGVpZ2h0IC0gMzAgOiBoZWlnaHQsXG4gICAgICBvblRvdWNoTW92ZTogdGhpcy5oYW5kbGVUb3VjaE1vdmVcbiAgICB9KSwgdGhpcy5yZW5kZXJBbGxOb2RlcygpLCBjaGlsZHJlbiksIHR5cGUgPT09ICduZXN0JyAmJiB0aGlzLnJlbmRlck5lc3RJbmRleCgpKTtcbiAgfVxufVxuX2RlZmluZVByb3BlcnR5KFRyZWVtYXBXaXRoU3RhdGUsIFwiZGlzcGxheU5hbWVcIiwgJ1RyZWVtYXAnKTtcbmZ1bmN0aW9uIFRyZWVtYXBEaXNwYXRjaEluamVjdChwcm9wcykge1xuICB2YXIgZGlzcGF0Y2ggPSB1c2VBcHBEaXNwYXRjaCgpO1xuICB2YXIgd2lkdGggPSB1c2VDaGFydFdpZHRoKCk7XG4gIHZhciBoZWlnaHQgPSB1c2VDaGFydEhlaWdodCgpO1xuICBpZiAoIWlzUG9zaXRpdmVOdW1iZXIod2lkdGgpIHx8ICFpc1Bvc2l0aXZlTnVtYmVyKGhlaWdodCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVHJlZW1hcFdpdGhTdGF0ZSwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIGRpc3BhdGNoOiBkaXNwYXRjaFxuICB9KSk7XG59XG5leHBvcnQgZnVuY3Rpb24gVHJlZW1hcChvdXRzaWRlUHJvcHMpIHtcbiAgdmFyIF9wcm9wcyRjbGFzc05hbWU7XG4gIHZhciBwcm9wcyA9IHJlc29sdmVEZWZhdWx0UHJvcHMob3V0c2lkZVByb3BzLCBkZWZhdWx0VHJlZU1hcFByb3BzKTtcbiAgdmFyIHtcbiAgICBjbGFzc05hbWUsXG4gICAgc3R5bGUsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH0gPSBwcm9wcztcbiAgdmFyIFt0b29sdGlwUG9ydGFsLCBzZXRUb29sdGlwUG9ydGFsXSA9IHVzZVN0YXRlKG51bGwpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVjaGFydHNTdG9yZVByb3ZpZGVyLCB7XG4gICAgcHJlbG9hZGVkU3RhdGU6IHtcbiAgICAgIG9wdGlvbnNcbiAgICB9LFxuICAgIHJlZHV4U3RvcmVOYW1lOiAoX3Byb3BzJGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSkgIT09IG51bGwgJiYgX3Byb3BzJGNsYXNzTmFtZSAhPT0gdm9pZCAwID8gX3Byb3BzJGNsYXNzTmFtZSA6ICdUcmVlbWFwJ1xuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZXBvcnRDaGFydE1hcmdpbiwge1xuICAgIG1hcmdpbjogZGVmYXVsdFRyZWVtYXBNYXJnaW5cbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlY2hhcnRzV3JhcHBlciwge1xuICAgIGRpc3BhdGNoVG91Y2hFdmVudHM6IGZhbHNlLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgIHN0eWxlOiBzdHlsZSxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAvKlxuICAgICAqIFRyZWVtYXAgaGFzIGEgYnVnIHdoZXJlIGl0IGRvZXNuJ3QgaW5jbHVkZSBzdHJva2VXaWR0aCBpbiBpdHMgZGltZW5zaW9uIGNhbGN1bGF0aW9uXG4gICAgICogd2hpY2ggbWFrZXMgdGhlIGFjdHVhbCBjaGFydCBleGFjdGx5IHtzdHJva2VXaWR0aH0gbGFyZ2VyIHRoYW4gYXNrZWQgZm9yLlxuICAgICAqIEl0J3Mgbm90IGEgaHVnZSBkZWFsIHVzdWFsbHksIGJ1dCBpdCBtYWtlcyB0aGUgcmVzcG9uc2l2ZSBvcHRpb24gY3ljbGUgaW5maW5pdGVseS5cbiAgICAgKi8sXG4gICAgcmVzcG9uc2l2ZTogZmFsc2UsXG4gICAgcmVmOiBub2RlID0+IHtcbiAgICAgIGlmICh0b29sdGlwUG9ydGFsID09IG51bGwgJiYgbm9kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFRvb2x0aXBQb3J0YWwobm9kZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBvbk1vdXNlRW50ZXI6IHVuZGVmaW5lZCxcbiAgICBvbk1vdXNlTGVhdmU6IHVuZGVmaW5lZCxcbiAgICBvbkNsaWNrOiB1bmRlZmluZWQsXG4gICAgb25Nb3VzZU1vdmU6IHVuZGVmaW5lZCxcbiAgICBvbk1vdXNlRG93bjogdW5kZWZpbmVkLFxuICAgIG9uTW91c2VVcDogdW5kZWZpbmVkLFxuICAgIG9uQ29udGV4dE1lbnU6IHVuZGVmaW5lZCxcbiAgICBvbkRvdWJsZUNsaWNrOiB1bmRlZmluZWQsXG4gICAgb25Ub3VjaFN0YXJ0OiB1bmRlZmluZWQsXG4gICAgb25Ub3VjaE1vdmU6IHVuZGVmaW5lZCxcbiAgICBvblRvdWNoRW5kOiB1bmRlZmluZWRcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVG9vbHRpcFBvcnRhbENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogdG9vbHRpcFBvcnRhbFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChUcmVlbWFwRGlzcGF0Y2hJbmplY3QsIHByb3BzKSkpKTtcbn0iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgYXJyYXlUb29sdGlwU2VhcmNoZXIgfSBmcm9tICcuLi9zdGF0ZS9vcHRpb25zU2xpY2UnO1xuaW1wb3J0IHsgQ2FydGVzaWFuQ2hhcnQgfSBmcm9tICcuL0NhcnRlc2lhbkNoYXJ0JztcbnZhciBhbGxvd2VkVG9vbHRpcFR5cGVzID0gWydpdGVtJ107XG5leHBvcnQgdmFyIFNjYXR0ZXJDaGFydCA9IC8qI19fUFVSRV9fKi9mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDYXJ0ZXNpYW5DaGFydCwge1xuICAgIGNoYXJ0TmFtZTogXCJTY2F0dGVyQ2hhcnRcIixcbiAgICBkZWZhdWx0VG9vbHRpcEV2ZW50VHlwZTogXCJpdGVtXCIsXG4gICAgdmFsaWRhdGVUb29sdGlwRXZlbnRUeXBlczogYWxsb3dlZFRvb2x0aXBUeXBlcyxcbiAgICB0b29sdGlwUGF5bG9hZFNlYXJjaGVyOiBhcnJheVRvb2x0aXBTZWFyY2hlcixcbiAgICBjYXRlZ29yaWNhbENoYXJ0UHJvcHM6IHByb3BzLFxuICAgIHJlZjogcmVmXG4gIH0pO1xufSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9