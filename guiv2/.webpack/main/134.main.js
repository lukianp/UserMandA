"use strict";exports.id=134,exports.ids=[134],exports.modules={134:(t,a,e)=>{e.d(a,{databaseService:()=>h});var i=e(928),s=e.n(i),n=e(943),d=e.n(n),r=e(580),o=e(912);const l={waves:[],version:"1.0.0",lastModified:(new Date).toISOString(),metadata:{}};const h=new class{db=null;dbPath="";backupDir="";async initialize(t){try{await d().mkdir(t,{recursive:!0}),this.dbPath=s().join(t,"migration-plan.json"),this.backupDir=s().join(t,"backups"),await d().mkdir(this.backupDir,{recursive:!0});const a=new o.Pv(this.dbPath);this.db=new r.t(a,l),await this.db.read(),this.db.data&&this.db.data.waves||(this.db.data={...l},await this.db.write()),console.log(`[DatabaseService] Initialized at: ${this.dbPath}`)}catch(t){throw console.error("[DatabaseService] Initialization failed:",t),new Error(`Failed to initialize database: ${t}`)}}ensureInitialized(){if(!this.db)throw new Error("Database not initialized. Call initialize() first.")}async createBackup(){try{const t=(new Date).toISOString().replace(/[:.]/g,"-"),a=s().join(this.backupDir,`migration-plan-backup-${t}.json`);await d().copyFile(this.dbPath,a);const e=await d().readdir(this.backupDir);if(e.length>10){const t=e.sort().slice(0,-10);for(const a of t)await d().unlink(s().join(this.backupDir,a))}}catch(t){console.error("[DatabaseService] Backup failed:",t)}}async getWaves(){return this.ensureInitialized(),await this.db.read(),this.db.data.waves||[]}async getWave(t){return this.ensureInitialized(),await this.db.read(),this.db.data.waves.find(a=>a.id===t)||null}async addWave(t){this.ensureInitialized(),await this.db.read(),await this.createBackup(),this.db.data.waves.push({...t,createdAt:t.createdAt||(new Date).toISOString()}),this.db.data.lastModified=(new Date).toISOString(),await this.db.write(),console.log(`[DatabaseService] Added wave: ${t.id}`)}async updateWave(t,a){this.ensureInitialized(),await this.db.read();const e=this.db.data.waves.findIndex(a=>a.id===t);if(-1===e)throw new Error(`Wave not found: ${t}`);this.db.data.waves[e]={...this.db.data.waves[e],...a,id:t},this.db.data.lastModified=(new Date).toISOString(),await this.db.write(),console.log(`[DatabaseService] Updated wave: ${t}`)}async deleteWave(t){this.ensureInitialized(),await this.db.read(),await this.createBackup();const a=this.db.data.waves.length;if(this.db.data.waves=this.db.data.waves.filter(a=>a.id!==t),this.db.data.waves.length===a)throw new Error(`Wave not found: ${t}`);this.db.data.lastModified=(new Date).toISOString(),await this.db.write(),console.log(`[DatabaseService] Deleted wave: ${t}`)}async addItemToWave(t,a){this.ensureInitialized(),await this.db.read();const e=this.db.data.waves.find(a=>a.id===t);if(!e)throw new Error(`Wave not found: ${t}`);let i=e.batches.find(t=>t.type===a.type);i||(i={id:`batch-${a.type}-${Date.now()}`,name:`${a.type} Batch`,description:`Batch for ${a.type} migrations`,type:a.type,priority:a.priority||"Normal",complexity:a.complexity||"Moderate",items:[],status:"NotStarted",statusMessage:"",startTime:null,endTime:null,plannedStartDate:null,plannedEndDate:null,estimatedDuration:null,actualDuration:null,assignedTechnician:"",businessOwner:"",maxConcurrentItems:5,enableAutoRetry:!0,maxRetryAttempts:3,retryDelay:5e3,totalItems:0,completedItems:0,failedItems:0,itemsWithWarnings:0,inProgressItems:0,pendingItems:0,progressPercentage:0,successRate:0,totalSizeBytes:0,transferredBytes:0,averageTransferRateMBps:0,formattedTotalSize:"0 MB",prerequisites:[],postMigrationTasks:[],dependentBatches:[],configuration:{},environmentSettings:{},enableThrottling:!1,throttlingLimitMBps:100,preMigrationChecklist:[],postMigrationValidation:[],qualityGates:[],requiresApproval:!1,approvedBy:"",approvalDate:null,errors:[],warnings:[],logFilePath:"",detailedLogs:[],businessJustification:"",estimatedCost:null,actualCost:null,tags:[],customProperties:{},supportsRollback:!0,rollbackPlan:"",rollbackInstructions:[],isCompleted:!1,hasErrors:!1,hasWarnings:!1,isHighRisk:!1,canStart:!0,canPause:!1,canResume:!1,isRunning:!1,createdAt:(new Date).toISOString()},e.batches.push(i)),i.items.push(a),i.totalItems=i.items.length,i.pendingItems=i.items.filter(t=>"NotStarted"===t.status||"Planning"===t.status).length,e.totalItems=e.batches.reduce((t,a)=>t+a.totalItems,0),this.db.data.lastModified=(new Date).toISOString(),await this.db.write(),console.log(`[DatabaseService] Added item to wave ${t}, batch ${i.id}`)}async removeItemFromWave(t,a){this.ensureInitialized(),await this.db.read();const e=this.db.data.waves.find(a=>a.id===t);if(!e)throw new Error(`Wave not found: ${t}`);let i=!1;for(const t of e.batches){const e=t.items.length;t.items=t.items.filter(t=>t.id!==a),t.items.length<e&&(i=!0,t.totalItems=t.items.length,t.pendingItems=t.items.filter(t=>"NotStarted"===t.status||"Planning"===t.status).length)}if(!i)throw new Error(`Item not found: ${a}`);e.totalItems=e.batches.reduce((t,a)=>t+a.totalItems,0),this.db.data.lastModified=(new Date).toISOString(),await this.db.write(),console.log(`[DatabaseService] Removed item ${a} from wave ${t}`)}async getWaveItems(t){this.ensureInitialized(),await this.db.read();const a=this.db.data.waves.find(a=>a.id===t);if(!a)throw new Error(`Wave not found: ${t}`);return a.batches.flatMap(t=>t.items)}async saveMigrationPlan(t){this.ensureInitialized(),await this.createBackup(),this.db.data.waves=t,this.db.data.lastModified=(new Date).toISOString(),await this.db.write(),console.log(`[DatabaseService] Saved complete migration plan with ${t.length} waves`)}async updateMetadata(t){this.ensureInitialized(),await this.db.read(),this.db.data.metadata={...this.db.data.metadata,...t},this.db.data.lastModified=(new Date).toISOString(),await this.db.write()}async getMetadata(){return this.ensureInitialized(),await this.db.read(),this.db.data.metadata}async clearAll(){this.ensureInitialized(),await this.createBackup(),this.db.data={...l},await this.db.write(),console.log("[DatabaseService] Cleared all migration data")}async getStatistics(){this.ensureInitialized(),await this.db.read();return{totalWaves:this.db.data.waves.length,totalBatches:this.db.data.waves.reduce((t,a)=>t+a.batches.length,0),totalItems:this.db.data.waves.reduce((t,a)=>t+(a.totalItems||0),0),lastModified:this.db.data.lastModified}}}}};