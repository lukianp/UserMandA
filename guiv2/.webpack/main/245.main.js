"use strict";exports.id=245,exports.ids=[245],exports.modules={245:(s,t,e)=>{e.d(t,{registerMigrationPlanningHandlers:()=>l});var a=e(482),n=e(896),r=e(928);class i{plansDir;plans=new Map;constructor(s="C:\\DiscoveryData"){this.plansDir=r.join(s,"MigrationPlans"),this.ensureDirectoryExists()}ensureDirectoryExists(){n.existsSync(this.plansDir)||n.mkdirSync(this.plansDir,{recursive:!0})}async createPlan(s){const t={id:crypto.randomUUID(),...s,waves:[],created:(new Date).toISOString(),modified:(new Date).toISOString()};return this.plans.set(t.id,t),await this.savePlan(t),t}async addWave(s,t){const e=this.plans.get(s);if(!e)throw new Error(`Migration plan not found: ${s}`);const a={id:crypto.randomUUID(),...t,status:"planned",users:[],priority:t.priority||1,dependencies:t.dependencies||[],created:(new Date).toISOString(),modified:(new Date).toISOString()};return e.waves.push(a),e.modified=(new Date).toISOString(),await this.savePlan(e),a}async assignUsersToWave(s,t,e){const a=this.plans.get(s);if(!a)throw new Error(`Migration plan not found: ${s}`);const n=a.waves.find(s=>s.id===t);if(!n)throw new Error(`Wave not found: ${t}`);const r=new Set(n.users);e.forEach(s=>r.add(s)),n.users=Array.from(r),n.modified=(new Date).toISOString(),a.modified=(new Date).toISOString(),await this.savePlan(a)}async updateWaveStatus(s,t,e){const a=this.plans.get(s);if(!a)throw new Error(`Migration plan not found: ${s}`);const n=a.waves.find(s=>s.id===t);if(!n)throw new Error(`Wave not found: ${t}`);n.status=e,n.modified=(new Date).toISOString(),a.modified=(new Date).toISOString(),await this.savePlan(a)}async getPlan(s){if(this.plans.has(s)){return this.plans.get(s)||null}const t=r.join(this.plansDir,`${s}.json`);if(n.existsSync(t)){const s=await n.promises.readFile(t,"utf8"),e=JSON.parse(s);return this.plans.set(e.id,e),e}return null}async getPlansByProfile(s){return await this.loadAllPlans(),Array.from(this.plans.values()).filter(t=>t.profileName===s)}async deletePlan(s){this.plans.delete(s);const t=r.join(this.plansDir,`${s}.json`);n.existsSync(t)&&await n.promises.unlink(t)}async savePlan(s){const t=r.join(this.plansDir,`${s.id}.json`);await n.promises.writeFile(t,JSON.stringify(s,null,2),"utf8")}async loadAllPlans(){if(!n.existsSync(this.plansDir))return;const s=(await n.promises.readdir(this.plansDir)).filter(s=>s.endsWith(".json"));for(const t of s)try{const s=await n.promises.readFile(r.join(this.plansDir,t),"utf8"),e=JSON.parse(s);this.plans.set(e.id,e)}catch(s){console.error(`Failed to load migration plan ${t}:`,s)}}getStatistics(){const s=Array.from(this.plans.values()).flatMap(s=>s.waves);return{totalPlans:this.plans.size,totalWaves:s.length,wavesByStatus:{planned:s.filter(s=>"planned"===s.status).length,inprogress:s.filter(s=>"inprogress"===s.status).length,completed:s.filter(s=>"completed"===s.status).length,failed:s.filter(s=>"failed"===s.status).length},totalUsersAssigned:Array.from(new Set(s.flatMap(s=>s.users))).length}}}let o=null;function l(){const s=(o||(o=new i(t)),o);var t;a.ipcMain.handle("migration-plan:get-by-profile",async(t,e)=>{try{return{success:!0,plans:await s.getPlansByProfile(e)}}catch(s){return{success:!1,error:s.message}}}),a.ipcMain.handle("migration-plan:create",async(t,e)=>{try{return{success:!0,plan:await s.createPlan(e)}}catch(s){return{success:!1,error:s.message}}}),a.ipcMain.handle("migration-plan:add-wave",async(t,e)=>{try{return{success:!0,wave:await s.addWave(e.planId,e.waveData)}}catch(s){return{success:!1,error:s.message}}}),a.ipcMain.handle("migration-plan:assign-users",async(t,e)=>{try{return await s.assignUsersToWave(e.planId,e.waveId,e.userIds),{success:!0}}catch(s){return{success:!1,error:s.message}}}),a.ipcMain.handle("migration-plan:update-wave-status",async(t,e)=>{try{return await s.updateWaveStatus(e.planId,e.waveId,e.status),{success:!0}}catch(s){return{success:!1,error:s.message}}}),a.ipcMain.handle("migration-plan:delete",async(t,e)=>{try{return await s.deletePlan(e),{success:!0}}catch(s){return{success:!1,error:s.message}}}),a.ipcMain.handle("migration-plan:get-by-id",async(t,e)=>{try{return{success:!0,plan:await s.getPlanById(e)}}catch(s){return{success:!1,error:s.message}}})}}};