#!/usr/bin/env node

/**
 * Discovery View Generator
 *
 * Automatically generates standardized discovered view components from manifest.
 *
 * Usage:
 *   node scripts/generate-discovery-views.js
 *   node scripts/generate-discovery-views.js --dry-run
 *   node scripts/generate-discovery-views.js --module=aws
 */

const fs = require('fs');
const path = require('path');

// ============================================================================
// Configuration
// ============================================================================

const MANIFEST_PATH = path.join(__dirname, 'discovery-modules.json');
const OUTPUT_DIR = path.join(__dirname, '..', 'src', 'renderer', 'views', 'discovered');
const DRY_RUN = process.argv.includes('--dry-run');
const SINGLE_MODULE = process.argv.find(arg => arg.startsWith('--module='))?.split('=')[1];

// ============================================================================
// Template Functions
// ============================================================================

/**
 * Generate view component TypeScript code
 */
function generateViewComponent(module) {
  const componentName = `${pascalCase(module.id)}DiscoveredView`;

  return `/**
 * ${module.name} Discovered View
 *
 * Auto-generated discovered data view for ${module.name}.
 * Displays CSV data from: ${module.csvPath}
 *
 * @generated by scripts/generate-discovery-views.js
 * @module ${module.id}
 * @category ${module.category}
 */

import React, { useState, useCallback } from 'react';
import { DiscoveredViewTemplate } from '../../components/organisms/DiscoveredViewTemplate';
import { useCsvDataLoader } from '../../hooks/useCsvDataLoader';

/**
 * ${module.name} discovered data view component
 */
export const ${componentName}: React.FC = () => {
  const [searchText, setSearchText] = useState('');

  const {
    data,
    columns,
    loading,
    error,
    lastRefresh,
    loadCsvData,
  } = useCsvDataLoader('${module.csvPath}');

  const handleRefresh = useCallback(() => {
    loadCsvData();
  }, [loadCsvData]);

  const handleExport = useCallback(() => {
    // Export functionality handled by VirtualizedDataGrid
    console.log('[${componentName}] Export requested');
  }, []);

  return (
    <DiscoveredViewTemplate
      title="${module.name}"
      description="${module.description}"
      data={data}
      columns={columns}
      loading={loading}
      error={error}
      searchText={searchText}
      onSearchChange={setSearchText}
      onRefresh={handleRefresh}
      onExport={handleExport}
      lastRefresh={lastRefresh}
      enableSearch={true}
      enableExport={true}
      data-cy="${module.id}-discovered-view"
    />
  );
};

export default ${componentName};
`;
}

/**
 * Generate route configuration TypeScript code
 */
function generateRouteConfig(modules) {
  const imports = modules.map(m => {
    const componentName = `${pascalCase(m.id)}DiscoveredView`;
    return `const ${componentName} = lazy(() => import('./${componentName}'));`;
  }).join('\n');

  const routes = modules.map(m => {
    const componentName = `${pascalCase(m.id)}DiscoveredView`;
    return `  {
    path: '/discovered/${m.id}',
    element: <${componentName} />
  },`;
  }).join('\n');

  return `// Auto-generated discovered view routes
// Generated by: scripts/generate-discovery-views.js
// Do not edit manually - regenerate using: npm run generate:views

import { lazy } from 'react';

${imports}

export const discoveredRoutes = [
${routes}
];
`;
}

/**
 * Generate sidebar navigation configuration
 */
function generateSidebarConfig(modules, categories) {
  const groupedModules = {};

  modules.forEach(m => {
    if (!groupedModules[m.category]) {
      groupedModules[m.category] = [];
    }
    groupedModules[m.category].push(m);
  });

  const categoryOrder = Object.keys(categories).sort((a, b) =>
    categories[a].order - categories[b].order
  );

  let output = `// Auto-generated sidebar navigation items for discovered views
// Generated by: scripts/generate-discovery-views.js

import {
  Database, Package, Cloud, Layers, HardDrive, Shield, Key, Lock,
  Tag, Network, AppWindow, Radar, Mail, Users, Server, FileText,
  Cpu, GitBranch, Folder, Folders, BarChart3, Workflow, Printer, Calendar,
  MessageSquare, Globe, Smartphone
} from 'lucide-react';

export const discoveredNavItems = [\n`;

  categoryOrder.forEach((categoryKey, catIndex) => {
    const category = categories[categoryKey];
    const categoryModules = (groupedModules[categoryKey] || []).sort((a, b) =>
      a.name.localeCompare(b.name)
    );

    if (categoryModules.length === 0) return;

    output += `  // ${category.label}\n`;

    categoryModules.forEach((module, modIndex) => {
      const comma = (catIndex === categoryOrder.length - 1 && modIndex === categoryModules.length - 1) ? '' : ',';
      output += `  { path: '/discovered/${module.id}', label: '${module.name}', icon: <${module.icon} size={16} /> }${comma}\n`;
    });

    if (catIndex < categoryOrder.length - 1) {
      output += '\n';
    }
  });

  output += '];\n';

  return output;
}

// ============================================================================
// Utility Functions
// ============================================================================

function pascalCase(str) {
  return str.replace(/(^\w|-\w|_\w)/g, (match) =>
    match.replace(/[-_]/, '').toUpperCase()
  );
}

function ensureDirectoryExists(dir) {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
    console.log(`‚úì Created directory: ${dir}`);
  }
}

function writeFile(filePath, content) {
  if (DRY_RUN) {
    console.log(`[DRY RUN] Would write: ${filePath}`);
    return;
  }

  fs.writeFileSync(filePath, content, 'utf8');
  console.log(`‚úì Generated: ${filePath}`);
}

// ============================================================================
// Main Generation Logic
// ============================================================================

function main() {
  console.log('='.repeat(70));
  console.log('Discovery View Generator');
  console.log('='.repeat(70));

  if (DRY_RUN) {
    console.log('‚ö†Ô∏è  DRY RUN MODE - No files will be written\n');
  }

  // Load manifest
  console.log(`\nüìñ Loading manifest: ${MANIFEST_PATH}`);
  const manifest = JSON.parse(fs.readFileSync(MANIFEST_PATH, 'utf8'));

  // Filter modules
  let modules = manifest.modules.filter(m => m.enabled);

  if (SINGLE_MODULE) {
    modules = modules.filter(m => m.id === SINGLE_MODULE);
    if (modules.length === 0) {
      console.error(`‚ùå Module not found: ${SINGLE_MODULE}`);
      process.exit(1);
    }
    console.log(`\nüéØ Generating single module: ${SINGLE_MODULE}`);
  }

  console.log(`\nüìä Found ${modules.length} enabled modules`);
  console.log(`üìÇ Output directory: ${OUTPUT_DIR}\n`);

  // Ensure output directory exists
  ensureDirectoryExists(OUTPUT_DIR);

  // Generate view components
  console.log('üî® Generating view components...\n');
  let successCount = 0;
  let errorCount = 0;

  modules.forEach(module => {
    try {
      const componentName = `${pascalCase(module.id)}DiscoveredView`;
      const fileName = `${componentName}.tsx`;
      const filePath = path.join(OUTPUT_DIR, fileName);

      const content = generateViewComponent(module);
      writeFile(filePath, content);

      successCount++;
    } catch (error) {
      console.error(`‚ùå Error generating ${module.id}:`, error.message);
      errorCount++;
    }
  });

  // Generate route configuration
  if (!SINGLE_MODULE) {
    console.log('\nüõ£Ô∏è  Generating route configuration...\n');
    const routesPath = path.join(OUTPUT_DIR, '_routes.generated.tsx');
    const routesContent = generateRouteConfig(modules);
    writeFile(routesPath, routesContent);

    // Generate sidebar configuration
    console.log('\nüì± Generating sidebar configuration...\n');
    const sidebarPath = path.join(OUTPUT_DIR, '_sidebar.generated.tsx');
    const sidebarContent = generateSidebarConfig(modules, manifest.categories);
    writeFile(sidebarPath, sidebarContent);
  }

  // Summary
  console.log('\n' + '='.repeat(70));
  console.log('Generation Complete!');
  console.log('='.repeat(70));
  console.log(`‚úì ${successCount} components generated`);
  if (errorCount > 0) {
    console.log(`‚ùå ${errorCount} errors`);
  }

  if (!DRY_RUN) {
    console.log(`\nüìÅ Output directory: ${OUTPUT_DIR}`);
    console.log('\nüìù Next steps:');
    console.log('   1. Import generated routes in routes.tsx');
    console.log('   2. Import generated sidebar items in Sidebar.tsx');
    console.log('   3. Build renderer: npm run webpack --config webpack.renderer.config.js');
    console.log('   4. Test application: npm start\n');
  }
}

// Run generator
try {
  main();
} catch (error) {
  console.error('\n‚ùå Fatal error:', error.message);
  console.error(error.stack);
  process.exit(1);
}
