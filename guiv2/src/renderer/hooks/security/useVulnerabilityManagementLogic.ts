import { useState, useEffect, useCallback } from 'react';
import { useProfileStore } from '../../store/useProfileStore';

export interface VulnerabilityData {
  id: string;
  cve: string;
  title: string;
  severity: 'Critical' | 'High' | 'Medium' | 'Low' | 'Informational';
  cvssScore: number;
  affectedSystems: string[];
  status: 'Open' | 'In Progress' | 'Resolved' | 'Accepted Risk';
  discoveredDate: string;
  lastScanned: string;
  remediation: string;
  description: string;
  affectedAssets: number;
  patchAvailable: boolean;
  exploitAvailable: boolean;
  category: string;
  owner: string;
  dueDate: string;
}

export interface VulnerabilityStats {
  total: number;
  critical: number;
  high: number;
  medium: number;
  low: number;
  resolved: number;
  overdue: number;
  patchesAvailable: number;
  activeExploits: number;
}

export const useVulnerabilityManagementLogic = () => {
  const [data, setData] = useState<VulnerabilityData[]>([]);
  const [stats, setStats] = useState<VulnerabilityStats>({
    total: 0,
    critical: 0,
    high: 0,
    medium: 0,
    low: 0,
    resolved: 0,
    overdue: 0,
    patchesAvailable: 0,
    activeExploits: 0,
  });
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [selectedVulnerabilities, setSelectedVulnerabilities] = useState<VulnerabilityData[]>([]);
  const { selectedSourceProfile } = useProfileStore();

  // Filters
  const [filters, setFilters] = useState({
    searchText: '',
    severity: '',
    status: '',
    category: '',
    patchAvailable: '',
    exploitAvailable: '',
  });

  const loadData = useCallback(async () => {
    if (!selectedSourceProfile) {
      setError('No profile selected');
      return;
    }

    setIsLoading(true);
    setError(null);

    try {
      // Use PowerShell module integration for vulnerability data
      const result = await window.electronAPI.executeModule({
        modulePath: 'Modules/Security/GetVulnerabilities.psm1',
        functionName: 'Get-VulnerabilityData',
        parameters: { profile: selectedSourceProfile.companyName },
        options: {}
      });

      if (result.success && result.data) {
        const vulnerabilities = result.data.vulnerabilities || [];
        setData(vulnerabilities);

        // Calculate stats
        const newStats: VulnerabilityStats = {
          total: vulnerabilities.length,
          critical: vulnerabilities.filter((v: VulnerabilityData) => v.severity === 'Critical').length,
          high: vulnerabilities.filter((v: VulnerabilityData) => v.severity === 'High').length,
          medium: vulnerabilities.filter((v: VulnerabilityData) => v.severity === 'Medium').length,
          low: vulnerabilities.filter((v: VulnerabilityData) => v.severity === 'Low').length,
          resolved: vulnerabilities.filter((v: VulnerabilityData) => v.status === 'Resolved').length,
          overdue: vulnerabilities.filter((v: VulnerabilityData) => {
            const dueDate = new Date(v.dueDate);
            return dueDate < new Date() && v.status !== 'Resolved';
          }).length,
          patchesAvailable: vulnerabilities.filter((v: VulnerabilityData) => v.patchAvailable).length,
          activeExploits: vulnerabilities.filter((v: VulnerabilityData) => v.exploitAvailable).length,
        };
        setStats(newStats);
      } else {
        setError(result.error || 'Failed to load vulnerability data');
      }
    } catch (err: any) {
      setError(err.message || 'An error occurred while loading vulnerability data');
    } finally {
      setIsLoading(false);
    }
  }, [selectedSourceProfile]);

  useEffect(() => {
    loadData();
  }, [loadData]);

  const updateFilter = useCallback((key: string, value: string) => {
    setFilters(prev => ({ ...prev, [key]: value }));
  }, []);

  const clearFilters = useCallback(() => {
    setFilters({
      searchText: '',
      severity: '',
      status: '',
      category: '',
      patchAvailable: '',
      exploitAvailable: '',
    });
  }, []);

  // Apply filters
  const filteredData = data.filter(vuln => {
    if (filters.searchText && !vuln.title.toLowerCase().includes(filters.searchText.toLowerCase()) &&
        !vuln.cve.toLowerCase().includes(filters.searchText.toLowerCase())) {
      return false;
    }
    if (filters.severity && vuln.severity !== filters.severity) return false;
    if (filters.status && vuln.status !== filters.status) return false;
    if (filters.category && vuln.category !== filters.category) return false;
    if (filters.patchAvailable === 'Yes' && !vuln.patchAvailable) return false;
    if (filters.patchAvailable === 'No' && vuln.patchAvailable) return false;
    if (filters.exploitAvailable === 'Yes' && !vuln.exploitAvailable) return false;
    if (filters.exploitAvailable === 'No' && vuln.exploitAvailable) return false;
    return true;
  });

  // Get unique filter options
  const filterOptions = {
    severities: Array.from(new Set(data.map(v => v.severity))),
    statuses: Array.from(new Set(data.map(v => v.status))),
    categories: Array.from(new Set(data.map(v => v.category))),
  };

  const exportData = useCallback((format: 'csv' | 'json') => {
    const exportData = selectedVulnerabilities.length > 0 ? selectedVulnerabilities : filteredData;

    if (format === 'csv') {
      const csv = [
        ['CVE', 'Title', 'Severity', 'CVSS Score', 'Status', 'Affected Systems', 'Discovered Date', 'Patch Available', 'Exploit Available'],
        ...exportData.map(v => [
          v.cve,
          v.title,
          v.severity,
          v.cvssScore.toString(),
          v.status,
          v.affectedSystems.join('; '),
          v.discoveredDate,
          v.patchAvailable ? 'Yes' : 'No',
          v.exploitAvailable ? 'Yes' : 'No',
        ])
      ].map(row => row.join(',')).join('\n');

      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `vulnerabilities-${new Date().toISOString().split('T')[0]}.csv`;
      a.click();
      URL.revokeObjectURL(url);
    } else {
      const json = JSON.stringify(exportData, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `vulnerabilities-${new Date().toISOString().split('T')[0]}.json`;
      a.click();
      URL.revokeObjectURL(url);
    }
  }, [selectedVulnerabilities, filteredData]);

  const columns = [
    { field: 'cve', header: 'CVE ID', sortable: true, width: '150px' },
    { field: 'title', header: 'Title', sortable: true, width: '300px' },
    { field: 'severity', header: 'Severity', sortable: true, width: '120px' },
    { field: 'cvssScore', header: 'CVSS Score', sortable: true, width: '100px' },
    { field: 'affectedAssets', header: 'Affected Assets', sortable: true, width: '130px' },
    { field: 'status', header: 'Status', sortable: true, width: '130px' },
    { field: 'patchAvailable', header: 'Patch Available', sortable: true, width: '130px' },
    { field: 'exploitAvailable', header: 'Active Exploit', sortable: true, width: '130px' },
    { field: 'discoveredDate', header: 'Discovered', sortable: true, width: '120px' },
    { field: 'dueDate', header: 'Due Date', sortable: true, width: '120px' },
  ];

  return {
    data: filteredData,
    columns,
    stats,
    isLoading,
    error,
    filters,
    filterOptions,
    updateFilter,
    clearFilters,
    selectedVulnerabilities,
    setSelectedVulnerabilities,
    loadData,
    exportData,
    selectedProfile: selectedSourceProfile,
  };
};
