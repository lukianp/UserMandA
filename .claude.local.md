# Enterprise Discovery System - Development Guide

## Discovery Module Architecture Pattern

### Overview
All discovery modules follow a consistent pattern for data collection, structuring, and frontend integration. This document contains battle-tested patterns and critical lessons learned from months of development.

---

## CRITICAL: PowerShell → TypeScript Property Casing (THE #1 BUG SOURCE)

### The Problem
PowerShell returns JSON with **PascalCase** properties (`Name`, `Path`, `SizeGB`), but TypeScript developers instinctively use **camelCase** (`name`, `path`, `sizeGB`). This mismatch causes ALL data to show as "N/A" or undefined in the UI.

### The Rule
**ALWAYS use PascalCase for PowerShell output properties throughout the entire stack.**

### Example - FileSystem Discovery (Fixed Nov 30, 2025)

**PowerShell Output (CORRECT):**
```json
{
  "shares": [
    {
      "Name": "DiscoveryData",
      "Path": "C:\\DiscoveryData",
      "Server": "localhost",
      "ShareType": 0,
      "SizeGB": 0.01,
      "FileCount": 246
    }
  ],
  "permissions": [
    {
      "ShareName": "DiscoveryData",
      "IdentityReference": "BUILTIN\\Administrators",
      "FileSystemRights": "FullControl",
      "AccessControlType": "Allow"
    }
  ],
  "largeFiles": [
    {
      "Name": "windows.iso",
      "Path": "D:\\Drobo\\Appz\\windows.iso",
      "SizeMB": 3142.88,
      "ShareName": "Drobo",
      "Extension": ".iso"
    }
  ]
}
```

**TypeScript Hook - Column Definitions (CORRECT):**
```typescript
const shareColumnDefs = useMemo<ColDef[]>(() => [
  { field: 'Name', headerName: 'Share Name', sortable: true, filter: true },
  { field: 'Path', headerName: 'Path', sortable: true, filter: true },
  { field: 'Server', headerName: 'Server', sortable: true, filter: true },
  { field: 'ShareType', headerName: 'Type', sortable: true, filter: true },
  { field: 'SizeGB', headerName: 'Size', sortable: true, filter: 'agNumberColumnFilter',
    valueFormatter: (params) => params.value !== undefined ? `${params.value.toFixed(2)} GB` : 'N/A'
  },
  { field: 'FileCount', headerName: 'Files', sortable: true, filter: 'agNumberColumnFilter' },
], []);

const permissionColumnDefs = useMemo<ColDef[]>(() => [
  { field: 'ShareName', headerName: 'Share', sortable: true, filter: true },
  { field: 'IdentityReference', headerName: 'Principal', sortable: true, filter: true },
  { field: 'FileSystemRights', headerName: 'Rights', sortable: true, filter: true },
  { field: 'AccessControlType', headerName: 'Access', sortable: true, filter: true },
], []);

const largeFileColumnDefs = useMemo<ColDef[]>(() => [
  { field: 'Name', headerName: 'File Name', sortable: true, filter: true },
  { field: 'Path', headerName: 'Path', sortable: true, filter: true },
  { field: 'SizeMB', headerName: 'Size', sortable: true, filter: 'agNumberColumnFilter',
    valueFormatter: (params) => params.value !== undefined ? `${params.value.toLocaleString()} MB` : 'N/A'
  },
  { field: 'ShareName', headerName: 'Share', sortable: true, filter: true },
  { field: 'Extension', headerName: 'Type', sortable: true, filter: true },
], []);
```

**React View - Accessing Properties (CORRECT):**
```typescript
// If using HTML tables (not AG Grid):
<td>{share.Name || 'N/A'}</td>
<td>{share.Path || 'N/A'}</td>
<td>{share.Server || 'N/A'}</td>
<td>{share.SizeGB !== undefined ? `${share.SizeGB.toFixed(2)} GB` : 'N/A'}</td>

// Permissions
<td>{permission.ShareName || 'N/A'}</td>
<td>{permission.IdentityReference || 'N/A'}</td>
<td>{permission.FileSystemRights || 'N/A'}</td>

// Large Files
<td>{file.Name || 'N/A'}</td>
<td>{file.SizeMB !== undefined ? file.SizeMB.toLocaleString() : 'N/A'}</td>
```

**WRONG (All data shows as "N/A"):**
```typescript
// ❌ BROKEN - lowercase will NEVER work with PowerShell JSON
{ field: 'name', ... }
{ field: 'path', ... }
{ field: 'sizeGB', ... }
{ field: 'sizeMB', ... }

<td>{share.name || 'N/A'}</td>  // Always "N/A"!
<td>{share.path || 'N/A'}</td>  // Always "N/A"!
```

### Debugging Property Casing Issues

**Step 1: Write Debug JSON File**
```powershell
# In PowerShell module
$debugPath = "C:\temp\filesystem-result-$(Get-Date -Format 'yyyyMMddHHmmss').json"
$discoveryResult | ConvertTo-Json -Depth 10 | Out-File -FilePath $debugPath -Encoding UTF8
Write-Information "[FileSystem] Debug output: $debugPath" -InformationAction Continue
```

**Step 2: Inspect Actual Property Names**
```powershell
# Check what PowerShell actually returns
Get-Content C:\temp\filesystem-result-*.json | ConvertFrom-Json |
  Select-Object -ExpandProperty data |
  Select-Object -ExpandProperty Data |
  Select-Object -ExpandProperty shares |
  Select-Object -First 1 |
  Get-Member -MemberType NoteProperty
```

**Step 3: Match TypeScript to PowerShell Exactly**
- Copy property names EXACTLY as they appear in JSON
- Never assume camelCase - always verify
- Use PascalCase for all PowerShell-sourced data

---

## AG Grid Integration Pattern

### Why AG Grid?
- **Performance**: Virtual scrolling handles 100,000+ rows at 60 FPS
- **Built-in Features**: Sorting, filtering, column resizing, pinning, export
- **No Duplicate Key Warnings**: AG Grid handles row IDs internally
- **Professional UI**: Enterprise-grade styling out of the box

### VirtualizedDataGrid Component Setup

**Component Configuration (Fixed Nov 30, 2025):**
```typescript
// VirtualizedDataGrid.tsx (lines 136-139)
gridOptions = {
  enableCharts: false,  // CRITICAL: Disable to avoid AG Grid error #200
  cellSelection: true,  // CRITICAL: Replaces deprecated enableRangeSelection
  // ... other options
}
```

**Common AG Grid Errors:**
- **Error #200**: `enableCharts: true` requires IntegratedChartsModule → **Fix**: Set to `false`
- **Error #239**: Mixed theming APIs → **Fix**: Use `cellSelection` instead of `enableRangeSelection`

### Using VirtualizedDataGrid in Views

```typescript
// FileSystemDiscoveryView.tsx
import { VirtualizedDataGrid } from '../../components/organisms/VirtualizedDataGrid';

// In render:
{activeTab === 'shares' && (
  <div className="h-full p-6">
    <VirtualizedDataGrid
      data={filteredShares}
      columns={shareColumnDefs}
      loading={isRunning}
      onSelectionChange={setSelectedShares}
      enableExport
      enableGrouping
      height="calc(100vh - 400px)"
      data-cy="shares-grid"
    />
  </div>
)}
```

**Key Props:**
- `data`: Array of row objects (MUST match column field names exactly)
- `columns`: ColDef array from hook (MUST use PascalCase field names)
- `height`: Explicit height required for virtual scrolling
- `enableExport`: Adds CSV/Excel export buttons
- `enableGrouping`: Enables sidebar with column/filter tools

---

## Standard Discovery Module Structure

### 1. Core Discovery Function (`Invoke-{Module}Discovery`)

**Key Pattern:**
```powershell
function Invoke-{Module}Discovery {
    param(
        [hashtable]$Configuration,
        [hashtable]$Context,
        [string]$SessionId
    )

    $discoveryScript = {
        param($Configuration, $Context, $SessionId, $Connections, $Result)

        $allDiscoveredData = [System.Collections.ArrayList]::new()

        # Each discovered item MUST have _DataType property
        foreach ($item in $discoveredItems) {
            $obj = [PSCustomObject]@{
                # CRITICAL: Use PascalCase for ALL properties
                Id = $item.Id
                Name = $item.Name
                Path = $item.Path
                _DataType = "ItemType"  # For grouping in exports
            }
            $null = $allDiscoveredData.Add($obj)
        }

        # Export grouped by type
        $dataGroups = $allDiscoveredData | Group-Object -Property _DataType
        foreach ($group in $dataGroups) {
            $fileName = switch ($group.Name) {
                'Share' { 'FileSystemShares.csv' }
                'Permission' { 'FileSystemPermissions.csv' }
                'LargeFile' { 'FileSystemLargeFiles.csv' }
                default { "{Module}_$($group.Name).csv" }
            }

            Export-DiscoveryResults -Data $group.Group `
                -FileName $fileName `
                -OutputPath $Context.Paths.RawDataOutput `
                -ModuleName "{Module}" `
                -SessionId $SessionId
        }

        # CRITICAL: Return the raw data array
        return $allDiscoveredData
    }

    return Start-DiscoveryModule -ModuleName "{Module}" `
        -Configuration $Configuration `
        -Context $Context `
        -SessionId $SessionId `
        -RequiredServices @('Graph') `
        -DiscoveryScript $discoveryScript
}
```

---

### 2. Wrapper Function (`Start-{Module}Discovery`)

**Reference Implementation: FileSystemDiscovery.psm1**

**Key Pattern:**
```powershell
function Start-{Module}Discovery {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$false)]
        [string]$CompanyName,
        [Parameter(Mandatory=$false)]
        [string[]]$Servers = @('localhost'),
        [Parameter(Mandatory=$false)]
        [string]$OutputPath,
        [Parameter(Mandatory=$false)]
        [hashtable]$AdditionalParams = @{}
    )

    # Initialize result structure with PascalCase properties
    $result = [PSCustomObject]@{
        Success = $false
        RecordCount = 0
        Errors = @()
        Warnings = @()
        Metadata = @{}
        Data = $null
        OutputPath = $OutputPath
        StartTime = Get-Date
        EndTime = $null
        Duration = $null
    }

    try {
        # Ensure output paths exist
        if (-not (Test-Path $OutputPath)) {
            New-Item -Path $OutputPath -ItemType Directory -Force | Out-Null
        }

        # Generate session ID
        $sessionId = [guid]::NewGuid().ToString()

        # Build configuration
        $config = @{
            CompanyName = $CompanyName
            Servers = $Servers
        }
        foreach ($key in $AdditionalParams.Keys) {
            $config[$key] = $AdditionalParams[$key]
        }

        $context = @{
            Paths = @{
                RawDataOutput = $OutputPath
                Logs = Join-Path (Split-Path $OutputPath -Parent) "Logs"
            }
            CompanyName = $CompanyName
        }

        # Call Invoke-{Module}Discovery
        $discoveryResult = Invoke-{Module}Discovery -Configuration $config -Context $context -SessionId $sessionId

        # CRITICAL: Transform flat array into structured format for frontend
        if ($discoveryResult -and $discoveryResult.Success) {
            $allData = $discoveryResult.Data

            # Group by _DataType and create structured output
            $structuredData = @{
                shares = @($allData | Where-Object { $_._DataType -eq 'Share' })
                permissions = @($allData | Where-Object { $_._DataType -eq 'Permission' })
                largeFiles = @($allData | Where-Object { $_._DataType -eq 'LargeFile' })
                # Compute statistics from grouped data
                statistics = @{
                    totalShares = ($allData | Where-Object { $_._DataType -eq 'Share' }).Count
                    totalPermissions = ($allData | Where-Object { $_._DataType -eq 'Permission' }).Count
                    totalLargeFiles = ($allData | Where-Object { $_._DataType -eq 'LargeFile' }).Count
                    totalSizeMB = ($allData | Where-Object { $_._DataType -eq 'Share' } | Measure-Object -Property SizeGB -Sum).Sum * 1024
                    largestFileMB = ($allData | Where-Object { $_._DataType -eq 'LargeFile' } | Measure-Object -Property SizeMB -Maximum).Maximum
                }
            }

            $result.Data = $structuredData
            $result.RecordCount = $allData.Count
            $result.Success = $true
        }

    } catch {
        $result.Success = $false
        $result.Errors += $_.Exception.Message
    }

    $result.EndTime = Get-Date
    $result.Duration = ($result.EndTime - $result.StartTime).TotalSeconds

    return $result
}
```

**Critical Points:**
- Use PascalCase for ALL properties in result object
- Transform flat `Data` array into structured hashtable with categorized arrays
- Compute statistics from the grouped data
- Match property names to TypeScript interface exactly

---

### 3. Frontend TypeScript Integration

#### Hook Pattern (`use{Module}DiscoveryLogic.ts`)

```typescript
// Extract PowerShell data with nested structure awareness
const psWrapper = result.data || result;
const psData = psWrapper?.Data || psWrapper?.data || psWrapper;

// CRITICAL: Extract structured data (PowerShell groups by _DataType)
const grouped = {
  shares: Array.isArray(psData?.shares) ? psData.shares : [],
  permissions: Array.isArray(psData?.permissions) ? psData.permissions : [],
  largeFiles: Array.isArray(psData?.largeFiles) ? psData.largeFiles : [],
};

// Extract statistics computed by PowerShell
const psStats = psData?.statistics || {};

// Create result object matching TypeScript interface
const fileSystemResult: FileSystemDiscoveryResult = {
  id: psData?.id || data.executionId || `filesystem-discovery-${Date.now()}`,
  startTime: psData?.startTime?.DateTime || new Date().toISOString(),
  endTime: psData?.endTime?.DateTime || new Date().toISOString(),
  status: 'completed',
  shares: grouped.shares,
  permissions: grouped.permissions,
  largeFiles: grouped.largeFiles,
  statistics: psStats,
};

// Set state arrays (for filtering/display)
setShares(fileSystemResult.shares || []);
setPermissions(fileSystemResult.permissions || []);
setLargeFiles(fileSystemResult.largeFiles || []);
```

#### AG Grid Column Definitions (CRITICAL)

```typescript
// ALWAYS use PascalCase field names to match PowerShell output
const shareColumnDefs = useMemo<ColDef[]>(() => [
  { field: 'Name', headerName: 'Share Name', sortable: true, filter: true, pinned: 'left', width: 200 },
  { field: 'Path', headerName: 'Path', sortable: true, filter: true, width: 300 },
  { field: 'Server', headerName: 'Server', sortable: true, filter: true, width: 150 },
  {
    field: 'SizeGB',  // NOT sizeGB, NOT sizegb
    headerName: 'Total Size',
    sortable: true,
    filter: 'agNumberColumnFilter',
    width: 130,
    valueFormatter: (params) => params.value !== undefined ? `${params.value.toFixed(2)} GB` : 'N/A',
  },
  { field: 'FileCount', headerName: 'Files', sortable: true, filter: 'agNumberColumnFilter', width: 100 },
], []);
```

---

## Debugging Discovery Modules - Essential Patterns

### Debug File Writing (MOST USEFUL TECHNIQUE)

**PowerShell Debug Output:**
```powershell
# In Start-{Module}Discovery function, after calling Invoke-{Module}Discovery
$debugPath = "C:\temp\{module}-result-$(Get-Date -Format 'yyyyMMddHHmmss').json"
$discoveryResult | ConvertTo-Json -Depth 10 | Out-File -FilePath $debugPath -Encoding UTF8
Write-Information "[{Module}] Debug output written to: $debugPath" -InformationAction Continue
```

**TypeScript Debug Output:**
```typescript
// In hook's onDiscoveryComplete handler
const debugPath = `C:\\temp\\{module}-result-${Date.now()}.json`;
try {
  await window.electronAPI.writeFile(debugPath, JSON.stringify(result, null, 2));
  console.log(`[{Module}Hook] Debug file written to: ${debugPath}`);
} catch (e) {
  console.warn('[{Module}Hook] Could not write debug file:', e);
}
```

**Why this is essential:**
1. See exact JSON structure and property names (PascalCase vs camelCase)
2. Identify missing properties or unexpected nesting
3. Verify data types and array structures
4. Debug without constantly restarting the app
5. Compare PowerShell output vs TypeScript expectations

### Console Logging Pattern

```typescript
// At start of result processing
console.log('[{Module}Hook] Raw result:', JSON.stringify(result).slice(0, 500));
console.log('[{Module}Hook] psData keys:', Object.keys(psData || {}));

// After grouping data
console.log('[{Module}Hook] Grouped data:', {
  shares: grouped.shares.length,
  permissions: grouped.permissions.length,
  largeFiles: grouped.largeFiles.length,
});

// After extracting statistics
console.log('[{Module}Hook] psStats:', JSON.stringify(psStats));

// In View component
console.log('[{Module}View] Rendering with data:', {
  shares: filteredShares?.length || 0,
  permissions: filteredPermissions?.length || 0,
});
```

---

## Common Issues and Fixes

### Issue 1: All Data Shows as "N/A" in UI

**Problem:** Tables/grids render but all cells show "N/A" or undefined.

**Root Cause:** Property casing mismatch - PowerShell uses PascalCase, TypeScript uses camelCase.

**Diagnosis:**
1. Write debug JSON file from PowerShell
2. Inspect actual property names in C:\temp\
3. Compare to TypeScript column definitions and JSX access

**Fix:**
```typescript
// BEFORE (BROKEN)
{ field: 'name', headerName: 'Name' }
<td>{share.name || 'N/A'}</td>

// AFTER (FIXED)
{ field: 'Name', headerName: 'Name' }
<td>{share.Name || 'N/A'}</td>
```

---

### Issue 2: RecordCount Shows 0 Despite Data

**Problem:** Summary shows "Found 0 objects" but data was discovered.

**Root Cause:** `Start-DiscoveryModule` wasn't setting `$result.RecordCount`.

**Fix:** (DiscoveryBase.psm1:95)
```powershell
$discoveryData = & $DiscoveryScript @discoveryParams
$result.Data = $discoveryData
$result.RecordCount = if ($discoveryData) { $discoveryData.Count } else { 0 }
```

---

### Issue 3: Frontend Shows "0 items"

**Problem:** UI displays "0 shares, 0 permissions" when PowerShell found data.

**Root Cause:** PowerShell returns flat array, frontend expects structured object.

**Fix:** Transform in wrapper function
```powershell
$allData = $discoveryResult.Data
$structuredData = @{
    shares = @($allData | Where-Object { $_._DataType -eq 'Share' })
    permissions = @($allData | Where-Object { $_._DataType -eq 'Permission' })
    largeFiles = @($allData | Where-Object { $_._DataType -eq 'LargeFile' })
}
$result.Data = $structuredData
```

---

### Issue 4: AG Grid Shows Empty Despite Data

**Symptoms:**
- Console logs show correct data counts
- AG Grid renders but shows "No Rows To Show"
- No errors in console

**Root Cause:** Column field names don't match data property names.

**Diagnosis:**
```typescript
// Add to VirtualizedDataGrid component
const rowData = useMemo(() => {
  const result = data ?? [];
  console.log('[VirtualizedDataGrid] rowData:', result.length, 'rows');
  console.log('[VirtualizedDataGrid] First row:', JSON.stringify(result[0]));
  console.log('[VirtualizedDataGrid] Columns:', columns.map(c => c.field));
  return result;
}, [data]);
```

**Fix:** Match column field names to data properties EXACTLY (case-sensitive)

---

## File Locations Reference

### TypeScript Frontend (CANONICAL PATHS)
- **Types:** `guiv2/src/renderer/types/models/{module}.ts`
- **Hooks:** `guiv2/src/renderer/hooks/use{Module}DiscoveryLogic.ts`
- **Views:** `guiv2/src/renderer/views/discovery/{Module}DiscoveryView.tsx`
- **Components:** `guiv2/src/renderer/components/organisms/VirtualizedDataGrid.tsx`
- **Main process:** `guiv2/src/main/`
- **Services:** `guiv2/src/main/services/powerShellService.ts`
- **IPC Handlers:** `guiv2/src/main/ipcHandlers.ts`

### PowerShell Modules
- **Base Module:** `C:\enterprisediscovery\Modules\Discovery\DiscoveryBase.psm1`
- **Discovery Modules:** `C:\enterprisediscovery\Modules\Discovery\{Module}Discovery.psm1`

### Workspace Mirror
- **Source of Truth:** `D:\Scripts\UserMandA\` (for git commits)
- **Development:** `C:\enterprisediscovery\` (for active work)

---

## CRITICAL: Always Work in Deployment Directory

**⚠️ ALL CODE CHANGES MUST BE MADE IN `C:\enterprisediscovery\guiv2\src`**

**Development Workflow:**
1. Make ALL changes in `C:\enterprisediscovery\guiv2\src`
2. Build and test in deployment directory
3. When ready to commit, copy TO workspace:

```powershell
# CORRECT: Copy from deployment to workspace
robocopy C:\enterprisediscovery\guiv2\src D:\Scripts\UserMandA\guiv2\src /MIR /XD node_modules .webpack
```

**NEVER copy from workspace to deployment - you will lose uncommitted changes!**

---

## Build & Run Commands

**⚠️ CRITICAL: ALWAYS BUILD ALL THREE COMPONENTS**

The app has THREE separate webpack builds. You MUST run ALL THREE or changes won't take effect.

### Recommended: Use buildguiv2.ps1 Script

The `buildguiv2.ps1` PowerShell script handles the entire build process correctly:

```powershell
# From the project root (D:\Scripts\UserMandA)
.\buildguiv2.ps1              # Build only
.\buildguiv2.ps1 -Run         # Build and run the app
.\buildguiv2.ps1 -Dev         # Development mode (faster, no minification)
.\buildguiv2.ps1 -Run -Dev    # Build dev and run
```

This script:
1. Copies source from `D:\Scripts\UserMandA` to `C:\enterprisediscovery`
2. Installs npm dependencies if needed
3. Builds all THREE webpack bundles in the correct order
4. Optionally launches the app

### Manual Build Commands (if needed)

```powershell
cd C:\enterprisediscovery\guiv2

# 1. Build MAIN process (Electron main) - outputs to .webpack/main
npx webpack --config webpack.main.config.js --mode=production --output-path=.webpack/main

# 2. Build RENDERER process (React frontend) - CRITICAL FOR UI!
# NOTE: Use webpack.renderer.config.js (NOT webpack.renderer-standalone.config.js)
npx webpack --config webpack.renderer.config.js --mode=production

# 3. Build PRELOAD script (context bridge)
npx webpack --config webpack.preload.config.js --mode=production

# 4. Start the app
npm start
```

**Quick full build (copy/paste):**
```powershell
cd C:\enterprisediscovery\guiv2; npx webpack --config webpack.main.config.js --mode=production --output-path=.webpack/main; npx webpack --config webpack.renderer.config.js --mode=production; npx webpack --config webpack.preload.config.js --mode=production; npm start
```

### What Each Webpack Config Contains

| Config File | Output Location | Contains |
|-------------|-----------------|----------|
| `webpack.main.config.js` | `.webpack/main` | IPC handlers, PowerShell service, Electron main process |
| `webpack.renderer.config.js` | `.webpack/renderer` | React components, hooks, views, Tailwind CSS, all UI |
| `webpack.preload.config.js` | `.webpack/preload` | Context bridge, electronAPI exposure |

### CRITICAL: webpack.renderer.config.js vs webpack.renderer-standalone.config.js

**ALWAYS use `webpack.renderer.config.js`** for building the renderer. This config includes:
- All HtmlWebpackPlugin configurations
- CopyWebpackPlugin for static assets
- Full Tailwind CSS processing
- Bundle analysis and optimizations
- Proper dark mode theming support

**DO NOT use `webpack.renderer-standalone.config.js`** - it's missing critical plugins and will result in:
- Missing styles/broken UI
- "Cannot read properties of undefined (reading 'plugins')" errors
- White-on-white text in dark mode
- Missing component styling

### Common Mistakes

1. **Only running `npm run build`** - This only builds the main process. UI changes require renderer rebuild!
2. **Using wrong renderer config** - `webpack.renderer-standalone.config.js` is incomplete
3. **Forgetting preload** - New IPC methods won't work without preload rebuild
4. **Not clearing cache** - If builds seem stale, delete `.webpack` folder and rebuild

---

## Checklist for New/Updated Discovery Modules

### PowerShell Module
- [ ] All properties use PascalCase (Name, Path, SizeGB, etc.)
- [ ] Core function uses `Start-DiscoveryModule` pattern
- [ ] All discovered objects have `_DataType` property
- [ ] Wrapper function transforms flat array to structured hashtable
- [ ] Structured data keys match TypeScript interface
- [ ] Statistics computed by PowerShell (not TypeScript)
- [ ] Debug JSON file written to C:\temp\

### Frontend TypeScript
- [ ] All column definitions use PascalCase field names
- [ ] Interface properties match PowerShell output exactly
- [ ] Hook extracts structured data from `psData.Data`
- [ ] AG Grid columns match data property names exactly
- [ ] Debug logging added to hook and view
- [ ] Debug JSON file written to C:\temp\

### Testing
- [ ] Discovery finds expected data
- [ ] CSV files export correctly
- [ ] Summary shows correct record count
- [ ] All AG Grid tabs display data (not "N/A")
- [ ] Sorting and filtering work
- [ ] Export buttons work (CSV/Excel)
- [ ] No React duplicate key warnings

---

## Notes

- **Property Casing:** ALWAYS use PascalCase for PowerShell-sourced data
- **Debug Files:** Write to C:\temp\ during development - inspect FIRST when debugging
- **AG Grid:** Disable enableCharts, use cellSelection instead of enableRangeSelection
- **Workspace Sync:** Copy FROM deployment TO workspace when ready to commit
- **Build All Three:** Main, Renderer, Preload - EVERY TIME

---

---

## PowerShell Date Serialization Pattern (CRITICAL FOR EXCHANGE/AZURE)

### The Problem

PowerShell serializes .NET DateTime objects to JSON as complex objects, not ISO strings:

```json
{
  "value": "/Date(1764628412765)/",
  "DisplayHint": 2,
  "DateTime": "01 December 2025 22:33:35"
}
```

When TypeScript tries to display these with `new Date(dateObj)`, it shows "Invalid Date".

### The Solution - Unified Date Parser

**Create a reusable date parser function in every hook that handles dates:**

```typescript
/**
 * Parse PowerShell serialized date objects
 * Handles three formats:
 * 1. PowerShell DateTime property: { DateTime: "01 December 2025 22:33:35" }
 * 2. Microsoft JSON date: { value: "/Date(1764628412765)/" }
 * 3. ISO string: "2025-12-01T22:33:35.000Z"
 */
const parsePowerShellDate = (dateObj: any): Date | undefined => {
  if (!dateObj) {
    console.log('[parsePowerShellDate] Received null/undefined');
    return undefined;
  }

  // FIRST: Try DateTime property (most reliable for PowerShell dates)
  if (dateObj.DateTime) {
    console.log('[parsePowerShellDate] Using DateTime property:', dateObj.DateTime);
    return new Date(dateObj.DateTime);
  }

  // SECOND: Try Microsoft JSON date format /Date(timestamp)/
  if (dateObj.value && typeof dateObj.value === 'string' && dateObj.value.startsWith('/Date(')) {
    const timestamp = dateObj.value.match(/\/Date\((\d+)\)\//)?.[1];
    console.log('[parsePowerShellDate] Using /Date() timestamp:', timestamp);
    return timestamp ? new Date(parseInt(timestamp)) : undefined;
  }

  // THIRD: Try ISO string
  if (typeof dateObj === 'string') {
    console.log('[parsePowerShellDate] Using ISO string:', dateObj);
    try {
      return new Date(dateObj);
    } catch {
      return undefined;
    }
  }

  // FALLBACK: Try direct date object conversion
  console.log('[parsePowerShellDate] Using direct date object conversion');
  try {
    return new Date(dateObj);
  } catch {
    return undefined;
  }
};
```

### Using in AG Grid Column Definitions

**Apply the parser in EVERY date column's valueFormatter:**

```typescript
const mailboxColumns = useMemo<ColDef<ExchangeMailbox>[]>(() => [
  {
    field: 'LastLogonTime', // ALWAYS PascalCase!
    headerName: 'Last Logon',
    sortable: true,
    filter: 'agDateColumnFilter',
    valueFormatter: (params) => {
      if (!params.value) return 'Never';

      // Handle PowerShell date object
      const date = parsePowerShellDate(params.value);
      return date ? date.toLocaleDateString() : 'Invalid';
    },
    width: 120,
  },
  {
    field: 'WhenCreated',
    headerName: 'Created',
    sortable: true,
    filter: 'agDateColumnFilter',
    valueFormatter: (params) => {
      if (!params.value) return 'N/A';
      const date = parsePowerShellDate(params.value);
      return date ? date.toLocaleDateString() : 'Invalid';
    },
    width: 120,
  },
], []);
```

### Console Logging for Date Debugging

**Add extensive logging to the parser function during development:**

```typescript
const parsePowerShellDate = (dateObj: any): Date | undefined => {
  console.log('[parsePowerShellDate] Input:', JSON.stringify(dateObj));

  if (dateObj.DateTime) {
    const parsed = new Date(dateObj.DateTime);
    console.log('[parsePowerShellDate] Parsed from DateTime:', parsed);
    return parsed;
  }

  // ... rest of function with logging
};
```

**In the hook's data processing:**

```typescript
console.log('[ExchangeDiscoveryHook] First mailbox sample:', mailboxes[0]);
console.log('[ExchangeDiscoveryHook] LastLogonTime value:', mailboxes[0]?.LastLogonTime);
console.log('[ExchangeDiscoveryHook] WhenCreated value:', distributionGroups[0]?.WhenCreated);
```

### PowerShell-Side Best Practices

**Don't try to "help" by converting dates to strings in PowerShell:**

```powershell
# WRONG - Don't do this!
$obj = [PSCustomObject]@{
    Name = $mailbox.DisplayName
    LastLogonTime = $mailbox.LastLogonTime.ToString()  # ❌ Loses timezone info
}

# CORRECT - Let PowerShell serialize naturally
$obj = [PSCustomObject]@{
    Name = $mailbox.DisplayName
    LastLogonTime = $mailbox.LastLogonTime  # ✅ Preserves full DateTime object
}
```

PowerShell's `ConvertTo-Json` automatically creates the `{DateTime, value}` structure - TypeScript just needs to know how to parse it.

---

## Exchange Discovery - Complete PascalCase Fix (Dec 1, 2025)

### The Issue

Exchange Discovery found 3 mailboxes and 6 distribution groups, but AG Grid showed "N/A" in ALL columns across ALL tabs (Mailboxes, Distribution Groups, Transport Rules).

### Root Cause

AG Grid column definitions used camelCase field names, but PowerShell returned PascalCase properties:

```typescript
// BROKEN - Column definitions
{ field: 'displayName', ... }         // ❌ displayName doesn't exist
{ field: 'userPrincipalName', ... }   // ❌ userPrincipalName doesn't exist

// PowerShell actually returns:
{
  "DisplayName": "John Doe",          // ✅ DisplayName
  "UserPrincipalName": "john@domain.com"  // ✅ UserPrincipalName
}
```

### The Fix - All Column Definitions Updated

**Mailbox Columns (10 fields):**
```typescript
const mailboxColumns = useMemo<ColDef<ExchangeMailbox>[]>(() => [
  { field: 'DisplayName', headerName: 'Display Name', sortable: true, filter: true, pinned: 'left', width: 200 },
  { field: 'UserPrincipalName', headerName: 'UPN', sortable: true, filter: true, width: 250 },
  { field: 'PrimarySmtpAddress', headerName: 'Email', sortable: true, filter: true, width: 250 },
  { field: 'MailboxType', headerName: 'Type', sortable: true, filter: true, width: 120 },
  {
    field: 'TotalItemSize',  // NOT totalItemSize!
    headerName: 'Size (MB)',
    sortable: true,
    filter: 'agNumberColumnFilter',
    valueFormatter: (params) => {
      const value = params.value;
      if (value === null || value === undefined || isNaN(value)) return 'N/A';
      return (Number(value) / 1024 / 1024).toFixed(2);
    },
    width: 120,
  },
  { field: 'ItemCount', headerName: 'Items', sortable: true, filter: 'agNumberColumnFilter', width: 100 },
  { field: 'ArchiveEnabled', headerName: 'Archive', sortable: true, filter: true, width: 100,
    valueFormatter: (params) => (params.value ? 'Yes' : 'No'),
  },
  { field: 'LitigationHoldEnabled', headerName: 'Litigation Hold', sortable: true, filter: true, width: 130,
    valueFormatter: (params) => (params.value ? 'Yes' : 'No'),
  },
  { field: 'IsInactive', headerName: 'Inactive', sortable: true, filter: true, width: 100,
    valueFormatter: (params) => (params.value ? 'Yes' : 'No'),
  },
  {
    field: 'LastLogonTime',  // NOT lastLogonTime!
    headerName: 'Last Logon',
    sortable: true,
    filter: 'agDateColumnFilter',
    valueFormatter: (params) => {
      if (!params.value) return 'Never';
      const date = parsePowerShellDate(params.value);
      return date ? date.toLocaleDateString() : 'Invalid';
    },
    width: 120,
  },
], []);
```

**Distribution Group Columns (7 fields):**
```typescript
const groupColumns = useMemo<ColDef<ExchangeDistributionGroup>[]>(() => [
  { field: 'DisplayName', headerName: 'Name', sortable: true, filter: true, pinned: 'left', width: 200 },
  { field: 'PrimarySmtpAddress', headerName: 'Email', sortable: true, filter: true, width: 250 },
  { field: 'GroupType', headerName: 'Type', sortable: true, filter: true, width: 120 },
  { field: 'MemberCount', headerName: 'Members', sortable: true, filter: 'agNumberColumnFilter', width: 100 },
  { field: 'ModerationEnabled', headerName: 'Moderation', sortable: true, filter: true, width: 120,
    valueFormatter: (params) => (params.value ? 'Yes' : 'No'),
  },
  { field: 'HiddenFromAddressListsEnabled', headerName: 'Hidden', sortable: true, filter: true, width: 100,
    valueFormatter: (params) => (params.value ? 'Yes' : 'No'),
  },
  {
    field: 'WhenCreated',  // NOT whenCreated!
    headerName: 'Created',
    sortable: true,
    filter: 'agDateColumnFilter',
    valueFormatter: (params) => {
      if (!params.value) return 'N/A';
      const date = parsePowerShellDate(params.value);
      return date ? date.toLocaleDateString() : 'Invalid';
    },
    width: 120,
  },
], []);
```

**Transport Rule Columns (7 fields):**
```typescript
const ruleColumns = useMemo<ColDef<ExchangeTransportRule>[]>(() => [
  { field: 'Name', headerName: 'Rule Name', sortable: true, filter: true, pinned: 'left', width: 200 },
  { field: 'Description', headerName: 'Description', sortable: true, filter: true, width: 300 },
  { field: 'Priority', headerName: 'Priority', sortable: true, filter: 'agNumberColumnFilter', width: 100 },
  { field: 'State', headerName: 'State', sortable: true, filter: true, width: 100 },
  { field: 'CreatedBy', headerName: 'Created By', sortable: true, filter: true, width: 200 },
  {
    field: 'CreatedDate',  // NOT createdDate!
    headerName: 'Created',
    sortable: true,
    filter: 'agDateColumnFilter',
    valueFormatter: (params) => {
      if (!params.value) return 'N/A';
      const date = parsePowerShellDate(params.value);
      return date ? date.toLocaleDateString() : 'Invalid';
    },
    width: 120,
  },
  {
    field: 'ModifiedDate',  // NOT modifiedDate!
    headerName: 'Modified',
    sortable: true,
    filter: 'agDateColumnFilter',
    valueFormatter: (params) => {
      if (!params.value) return 'N/A';
      const date = parsePowerShellDate(params.value);
      return date ? date.toLocaleDateString() : 'Invalid';
    },
    width: 120,
  },
], []);
```

### Debug Logging Added

**To verify field name matching:**

```typescript
// After extracting data from PowerShell result
console.log('[ExchangeDiscoveryHook] ========== DEBUG DATA VERIFICATION ==========');
console.log('[ExchangeDiscoveryHook] PowerShell return keys:', Object.keys(psReturnValue || {}));

if (mailboxes.length > 0) {
  console.log('[ExchangeDiscoveryHook] First mailbox sample:', mailboxes[0]);
  console.log('[ExchangeDiscoveryHook] First mailbox keys:', Object.keys(mailboxes[0]));
}

if (distributionGroups.length > 0) {
  console.log('[ExchangeDiscoveryHook] First group sample:', distributionGroups[0]);
  console.log('[ExchangeDiscoveryHook] First group keys:', Object.keys(distributionGroups[0]));
}

console.log('[ExchangeDiscoveryHook] Mailbox column fields:', mailboxColumns.map(c => c.field));
console.log('[ExchangeDiscoveryHook] Group column fields:', groupColumns.map(c => c.field));
console.log('[ExchangeDiscoveryHook] ========================================');
```

This logging allows you to visually compare:
- PowerShell property names (e.g., `["DisplayName", "UserPrincipalName", "TotalItemSize"]`)
- AG Grid column field names (e.g., `["DisplayName", "UserPrincipalName", "TotalItemSize"]`)

If they don't match EXACTLY (case-sensitive), AG Grid shows "N/A".

### Files Modified

**Hook:** `C:\enterprisediscovery\guiv2\src\renderer\hooks\useExchangeDiscoveryLogic.ts`
- Fixed all column field names to PascalCase
- Added `parsePowerShellDate` function with logging
- Added comprehensive debug logging section

**VirtualizedDataGrid:** `C:\enterprisediscovery\guiv2\src\renderer\components\organisms\VirtualizedDataGrid.tsx`
- Changed `theme: undefined` → `theme: 'legacy' as any` (line 142)
- Fixes AG Grid error #239 (theming API conflict)

**PowerShell Module:** `C:\enterprisediscovery\Modules\Discovery\ExchangeDiscovery.psm1`
- Fixed 11 null comparison warnings (`$null` on left side)

### Testing Checklist

After these fixes, Exchange Discovery should:
- ✅ Display actual mailbox names (not "N/A")
- ✅ Show all 6 distribution groups with proper data
- ✅ Display formatted dates (not "Invalid Date")
- ✅ Show sizes in MB (converted from bytes)
- ✅ Display boolean fields as "Yes"/"No"
- ✅ Enable sorting and filtering on all columns
- ✅ No console errors or AG Grid warnings

---

## AG Grid Theme Configuration (CRITICAL)

### AG Grid v32/v33 Breaking Change

**Error #239:** "AG Grid: error #239 Theming API and CSS File Themes are both used in the same page."

**Cause:** AG Grid v33+ introduced a new Theming API. Setting `theme: undefined` doesn't properly suppress it, causing conflicts with CSS-based themes.

**Fix in VirtualizedDataGrid.tsx (line 142):**
```typescript
gridOptions = useMemo(() => ({
  // ... other options

  // FIX: Use legacy theme to prevent theming API conflict (error #239)
  // Must be set to 'legacy' to use v32 style themes with CSS files
  theme: 'legacy' as any,

  // ... other options
}), [virtualRowHeight, enableSelection, selectionMode, enableGrouping]);
```

This forces AG Grid to use the legacy CSS-based theming system (v32 style), preventing the conflict.

### Other AG Grid Configuration

```typescript
gridOptions = useMemo(() => ({
  rowHeight: virtualRowHeight,
  headerHeight: 40,
  floatingFiltersHeight: 40,
  suppressRowClickSelection: !enableSelection,
  rowSelection: enableSelection ? selectionMode : undefined,
  animateRows: true,

  // FIX: Disable charts to avoid error #200 (requires IntegratedChartsModule)
  enableCharts: false,

  // FIX: Use cellSelection instead of deprecated enableRangeSelection
  cellSelection: true,

  // FIX: Use legacy theme (see above)
  theme: 'legacy' as any,

  statusBar: {
    statusPanels: [
      { statusPanel: 'agTotalAndFilteredRowCountComponent', align: 'left' },
      { statusPanel: 'agSelectedRowCountComponent', align: 'center' },
      { statusPanel: 'agAggregationComponent', align: 'right' },
    ],
  },

  sideBar: enableGrouping ? { /* ... */ } : false,
}), [virtualRowHeight, enableSelection, selectionMode, enableGrouping]);
```

---

## Version History

- **2025-12-05 (v2.2):** Build process documentation overhaul
  - Documented `buildguiv2.ps1` as the recommended build method
  - Added detailed webpack config comparison table
  - Clarified `webpack.renderer.config.js` vs `webpack.renderer-standalone.config.js`
  - Added common build mistakes section
  - Documented the UI improvements from using correct renderer config (full Tailwind, dark mode, component library)

- **2025-12-01 (v2.1):** Exchange Discovery PascalCase fix and date parsing
  - Added PowerShell Date Serialization Pattern section
  - Documented `parsePowerShellDate` utility function
  - Added complete Exchange Discovery PascalCase fix documentation
  - Documented all 24 column field name changes (Mailboxes, Groups, Rules)
  - Added AG Grid theme configuration section
  - Added debug logging patterns for field name verification
  - Emphasized THE #1 BUG: PascalCase vs camelCase mismatch

- **2025-11-30 (v2.0):** Complete rewrite based on FileSystem Discovery implementation
  - Added CRITICAL PascalCase property casing section (THE #1 BUG)
  - Documented AG Grid integration patterns
  - Added comprehensive debugging techniques
  - Removed outdated/incorrect patterns
  - Simplified and clarified all sections
  - Added real working examples from FileSystemDiscovery.psm1
  - Removed nested directory disaster section (resolved)
  - Focused on battle-tested patterns that actually work
